
serial_can:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002a20  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000300  20000000  00002a20  00010000  2**2
                  ALLOC
  2 .debug_abbrev 000018c6  00000000  00000000  0000aa20  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   00004aae  00000000  00000000  0000c2e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_line   00001565  00000000  00000000  00010d94  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_frame  00000f14  00000000  00000000  000122fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00001898  00000000  00000000  00013210  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 000011c5  00000000  00000000  00014aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000240  00000000  00000000  00015c6d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001b75  00000000  00000000  00015ead  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      00000306  00000000  00000000  00017a22  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 00000031  00000000  00000000  00017d28  2**0
                  CONTENTS, READONLY
 12 .debug_ranges 000000c0  00000000  00000000  00017d59  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <_pointers>:
       0:	20002000 	.word	0x20002000

00000004 <vectors>:
       4:	000000e5 000000e1 000000e1 000000e1     ................
      14:	000000e1 000000e1 000000e1 000000e1     ................
      24:	000000e1 000000e1 000000e1 000000e1     ................
      34:	000000e1 000000e1 0000076d 000000e1     ........m.......
      44:	000000e1 000000e1 000000e1 000000e1     ................
      54:	000000e1 000000e1 000000e1 000000e1     ................
      64:	000000e1 000000e1 000000e1 000000e1     ................
      74:	000000e1 000000e1 000000e1 000000e1     ................
      84:	000000e1 000000e1 000000e1 00000561     ............a...
      94:	000000e1 000000e1 000000e1 000000e1     ................
      a4:	000000e1 000000e1 000000e1 000000e1     ................
      b4:	000000e1 000000e1 000000e1 000000e1     ................
      c4:	000000e1 000000e1 000000e1 000000e1     ................
      d4:	0000060d 000000e1 000000e1              ............

000000e0 <no_handler>:

/* ---------------------------------------------------------------------------
 * The function will be started after RESET.
 * ------------------------------------------------------------------------ */

void no_handler() {
      e0:	e7fe      	b.n	e0 <no_handler>
      e2:	46c0      	nop			(mov r8, r8)

000000e4 <sysinit>:

t_queue usart2can;
t_queue can2usart;
const unsigned int f_cpu = CLOCK_FREQ * PLL_FACTOR;

void sysinit() {
      e4:	b530      	push	{r4, r5, lr}
      e6:	b083      	sub	sp, #12
//    unsigned char *ptr;
    NVIC_InitTypeDef NVIC_InitStructure;

    /* If the CLOCK_QUARTZ is 1, the main oscillator will be enabled */
    clock_enable_main_osc();
      e8:	f000 fc76 	bl	9d8 <clock_enable_main_osc>
    /* If the CLOCK_PLL is 1, the PLL will be enabled (requires main oscillator) */
    clock_enable_pll();
      ec:	f000 fc6a 	bl	9c4 <clock_enable_pll>

    /* Low level initialization of the GPIO ports */
    gpio_init();
      f0:	f000 fcba 	bl	a68 <gpio_init>
    usart_init(USART_BAUDRATE);
      f4:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
      f8:	f000 fe06 	bl	d08 <usart_init>
    CAN_init(f_cpu / 32 / CAN_BAUDRATE - 1);
      fc:	2059      	movs	r0, #89
      fe:	f000 fd6d 	bl	bdc <CAN_init>
    CAN_set_filter(0, 0, 0);
     102:	2000      	movs	r0, #0
     104:	4601      	mov	r1, r0
     106:	4602      	mov	r2, r0
     108:	f000 fd26 	bl	b58 <CAN_set_filter>

    cr_needed = line_len = 0;
     10c:	4a19      	ldr	r2, [pc, #100]	(174 <sysinit+0x90>)
     10e:	4b1a      	ldr	r3, [pc, #104]	(178 <sysinit+0x94>)
     110:	2100      	movs	r1, #0
     112:	6019      	str	r1, [r3, #0]
     114:	6011      	str	r1, [r2, #0]
    queue_init(&usart2can);
     116:	4819      	ldr	r0, [pc, #100]	(17c <sysinit+0x98>)
     118:	f000 f9a0 	bl	45c <queue_init>
    queue_init(&can2usart);
     11c:	4818      	ldr	r0, [pc, #96]	(180 <sysinit+0x9c>)
     11e:	f000 f99d 	bl	45c <queue_init>

    /* Initialization of the Systick Timer */
    systick_init(4);
     122:	2004      	movs	r0, #4
     124:	f000 fc7c 	bl	a20 <systick_init>
    // NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);

    /* Enable the USART1 Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;
    // NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
     128:	2401      	movs	r4, #1

    /* Configure the NVIC Preemption Priority Bits */
    // NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);

    /* Enable the USART1 Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;
     12a:	2325      	movs	r3, #37
    // NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
     12c:	4668      	mov	r0, sp

    /* Configure the NVIC Preemption Priority Bits */
    // NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);

    /* Enable the USART1 Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;
     12e:	f88d 3000 	strb.w	r3, [sp]
    // NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
     132:	9401      	str	r4, [sp, #4]
    NVIC_Init(&NVIC_InitStructure);
     134:	f002 f9a4 	bl	2480 <NVIC_Init>
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
     138:	f643 0000 	movw	r0, #14336	; 0x3800
     13c:	f240 5125 	movw	r1, #1317	; 0x525
     140:	4622      	mov	r2, r4
     142:	f2c4 0001 	movt	r0, #16385	; 0x4001
     146:	f001 ff81 	bl	204c <USART_ITConfig>

    /* Enable CAN RX0 interrupt IRQ channel */
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN_RX0_IRQChannel;
     14a:	2314      	movs	r3, #20
    // NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    // NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
     14c:	4668      	mov	r0, sp
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);

    /* Enable CAN RX0 interrupt IRQ channel */
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN_RX0_IRQChannel;
     14e:	f88d 3000 	strb.w	r3, [sp]
    // NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    // NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
     152:	9401      	str	r4, [sp, #4]
    NVIC_Init(&NVIC_InitStructure);
     154:	f002 f994 	bl	2480 <NVIC_Init>

    /* CAN FIFO0 and FIFO1 message pending interrupt enable */
    CAN_ITConfig(CAN_IT_FMP0, ENABLE);
     158:	2002      	movs	r0, #2
     15a:	4621      	mov	r1, r4
     15c:	f001 fc90 	bl	1a80 <CAN_ITConfig>
    CAN_ITConfig(CAN_IT_FMP1, ENABLE);
     160:	2010      	movs	r0, #16
     162:	4621      	mov	r1, r4
     164:	f001 fc8c 	bl	1a80 <CAN_ITConfig>

    while (1)
        main();
     168:	f000 f80c 	bl	184 <main>
     16c:	f000 f80a 	bl	184 <main>
     170:	e7fa      	b.n	168 <sysinit+0x84>
     172:	46c0      	nop			(mov r8, r8)
     174:	200002cc 	.word	0x200002cc
     178:	200002d4 	.word	0x200002d4
     17c:	20000110 	.word	0x20000110
     180:	20000008 	.word	0x20000008

00000184 <main>:
volatile t_queue can2usart;
volatile unsigned int can_baudrate;
volatile unsigned int can_filter[14], can_id[14];
extern const unsigned int f_cpu;

int main() {
     184:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                    // tq = 1/(f_cpu / 2) * (BRD+1) = 2/f_cpu * (BRD+1)
                    // bitrate = 1 / [2/f_cpu * 16 * (BRD+1)] = 
                    //     = f_cpu / [32 * (BRD+1)]
                    // BRD+1 = f_cpu / 32 / bitrate
                    // BRD = f_cpu / 32 / bitrate - 1
                    CAN_set_prescaler(f_cpu / 32 / can_baudrate - 1);
     188:	4a9c      	ldr	r2, [pc, #624]	(3fc <main+0x278>)
    char str[MAX_STR_LEN];

    /* A small message */
    t_message *pmsg;

    can_baudrate = CAN_BAUDRATE;
     18a:	f8df a2c4 	ldr.w	sl, [pc, #708]	; 450 <main+0x2cc>
     18e:	f246 13a8 	movw	r3, #25000	; 0x61a8
     192:	f8ca 3000 	str.w	r3, [sl]
                    // tq = 1/(f_cpu / 2) * (BRD+1) = 2/f_cpu * (BRD+1)
                    // bitrate = 1 / [2/f_cpu * 16 * (BRD+1)] = 
                    //     = f_cpu / [32 * (BRD+1)]
                    // BRD+1 = f_cpu / 32 / bitrate
                    // BRD = f_cpu / 32 / bitrate - 1
                    CAN_set_prescaler(f_cpu / 32 / can_baudrate - 1);
     196:	6813      	ldr	r3, [r2, #0]
volatile t_queue can2usart;
volatile unsigned int can_baudrate;
volatile unsigned int can_filter[14], can_id[14];
extern const unsigned int f_cpu;

int main() {
     198:	b093      	sub	sp, #76
     19a:	f8df b2b8 	ldr.w	fp, [pc, #696]	; 454 <main+0x2d0>
     19e:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 458 <main+0x2d4>
                    // tq = 1/(f_cpu / 2) * (BRD+1) = 2/f_cpu * (BRD+1)
                    // bitrate = 1 / [2/f_cpu * 16 * (BRD+1)] = 
                    //     = f_cpu / [32 * (BRD+1)]
                    // BRD+1 = f_cpu / 32 / bitrate
                    // BRD = f_cpu / 32 / bitrate - 1
                    CAN_set_prescaler(f_cpu / 32 / can_baudrate - 1);
     1a2:	ea4f 1953 	mov.w	r9, r3, lsr #5
     1a6:	af11      	add	r7, sp, #68
     1a8:	ae01      	add	r6, sp, #4
    t_message *pmsg;

    can_baudrate = CAN_BAUDRATE;

    while (1) {
        if (queue_get_non_blocking((t_queue *) &usart2can, &pmsg) == QUEUE_OK) {
     1aa:	4895      	ldr	r0, [pc, #596]	(400 <main+0x27c>)
     1ac:	4639      	mov	r1, r7
     1ae:	f000 f985 	bl	4bc <queue_get_non_blocking>
     1b2:	4605      	mov	r5, r0
     1b4:	2800      	cmp	r0, #0
     1b6:	d13b      	bne.n	230 <main+0xac>
            switch (pmsg->command) {
     1b8:	9b11      	ldr	r3, [sp, #68]
     1ba:	681c      	ldr	r4, [r3, #0]
     1bc:	2c03      	cmp	r4, #3
     1be:	f000 8084 	beq.w	2ca <main+0x146>
     1c2:	f200 80c3 	bhi.w	34c <main+0x1c8>
     1c6:	2c01      	cmp	r4, #1
     1c8:	f000 80f9 	beq.w	3be <main+0x23a>
     1cc:	f240 80f0 	bls.w	3b0 <main+0x22c>
                    CAN_set_filter(0, 0, 0);
                    CAN_set_filter(1, 0x1fffffff, 0);
                    break;

                case CAN_SET_BAUD:
                    can_baudrate = pmsg->param1;
     1d0:	685b      	ldr	r3, [r3, #4]
     1d2:	f8ca 3000 	str.w	r3, [sl]
                    CAN_set_prescaler(f_cpu / 32 / can_baudrate - 1);
     1d6:	f8da 0000 	ldr.w	r0, [sl]
     1da:	fbb9 f0f0 	udiv	r0, r9, r0
     1de:	3801      	subs	r0, #1
     1e0:	f000 fcd8 	bl	b94 <CAN_set_prescaler>

                    usart_send_str("+ Baud rate: 0x");
     1e4:	4887      	ldr	r0, [pc, #540]	(404 <main+0x280>)
     1e6:	f000 fdcf 	bl	d88 <usart_send_str>
                    num2hex(can_baudrate, str, 8);
     1ea:	4631      	mov	r1, r6
     1ec:	2208      	movs	r2, #8
     1ee:	f8da 0000 	ldr.w	r0, [sl]
     1f2:	f000 fb15 	bl	820 <num2hex>
                    usart_send_str(str);
     1f6:	4630      	mov	r0, r6
     1f8:	f000 fdc6 	bl	d88 <usart_send_str>

                    usart_send_str(", divisor: 0x");
     1fc:	4882      	ldr	r0, [pc, #520]	(408 <main+0x284>)
     1fe:	f000 fdc3 	bl	d88 <usart_send_str>
                    num2hex(f_cpu / 32 / can_baudrate - 1, str, 8);
     202:	f8da 0000 	ldr.w	r0, [sl]
     206:	fbb9 f0f0 	udiv	r0, r9, r0
     20a:	3801      	subs	r0, #1
                        usart_send_str(": Mask: 0x");
                        num2hex(can_filter[pmsg->param1], str, 8);
                        usart_send_str(str);

                        usart_send_str(", Id: 0x");
                        num2hex(can_id[pmsg->param1], str, 8);
     20c:	4631      	mov	r1, r6
     20e:	2208      	movs	r2, #8
     210:	f000 fb06 	bl	820 <num2hex>
                        usart_send_str(str);
     214:	4630      	mov	r0, r6
     216:	f000 fdb7 	bl	d88 <usart_send_str>
                default:
                    usart_send_str("- Internal error! Stop using this device!");
                    break;
            }

            if (cr_needed)
     21a:	f8d8 3000 	ldr.w	r3, [r8]
     21e:	2b00      	cmp	r3, #0
     220:	f000 808c 	beq.w	33c <main+0x1b8>
                usart_send_str("\r\n");
     224:	4879      	ldr	r0, [pc, #484]	(40c <main+0x288>)
     226:	f000 fdaf 	bl	d88 <usart_send_str>
            else
                usart_send_str("\n");

            queue_remove((t_queue *) &usart2can);
     22a:	4875      	ldr	r0, [pc, #468]	(400 <main+0x27c>)
     22c:	f000 f962 	bl	4f4 <queue_remove>
        }

        if (queue_get_non_blocking((t_queue *) &can2usart, &pmsg) == QUEUE_OK) {
     230:	4877      	ldr	r0, [pc, #476]	(410 <main+0x28c>)
     232:	4639      	mov	r1, r7
     234:	f000 f942 	bl	4bc <queue_get_non_blocking>
     238:	2800      	cmp	r0, #0
     23a:	d1b6      	bne.n	1aa <main+0x26>
            usart_send_str("# id: 0x");
     23c:	4875      	ldr	r0, [pc, #468]	(414 <main+0x290>)
     23e:	f000 fda3 	bl	d88 <usart_send_str>
            num2hex(pmsg->param1 & 0x1fffffff, str, 8);
     242:	9b11      	ldr	r3, [sp, #68]
     244:	4631      	mov	r1, r6
     246:	6858      	ldr	r0, [r3, #4]
     248:	2208      	movs	r2, #8
     24a:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
     24e:	f000 fae7 	bl	820 <num2hex>
            usart_send_str(str);
     252:	4630      	mov	r0, r6
     254:	f000 fd98 	bl	d88 <usart_send_str>

            usart_send_str(", length: ");
     258:	486f      	ldr	r0, [pc, #444]	(418 <main+0x294>)
     25a:	f000 fd95 	bl	d88 <usart_send_str>
            num2hex((pmsg->param1 >> 29) + 1, str, 8);
     25e:	9b11      	ldr	r3, [sp, #68]
     260:	4631      	mov	r1, r6
     262:	6858      	ldr	r0, [r3, #4]
     264:	2208      	movs	r2, #8
     266:	0f40      	lsrs	r0, r0, #29
     268:	3001      	adds	r0, #1
     26a:	f000 fad9 	bl	820 <num2hex>
            usart_send_str(str);
     26e:	4630      	mov	r0, r6
     270:	f000 fd8a 	bl	d88 <usart_send_str>

            usart_send_str(", data: 0x");
     274:	4869      	ldr	r0, [pc, #420]	(41c <main+0x298>)
     276:	f000 fd87 	bl	d88 <usart_send_str>
            num2hex(pmsg->param2, str, 8);
     27a:	9b11      	ldr	r3, [sp, #68]
     27c:	4631      	mov	r1, r6
     27e:	6898      	ldr	r0, [r3, #8]
     280:	2208      	movs	r2, #8
     282:	f000 facd 	bl	820 <num2hex>
            usart_send_str(str);
     286:	4630      	mov	r0, r6
     288:	f000 fd7e 	bl	d88 <usart_send_str>
            num2hex(pmsg->param3, str, 8);
     28c:	9b11      	ldr	r3, [sp, #68]
     28e:	4631      	mov	r1, r6
     290:	68d8      	ldr	r0, [r3, #12]
     292:	2208      	movs	r2, #8
     294:	f000 fac4 	bl	820 <num2hex>
            usart_send_str(str);
     298:	4630      	mov	r0, r6
     29a:	f000 fd75 	bl	d88 <usart_send_str>

            if (cr_needed)
     29e:	f8d8 3000 	ldr.w	r3, [r8]
     2a2:	2b00      	cmp	r3, #0
     2a4:	d04e      	beq.n	344 <main+0x1c0>
                usart_send_str("\r\n");
     2a6:	4859      	ldr	r0, [pc, #356]	(40c <main+0x288>)
     2a8:	f000 fd6e 	bl	d88 <usart_send_str>
            else
                usart_send_str("\n");

            queue_remove((t_queue *) &can2usart);
     2ac:	4858      	ldr	r0, [pc, #352]	(410 <main+0x28c>)
     2ae:	f000 f921 	bl	4f4 <queue_remove>
    t_message *pmsg;

    can_baudrate = CAN_BAUDRATE;

    while (1) {
        if (queue_get_non_blocking((t_queue *) &usart2can, &pmsg) == QUEUE_OK) {
     2b2:	4853      	ldr	r0, [pc, #332]	(400 <main+0x27c>)
     2b4:	4639      	mov	r1, r7
     2b6:	f000 f901 	bl	4bc <queue_get_non_blocking>
     2ba:	4605      	mov	r5, r0
     2bc:	2800      	cmp	r0, #0
     2be:	d1b7      	bne.n	230 <main+0xac>
            switch (pmsg->command) {
     2c0:	9b11      	ldr	r3, [sp, #68]
     2c2:	681c      	ldr	r4, [r3, #0]
     2c4:	2c03      	cmp	r4, #3
     2c6:	f47f af7c 	bne.w	1c2 <main+0x3e>
                    num2hex(f_cpu / 32 / can_baudrate - 1, str, 8);
                    usart_send_str(str);
                    break;

                case CAN_SET_FILTER:
                    if ((pmsg->param1 < 14) && (pmsg->param1 >= 0)) {
     2ca:	6858      	ldr	r0, [r3, #4]
     2cc:	280d      	cmp	r0, #13
     2ce:	f200 808c 	bhi.w	3ea <main+0x266>
                        can_filter[pmsg->param1] = pmsg->param2 & 0x1fffffff;
     2d2:	689b      	ldr	r3, [r3, #8]
     2d4:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
     2d8:	f84b 3020 	str.w	r3, [fp, r0, lsl #2]
                        CAN_set_filter(pmsg->param1, can_filter[pmsg->param1],
     2dc:	f240 2350 	movw	r3, #592	; 0x250
     2e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
     2e4:	f85b 1020 	ldr.w	r1, [fp, r0, lsl #2]
     2e8:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
     2ec:	f000 fc34 	bl	b58 <CAN_set_filter>
                            can_id[pmsg->param1]);

                        usart_send_str("+ Filter 0x");
     2f0:	484b      	ldr	r0, [pc, #300]	(420 <main+0x29c>)
     2f2:	f000 fd49 	bl	d88 <usart_send_str>
                        num2hex(pmsg->param1, str, 1);
     2f6:	9b11      	ldr	r3, [sp, #68]
     2f8:	4631      	mov	r1, r6
     2fa:	6858      	ldr	r0, [r3, #4]
     2fc:	2201      	movs	r2, #1
     2fe:	f000 fa8f 	bl	820 <num2hex>
                        usart_send_str(str);
     302:	4630      	mov	r0, r6
     304:	f000 fd40 	bl	d88 <usart_send_str>

                        usart_send_str(": Mask: 0x");
     308:	4846      	ldr	r0, [pc, #280]	(424 <main+0x2a0>)
     30a:	f000 fd3d 	bl	d88 <usart_send_str>
                        num2hex(can_filter[pmsg->param1], str, 8);
     30e:	9b11      	ldr	r3, [sp, #68]
     310:	4631      	mov	r1, r6
     312:	685a      	ldr	r2, [r3, #4]
     314:	f85b 0022 	ldr.w	r0, [fp, r2, lsl #2]
     318:	2208      	movs	r2, #8
     31a:	f000 fa81 	bl	820 <num2hex>
                        usart_send_str(str);
     31e:	4630      	mov	r0, r6
     320:	f000 fd32 	bl	d88 <usart_send_str>

                        usart_send_str(", Id: 0x");
     324:	4840      	ldr	r0, [pc, #256]	(428 <main+0x2a4>)
     326:	f000 fd2f 	bl	d88 <usart_send_str>
                        num2hex(can_id[pmsg->param1], str, 8);
     32a:	9b11      	ldr	r3, [sp, #68]
     32c:	f240 2150 	movw	r1, #592	; 0x250
     330:	685a      	ldr	r2, [r3, #4]
     332:	f2c2 0100 	movt	r1, #8192	; 0x2000
     336:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
     33a:	e767      	b.n	20c <main+0x88>
            }

            if (cr_needed)
                usart_send_str("\r\n");
            else
                usart_send_str("\n");
     33c:	483b      	ldr	r0, [pc, #236]	(42c <main+0x2a8>)
     33e:	f000 fd23 	bl	d88 <usart_send_str>
     342:	e772      	b.n	22a <main+0xa6>
            usart_send_str(str);

            if (cr_needed)
                usart_send_str("\r\n");
            else
                usart_send_str("\n");
     344:	4839      	ldr	r0, [pc, #228]	(42c <main+0x2a8>)
     346:	f000 fd1f 	bl	d88 <usart_send_str>
     34a:	e7af      	b.n	2ac <main+0x128>

    can_baudrate = CAN_BAUDRATE;

    while (1) {
        if (queue_get_non_blocking((t_queue *) &usart2can, &pmsg) == QUEUE_OK) {
            switch (pmsg->command) {
     34c:	2c05      	cmp	r4, #5
     34e:	d020      	beq.n	392 <main+0x20e>
     350:	d30a      	bcc.n	368 <main+0x1e4>
     352:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
     356:	d003      	beq.n	360 <main+0x1dc>
                case CAN_UNKNOWN:
                    usart_send_str("- Unknown message arrived.");
                    break;

                default:
                    usart_send_str("- Internal error! Stop using this device!");
     358:	4835      	ldr	r0, [pc, #212]	(430 <main+0x2ac>)
     35a:	f000 fd15 	bl	d88 <usart_send_str>
     35e:	e75c      	b.n	21a <main+0x96>
                        usart_send_str("- Unable to send message.");
                    }
                    break;

                case CAN_UNKNOWN:
                    usart_send_str("- Unknown message arrived.");
     360:	4834      	ldr	r0, [pc, #208]	(434 <main+0x2b0>)
     362:	f000 fd11 	bl	d88 <usart_send_str>
     366:	e758      	b.n	21a <main+0x96>
                    }

                    break;

                case CAN_SET_ID:
                    if ((pmsg->param1 < 14) && (pmsg->param1 >= 0)) {
     368:	685a      	ldr	r2, [r3, #4]
     36a:	2a0d      	cmp	r2, #13
     36c:	d83d      	bhi.n	3ea <main+0x266>
                        can_id[pmsg->param1] = pmsg->param2 & 0x1fffffff;
     36e:	689b      	ldr	r3, [r3, #8]
     370:	f240 2150 	movw	r1, #592	; 0x250
     374:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
     378:	f2c2 0100 	movt	r1, #8192	; 0x2000
     37c:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
                        CAN_set_filter(0, can_filter[pmsg->param1], can_id[pmsg->param1]);
     380:	f240 2350 	movw	r3, #592	; 0x250
     384:	f2c2 0300 	movt	r3, #8192	; 0x2000
     388:	f85b 1022 	ldr.w	r1, [fp, r2, lsl #2]
     38c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
     390:	e7ac      	b.n	2ec <main+0x168>
                    }

                    break;

                case CAN_SEND:
                    if (CAN_send(pmsg->param1 & 0x1fffffff, 
     392:	6858      	ldr	r0, [r3, #4]
     394:	689a      	ldr	r2, [r3, #8]
     396:	0f41      	lsrs	r1, r0, #29
     398:	3101      	adds	r1, #1
     39a:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
     39e:	68db      	ldr	r3, [r3, #12]
     3a0:	f000 fb9e 	bl	ae0 <CAN_send>
     3a4:	2801      	cmp	r0, #1
     3a6:	d024      	beq.n	3f2 <main+0x26e>
                                 (pmsg->param1 >> 29) + 1, 
                                 pmsg->param2, pmsg->param3) == CANTXOK) {
                        usart_send_str("+ Message successfully sent.");
                    } else {
                        usart_send_str("- Unable to send message.");
     3a8:	4823      	ldr	r0, [pc, #140]	(438 <main+0x2b4>)
     3aa:	f000 fced 	bl	d88 <usart_send_str>
     3ae:	e734      	b.n	21a <main+0x96>

    while (1) {
        if (queue_get_non_blocking((t_queue *) &usart2can, &pmsg) == QUEUE_OK) {
            switch (pmsg->command) {
                case CAN_VERSION:
                    usart_send_str("+ SER_CAN: ");
     3b0:	4822      	ldr	r0, [pc, #136]	(43c <main+0x2b8>)
     3b2:	f000 fce9 	bl	d88 <usart_send_str>
                    usart_send_str(DEV_VERSION);
     3b6:	4822      	ldr	r0, [pc, #136]	(440 <main+0x2bc>)
     3b8:	f000 fce6 	bl	d88 <usart_send_str>
     3bc:	e72d      	b.n	21a <main+0x96>
                    // tq = 1/(f_cpu / 2) * (BRD+1) = 2/f_cpu * (BRD+1)
                    // bitrate = 1 / [2/f_cpu * 16 * (BRD+1)] = 
                    //     = f_cpu / [32 * (BRD+1)]
                    // BRD+1 = f_cpu / 32 / bitrate
                    // BRD = f_cpu / 32 / bitrate - 1
                    CAN_set_prescaler(f_cpu / 32 / can_baudrate - 1);
     3be:	f8da 0000 	ldr.w	r0, [sl]
     3c2:	fbb9 f0f0 	udiv	r0, r9, r0
     3c6:	3801      	subs	r0, #1
     3c8:	f000 fbe4 	bl	b94 <CAN_set_prescaler>
                    usart_send_str("+ Successfully initialized.");
     3cc:	481d      	ldr	r0, [pc, #116]	(444 <main+0x2c0>)
     3ce:	f000 fcdb 	bl	d88 <usart_send_str>
                    CAN_set_filter(0, 0, 0);
     3d2:	4628      	mov	r0, r5
     3d4:	4629      	mov	r1, r5
     3d6:	462a      	mov	r2, r5
     3d8:	f000 fbbe 	bl	b58 <CAN_set_filter>
                    CAN_set_filter(1, 0x1fffffff, 0);
     3dc:	4620      	mov	r0, r4
     3de:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
     3e2:	462a      	mov	r2, r5
     3e4:	f000 fbb8 	bl	b58 <CAN_set_filter>
     3e8:	e717      	b.n	21a <main+0x96>

                        usart_send_str(", Id: 0x");
                        num2hex(can_id[pmsg->param1], str, 8);
                        usart_send_str(str);
                    } else {
                        usart_send_str("- Invalid filter number.");
     3ea:	4817      	ldr	r0, [pc, #92]	(448 <main+0x2c4>)
     3ec:	f000 fccc 	bl	d88 <usart_send_str>
     3f0:	e713      	b.n	21a <main+0x96>

                case CAN_SEND:
                    if (CAN_send(pmsg->param1 & 0x1fffffff, 
                                 (pmsg->param1 >> 29) + 1, 
                                 pmsg->param2, pmsg->param3) == CANTXOK) {
                        usart_send_str("+ Message successfully sent.");
     3f2:	4816      	ldr	r0, [pc, #88]	(44c <main+0x2c8>)
     3f4:	f000 fcc8 	bl	d88 <usart_send_str>
     3f8:	e70f      	b.n	21a <main+0x96>
     3fa:	46c0      	nop			(mov r8, r8)
     3fc:	0000288c 	.word	0x0000288c
     400:	10          	.byte	0x10
     401:	01          	.byte	0x01
     402:	2000      	.short	0x2000
     404:	000028e8 	.word	0x000028e8
     408:	000028f8 	.word	0x000028f8
     40c:	000029cc 	.word	0x000029cc
     410:	20000008 	.word	0x20000008
     414:	000029d4 	.word	0x000029d4
     418:	000029e0 	.word	0x000029e0
     41c:	000029ec 	.word	0x000029ec
     420:	00002908 	.word	0x00002908
     424:	00002914 	.word	0x00002914
     428:	00002920 	.word	0x00002920
     42c:	000029d0 	.word	0x000029d0
     430:	000029a0 	.word	0x000029a0
     434:	00002984 	.word	0x00002984
     438:	00002968 	.word	0x00002968
     43c:	00002890 	.word	0x00002890
     440:	0000289c 	.word	0x0000289c
     444:	000028cc 	.word	0x000028cc
     448:	0000292c 	.word	0x0000292c
     44c:	00002948 	.word	0x00002948
     450:	20000288 	.word	0x20000288
     454:	20000218 	.word	0x20000218
     458:	200002cc 	.word	0x200002cc

0000045c <queue_init>:
#include <queue.h>

void queue_init (t_queue *queue) {
    queue->rd_ptr = 0;
     45c:	2300      	movs	r3, #0
     45e:	6103      	str	r3, [r0, #16]
    queue->wr_ptr = 0;
     460:	6143      	str	r3, [r0, #20]
}
     462:	4770      	bx	lr

00000464 <queue_put_non_blocking>:

t_queue_result queue_put_non_blocking(t_queue *queue, t_message *msg) {
     464:	b410      	push	{r4}
    int k;

    if ((queue->wr_ptr != queue->rd_ptr) && ((queue->wr_ptr % QUEUE_SIZE) == (queue->rd_ptr % QUEUE_SIZE))) {
     466:	6903      	ldr	r3, [r0, #16]
     468:	6944      	ldr	r4, [r0, #20]
     46a:	429c      	cmp	r4, r3
     46c:	d002      	beq.n	474 <queue_put_non_blocking+0x10>
     46e:	2001      	movs	r0, #1

        queue->wr_ptr++;

        return QUEUE_OK;
    }
}
     470:	bc10      	pop	{r4}
     472:	4770      	bx	lr

    if ((queue->wr_ptr != queue->rd_ptr) && ((queue->wr_ptr % QUEUE_SIZE) == (queue->rd_ptr % QUEUE_SIZE))) {
        return QUEUE_FULL;
    } else {
        for (k = 0; k < sizeof(t_message); k++)
            ((char *)(&(queue->data[queue->wr_ptr % QUEUE_SIZE])))[k] = ((char *)msg)[k];
     474:	780b      	ldrb	r3, [r1, #0]
     476:	7003      	strb	r3, [r0, #0]
     478:	784a      	ldrb	r2, [r1, #1]
     47a:	7042      	strb	r2, [r0, #1]
     47c:	788b      	ldrb	r3, [r1, #2]
     47e:	7083      	strb	r3, [r0, #2]
     480:	78ca      	ldrb	r2, [r1, #3]
     482:	70c2      	strb	r2, [r0, #3]
     484:	790b      	ldrb	r3, [r1, #4]
     486:	7103      	strb	r3, [r0, #4]
     488:	794a      	ldrb	r2, [r1, #5]
     48a:	7142      	strb	r2, [r0, #5]
     48c:	798b      	ldrb	r3, [r1, #6]
     48e:	7183      	strb	r3, [r0, #6]
     490:	79ca      	ldrb	r2, [r1, #7]
     492:	71c2      	strb	r2, [r0, #7]
     494:	7a0b      	ldrb	r3, [r1, #8]
     496:	7203      	strb	r3, [r0, #8]
     498:	7a4a      	ldrb	r2, [r1, #9]
     49a:	7242      	strb	r2, [r0, #9]
     49c:	7a8b      	ldrb	r3, [r1, #10]
     49e:	7283      	strb	r3, [r0, #10]
     4a0:	7aca      	ldrb	r2, [r1, #11]
     4a2:	72c2      	strb	r2, [r0, #11]
     4a4:	7b0b      	ldrb	r3, [r1, #12]
     4a6:	7303      	strb	r3, [r0, #12]
     4a8:	7b4a      	ldrb	r2, [r1, #13]
     4aa:	7342      	strb	r2, [r0, #13]
     4ac:	7b8b      	ldrb	r3, [r1, #14]
     4ae:	7383      	strb	r3, [r0, #14]
     4b0:	7bca      	ldrb	r2, [r1, #15]

        queue->wr_ptr++;
     4b2:	1c63      	adds	r3, r4, #1

    if ((queue->wr_ptr != queue->rd_ptr) && ((queue->wr_ptr % QUEUE_SIZE) == (queue->rd_ptr % QUEUE_SIZE))) {
        return QUEUE_FULL;
    } else {
        for (k = 0; k < sizeof(t_message); k++)
            ((char *)(&(queue->data[queue->wr_ptr % QUEUE_SIZE])))[k] = ((char *)msg)[k];
     4b4:	73c2      	strb	r2, [r0, #15]

        queue->wr_ptr++;
     4b6:	6143      	str	r3, [r0, #20]
     4b8:	2000      	movs	r0, #0
     4ba:	e7d9      	b.n	470 <queue_put_non_blocking+0xc>

000004bc <queue_get_non_blocking>:
        return QUEUE_OK;
    }
}

t_queue_result queue_get_non_blocking(t_queue *queue, t_message **msg) {
    if (queue->rd_ptr == queue->wr_ptr) {
     4bc:	6902      	ldr	r2, [r0, #16]
     4be:	6943      	ldr	r3, [r0, #20]
     4c0:	429a      	cmp	r2, r3
     4c2:	d002      	beq.n	4ca <queue_get_non_blocking+0xe>
        return QUEUE_EMPTY;
    } else {
        *msg = &(queue->data[queue->rd_ptr % QUEUE_SIZE]);
     4c4:	6008      	str	r0, [r1, #0]
     4c6:	2000      	movs	r0, #0
        return QUEUE_OK;
    }
}
     4c8:	4770      	bx	lr
        return QUEUE_OK;
    }
}

t_queue_result queue_get_non_blocking(t_queue *queue, t_message **msg) {
    if (queue->rd_ptr == queue->wr_ptr) {
     4ca:	2002      	movs	r0, #2
     4cc:	e7fc      	b.n	4c8 <queue_get_non_blocking+0xc>
     4ce:	46c0      	nop			(mov r8, r8)

000004d0 <queue_remove_non_blocking>:
        return QUEUE_OK;
    }
}

t_queue_result queue_remove_non_blocking(t_queue *queue) {
    if (queue->rd_ptr == queue->wr_ptr) {
     4d0:	6902      	ldr	r2, [r0, #16]
     4d2:	6943      	ldr	r3, [r0, #20]
     4d4:	429a      	cmp	r2, r3
     4d6:	d003      	beq.n	4e0 <queue_remove_non_blocking+0x10>
        return QUEUE_EMPTY;
    } else {
        queue->rd_ptr++;
     4d8:	1c53      	adds	r3, r2, #1
     4da:	6103      	str	r3, [r0, #16]
     4dc:	2000      	movs	r0, #0
        return QUEUE_OK;
    }
}
     4de:	4770      	bx	lr
        return QUEUE_OK;
    }
}

t_queue_result queue_remove_non_blocking(t_queue *queue) {
    if (queue->rd_ptr == queue->wr_ptr) {
     4e0:	2002      	movs	r0, #2
     4e2:	e7fc      	b.n	4de <queue_remove_non_blocking+0xe>

000004e4 <queue_get>:
t_queue_result queue_put(t_queue *queue, t_message *msg) {
    while (queue_put_non_blocking(queue, msg) == QUEUE_FULL);
    return QUEUE_OK;
}

t_queue_result queue_get(t_queue *queue, t_message **msg) {
     4e4:	6902      	ldr	r2, [r0, #16]
     4e6:	6943      	ldr	r3, [r0, #20]
     4e8:	429a      	cmp	r2, r3
     4ea:	d002      	beq.n	4f2 <queue_get+0xe>

t_queue_result queue_get_non_blocking(t_queue *queue, t_message **msg) {
    if (queue->rd_ptr == queue->wr_ptr) {
        return QUEUE_EMPTY;
    } else {
        *msg = &(queue->data[queue->rd_ptr % QUEUE_SIZE]);
     4ec:	6008      	str	r0, [r1, #0]
}

t_queue_result queue_get(t_queue *queue, t_message **msg) {
    while (queue_get_non_blocking(queue, msg) == QUEUE_EMPTY);
    return QUEUE_OK;
}
     4ee:	2000      	movs	r0, #0
     4f0:	4770      	bx	lr
     4f2:	e7fe      	b.n	4f2 <queue_get+0xe>

000004f4 <queue_remove>:

t_queue_result queue_remove(t_queue *queue) {
     4f4:	6902      	ldr	r2, [r0, #16]
     4f6:	6943      	ldr	r3, [r0, #20]
     4f8:	4293      	cmp	r3, r2
     4fa:	d003      	beq.n	504 <queue_remove+0x10>

t_queue_result queue_remove_non_blocking(t_queue *queue) {
    if (queue->rd_ptr == queue->wr_ptr) {
        return QUEUE_EMPTY;
    } else {
        queue->rd_ptr++;
     4fc:	1c53      	adds	r3, r2, #1
     4fe:	6103      	str	r3, [r0, #16]
}

t_queue_result queue_remove(t_queue *queue) {
    while (queue_remove_non_blocking(queue) == QUEUE_EMPTY);
    return QUEUE_OK;
}
     500:	2000      	movs	r0, #0
     502:	4770      	bx	lr
     504:	e7fe      	b.n	504 <queue_remove+0x10>
     506:	46c0      	nop			(mov r8, r8)

00000508 <queue_put>:
        queue->rd_ptr++;
        return QUEUE_OK;
    }
}

t_queue_result queue_put(t_queue *queue, t_message *msg) {
     508:	b410      	push	{r4}
     50a:	6903      	ldr	r3, [r0, #16]
     50c:	6944      	ldr	r4, [r0, #20]
     50e:	429c      	cmp	r4, r3
     510:	d124      	bne.n	55c <queue_put+0x54>

    if ((queue->wr_ptr != queue->rd_ptr) && ((queue->wr_ptr % QUEUE_SIZE) == (queue->rd_ptr % QUEUE_SIZE))) {
        return QUEUE_FULL;
    } else {
        for (k = 0; k < sizeof(t_message); k++)
            ((char *)(&(queue->data[queue->wr_ptr % QUEUE_SIZE])))[k] = ((char *)msg)[k];
     512:	780b      	ldrb	r3, [r1, #0]
     514:	7003      	strb	r3, [r0, #0]
     516:	784a      	ldrb	r2, [r1, #1]
     518:	7042      	strb	r2, [r0, #1]
     51a:	788b      	ldrb	r3, [r1, #2]
     51c:	7083      	strb	r3, [r0, #2]
     51e:	78ca      	ldrb	r2, [r1, #3]
     520:	70c2      	strb	r2, [r0, #3]
     522:	790b      	ldrb	r3, [r1, #4]
     524:	7103      	strb	r3, [r0, #4]
     526:	794a      	ldrb	r2, [r1, #5]
     528:	7142      	strb	r2, [r0, #5]
     52a:	798b      	ldrb	r3, [r1, #6]
     52c:	7183      	strb	r3, [r0, #6]
     52e:	79ca      	ldrb	r2, [r1, #7]
     530:	71c2      	strb	r2, [r0, #7]
     532:	7a0b      	ldrb	r3, [r1, #8]
     534:	7203      	strb	r3, [r0, #8]
     536:	7a4a      	ldrb	r2, [r1, #9]
     538:	7242      	strb	r2, [r0, #9]
     53a:	7a8b      	ldrb	r3, [r1, #10]
     53c:	7283      	strb	r3, [r0, #10]
     53e:	7aca      	ldrb	r2, [r1, #11]
     540:	72c2      	strb	r2, [r0, #11]
     542:	7b0b      	ldrb	r3, [r1, #12]
     544:	7303      	strb	r3, [r0, #12]
     546:	7b4a      	ldrb	r2, [r1, #13]
     548:	7342      	strb	r2, [r0, #13]
     54a:	7b8b      	ldrb	r3, [r1, #14]
     54c:	7383      	strb	r3, [r0, #14]
     54e:	7bca      	ldrb	r2, [r1, #15]

        queue->wr_ptr++;
     550:	1c63      	adds	r3, r4, #1

    if ((queue->wr_ptr != queue->rd_ptr) && ((queue->wr_ptr % QUEUE_SIZE) == (queue->rd_ptr % QUEUE_SIZE))) {
        return QUEUE_FULL;
    } else {
        for (k = 0; k < sizeof(t_message); k++)
            ((char *)(&(queue->data[queue->wr_ptr % QUEUE_SIZE])))[k] = ((char *)msg)[k];
     552:	73c2      	strb	r2, [r0, #15]

        queue->wr_ptr++;
     554:	6143      	str	r3, [r0, #20]
}

t_queue_result queue_put(t_queue *queue, t_message *msg) {
    while (queue_put_non_blocking(queue, msg) == QUEUE_FULL);
    return QUEUE_OK;
}
     556:	2000      	movs	r0, #0
     558:	bc10      	pop	{r4}
     55a:	4770      	bx	lr
     55c:	e7fe      	b.n	55c <queue_put+0x54>
     55e:	46c0      	nop			(mov r8, r8)

00000560 <CAN_rx_handler>:

// ---------------------------------------------------------------------------
// When a message (frame) has been received through CAN controller...
// ---------------------------------------------------------------------------

void CAN_rx_handler() {
     560:	b510      	push	{r4, lr}
    t_message msg;
    CanRxMsg RxMessage;

    // Clean invalid data from the structure
    RxMessage.StdId = 0x00;
     562:	2400      	movs	r4, #0

// ---------------------------------------------------------------------------
// When a message (frame) has been received through CAN controller...
// ---------------------------------------------------------------------------

void CAN_rx_handler() {
     564:	b08a      	sub	sp, #40
    RxMessage.Data[5] = 0x00;
    RxMessage.Data[6] = 0x00;
    RxMessage.Data[7] = 0x00;

    // Copy data from CAN FIFO to structure
    CAN_Receive(CAN_FIFO0, &RxMessage);
     566:	4620      	mov	r0, r4
     568:	a901      	add	r1, sp, #4
void CAN_rx_handler() {
    t_message msg;
    CanRxMsg RxMessage;

    // Clean invalid data from the structure
    RxMessage.StdId = 0x00;
     56a:	9401      	str	r4, [sp, #4]
    RxMessage.ExtId = 0x00;
     56c:	9402      	str	r4, [sp, #8]
    RxMessage.IDE = 0;
     56e:	f88d 400c 	strb.w	r4, [sp, #12]
    RxMessage.DLC = 0;
     572:	f88d 400e 	strb.w	r4, [sp, #14]
    RxMessage.FMI = 0;
     576:	f88d 4017 	strb.w	r4, [sp, #23]
    RxMessage.Data[0] = 0x00;
     57a:	f88d 400f 	strb.w	r4, [sp, #15]
    RxMessage.Data[1] = 0x00;
     57e:	f88d 4010 	strb.w	r4, [sp, #16]
    RxMessage.Data[2] = 0x00;
     582:	f88d 4011 	strb.w	r4, [sp, #17]
    RxMessage.Data[3] = 0x00;
     586:	f88d 4012 	strb.w	r4, [sp, #18]
    RxMessage.Data[4] = 0x00;
     58a:	f88d 4013 	strb.w	r4, [sp, #19]
    RxMessage.Data[5] = 0x00;
     58e:	f88d 4014 	strb.w	r4, [sp, #20]
    RxMessage.Data[6] = 0x00;
     592:	f88d 4015 	strb.w	r4, [sp, #21]
    RxMessage.Data[7] = 0x00;
     596:	f88d 4016 	strb.w	r4, [sp, #22]

    // Copy data from CAN FIFO to structure
    CAN_Receive(CAN_FIFO0, &RxMessage);
     59a:	f001 fcd1 	bl	1f40 <CAN_Receive>

    // If it is in the acceptable format (with 29 bit addresses)...
    if (RxMessage.IDE == CAN_ID_EXT) {
     59e:	f89d 300c 	ldrb.w	r3, [sp, #12]
     5a2:	2b04      	cmp	r3, #4
     5a4:	d001      	beq.n	5aa <CAN_rx_handler+0x4a>

        // Send message to "main()", which will send it to "upper"
        // controller
        queue_put_non_blocking(&can2usart, &msg);
    }
}
     5a6:	b00a      	add	sp, #40
     5a8:	bd10      	pop	{r4, pc}
    CAN_Receive(CAN_FIFO0, &RxMessage);

    // If it is in the acceptable format (with 29 bit addresses)...
    if (RxMessage.IDE == CAN_ID_EXT) {
        // At least one byte of data has to be received (and sent!)
        if (RxMessage.DLC == 0) {
     5aa:	f89d 300e 	ldrb.w	r3, [sp, #14]
     5ae:	b913      	cbnz	r3, 5b6 <CAN_rx_handler+0x56>
            RxMessage.DLC = 1;
     5b0:	3301      	adds	r3, #1
     5b2:	f88d 300e 	strb.w	r3, [sp, #14]
        }

        // Preparing the massage to be sent to "main()" function
        msg.command = 0;
        msg.param1 = RxMessage.ExtId | (RxMessage.DLC - 1) << 29;
     5b6:	1e5a      	subs	r2, r3, #1
     5b8:	9b02      	ldr	r3, [sp, #8]
        msg.param2 = (RxMessage.Data[0] << 24) | (RxMessage.Data[1] << 16) |
     5ba:	f89d 100f 	ldrb.w	r1, [sp, #15]
            RxMessage.DLC = 1;
        }

        // Preparing the massage to be sent to "main()" function
        msg.command = 0;
        msg.param1 = RxMessage.ExtId | (RxMessage.DLC - 1) << 29;
     5be:	ea43 7342 	orr.w	r3, r3, r2, lsl #29
     5c2:	9307      	str	r3, [sp, #28]
        msg.param2 = (RxMessage.Data[0] << 24) | (RxMessage.Data[1] << 16) |
     5c4:	f89d 3010 	ldrb.w	r3, [sp, #16]
     5c8:	f89d 2012 	ldrb.w	r2, [sp, #18]
     5cc:	041b      	lsls	r3, r3, #16
     5ce:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
     5d2:	f89d 1011 	ldrb.w	r1, [sp, #17]
     5d6:	4313      	orrs	r3, r2
     5d8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
     5dc:	9308      	str	r3, [sp, #32]
                     (RxMessage.Data[2] << 8) | RxMessage.Data[3];
        msg.param3 = (RxMessage.Data[4] << 24) | (RxMessage.Data[5] << 16) |
     5de:	f89d 3014 	ldrb.w	r3, [sp, #20]
     5e2:	f89d 1013 	ldrb.w	r1, [sp, #19]
     5e6:	041b      	lsls	r3, r3, #16
     5e8:	f89d 2016 	ldrb.w	r2, [sp, #22]
     5ec:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
     5f0:	f89d 1015 	ldrb.w	r1, [sp, #21]
     5f4:	4313      	orrs	r3, r2
     5f6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                     (RxMessage.Data[6] << 8) | RxMessage.Data[7];

        // Send message to "main()", which will send it to "upper"
        // controller
        queue_put_non_blocking(&can2usart, &msg);
     5fa:	4803      	ldr	r0, [pc, #12]	(608 <CAN_rx_handler+0xa8>)
     5fc:	a906      	add	r1, sp, #24
        if (RxMessage.DLC == 0) {
            RxMessage.DLC = 1;
        }

        // Preparing the massage to be sent to "main()" function
        msg.command = 0;
     5fe:	9406      	str	r4, [sp, #24]
        msg.param1 = RxMessage.ExtId | (RxMessage.DLC - 1) << 29;
        msg.param2 = (RxMessage.Data[0] << 24) | (RxMessage.Data[1] << 16) |
                     (RxMessage.Data[2] << 8) | RxMessage.Data[3];
        msg.param3 = (RxMessage.Data[4] << 24) | (RxMessage.Data[5] << 16) |
     600:	9309      	str	r3, [sp, #36]
                     (RxMessage.Data[6] << 8) | RxMessage.Data[7];

        // Send message to "main()", which will send it to "upper"
        // controller
        queue_put_non_blocking(&can2usart, &msg);
     602:	f7ff ff2f 	bl	464 <queue_put_non_blocking>
     606:	e7ce      	b.n	5a6 <CAN_rx_handler+0x46>
     608:	20000008 	.word	0x20000008

0000060c <usart_rx_handler>:

// ---------------------------------------------------------------------------
// When a character has been received through USART...
// ---------------------------------------------------------------------------

void usart_rx_handler() {
     60c:	b530      	push	{r4, r5, lr}
    char ch;
    t_message msg;

    // If a new character is received
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
     60e:	f643 0000 	movw	r0, #14336	; 0x3800

// ---------------------------------------------------------------------------
// When a character has been received through USART...
// ---------------------------------------------------------------------------

void usart_rx_handler() {
     612:	b085      	sub	sp, #20
    char ch;
    t_message msg;

    // If a new character is received
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
     614:	f2c4 0001 	movt	r0, #16385	; 0x4001
     618:	f240 5125 	movw	r1, #1317	; 0x525
     61c:	f001 fdf6 	bl	220c <USART_GetITStatus>
     620:	b908      	cbnz	r0, 626 <usart_rx_handler+0x1a>
                line[line_len++] = ch;
                line[line_len] = 0;
            }
        }
    }
}
     622:	b005      	add	sp, #20
     624:	bd30      	pop	{r4, r5, pc}
    t_message msg;

    // If a new character is received
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
        // Switch on "Receiging..." LED
        gpio_set(LED_USART);
     626:	f44f 4080 	mov.w	r0, #16384	; 0x4000
     62a:	f000 fa13 	bl	a54 <gpio_set>

        // Read the character from the USART FIFO
        ch = usart_recv_char();
     62e:	f000 fb45 	bl	cbc <usart_recv_char>

        // A CR (Cursor Return) indicates that CR must be sent after
        // the answer string.

        if (ch == '\r') {
     632:	280d      	cmp	r0, #13
     634:	d00f      	beq.n	656 <usart_rx_handler+0x4a>
            cr_needed = 1;
        }

        // At the end of the command line...
        if ((ch == '\n') || (ch == '\r')) {
     636:	280a      	cmp	r0, #10
     638:	d010      	beq.n	65c <usart_rx_handler+0x50>
            line_len = 0;
            return;
        } else {
            // If one more character can be attached to the string 
            // (command line)...
            if (line_len + 1 < MAX_STR_LEN) {
     63a:	4a46      	ldr	r2, [pc, #280]	(754 <usart_rx_handler+0x148>)
     63c:	6813      	ldr	r3, [r2, #0]
     63e:	3301      	adds	r3, #1
     640:	2b3f      	cmp	r3, #63
     642:	d8ee      	bhi.n	622 <usart_rx_handler+0x16>
                // ... attach the character, and the terminator "zero"
                line[line_len++] = ch;
     644:	6813      	ldr	r3, [r2, #0]
     646:	4944      	ldr	r1, [pc, #272]	(758 <usart_rx_handler+0x14c>)
     648:	54c8      	strb	r0, [r1, r3]
     64a:	3301      	adds	r3, #1
     64c:	6013      	str	r3, [r2, #0]
                line[line_len] = 0;
     64e:	6812      	ldr	r2, [r2, #0]
     650:	2300      	movs	r3, #0
     652:	548b      	strb	r3, [r1, r2]
     654:	e7e5      	b.n	622 <usart_rx_handler+0x16>

        // A CR (Cursor Return) indicates that CR must be sent after
        // the answer string.

        if (ch == '\r') {
            cr_needed = 1;
     656:	4b41      	ldr	r3, [pc, #260]	(75c <usart_rx_handler+0x150>)
     658:	2201      	movs	r2, #1
     65a:	601a      	str	r2, [r3, #0]
        }

        // At the end of the command line...
        if ((ch == '\n') || (ch == '\r')) {
            // ... when the command starts with...
            switch (line[0]) {
     65c:	4a3e      	ldr	r2, [pc, #248]	(758 <usart_rx_handler+0x14c>)
     65e:	7813      	ldrb	r3, [r2, #0]
     660:	3b42      	subs	r3, #66
     662:	2b34      	cmp	r3, #52
     664:	d81c      	bhi.n	6a0 <usart_rx_handler+0x94>
     666:	e8df f003 	tbb	[pc, r3]
     66a:	1b67      	.short	0x1b67
     66c:	1b651b1b 	.word	0x1b651b1b
     670:	1b1b561b 	.word	0x1b1b561b
     674:	1b1b1b1b 	.word	0x1b1b1b1b
     678:	341b1b1b 	.word	0x341b1b1b
     67c:	1b2e1b1b 	.word	0x1b2e1b1b
     680:	1b1b1b1b 	.word	0x1b1b1b1b
     684:	1b1b1b1b 	.word	0x1b1b1b1b
     688:	1b671b1b 	.word	0x1b671b1b
     68c:	1b651b1b 	.word	0x1b651b1b
     690:	1b1b561b 	.word	0x1b1b561b
     694:	1b1b1b1b 	.word	0x1b1b1b1b
     698:	341b1b1b 	.word	0x341b1b1b
     69c:	002e1b1b 	.word	0x002e1b1b
                    break;

                default:
                    // When received an invalid command
                    msg.command = CAN_UNKNOWN;
                    msg.param1 = msg.param2 = msg.param3 = 0;
     6a0:	2300      	movs	r3, #0
                    msg.param3 = hex2num((char *) line+18, 8);
                    break;

                default:
                    // When received an invalid command
                    msg.command = CAN_UNKNOWN;
     6a2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     6a6:	9200      	str	r2, [sp, #0]
                    msg.param1 = msg.param2 = msg.param3 = 0;
     6a8:	9303      	str	r3, [sp, #12]
     6aa:	9302      	str	r3, [sp, #8]
     6ac:	9301      	str	r3, [sp, #4]
                    break;
            }
        
            // Sending the CAN command to the routine that
            // utilizes CAN controller
            queue_put_non_blocking(&usart2can, &msg);
     6ae:	4669      	mov	r1, sp
     6b0:	482b      	ldr	r0, [pc, #172]	(760 <usart_rx_handler+0x154>)
     6b2:	f7ff fed7 	bl	464 <queue_put_non_blocking>
            // Switch off the "Receiving..." LED
            // at the end of the command line
            gpio_clear(LED_USART);
     6b6:	f44f 4080 	mov.w	r0, #16384	; 0x4000
     6ba:	f000 f9c1 	bl	a40 <gpio_clear>
            // Line is to be invalidated
            line_len = 0;
     6be:	4b25      	ldr	r3, [pc, #148]	(754 <usart_rx_handler+0x148>)
     6c0:	2200      	movs	r2, #0
     6c2:	601a      	str	r2, [r3, #0]
     6c4:	e7ad      	b.n	622 <usart_rx_handler+0x16>
            switch (line[0]) {
                case 'v':
                case 'V':
                    // Version info
                    // One character expected
                    msg.command = CAN_VERSION;
     6c6:	2300      	movs	r3, #0
     6c8:	9300      	str	r3, [sp, #0]
                    msg.param1 = msg.param2 = msg.param3 = 0;
     6ca:	9303      	str	r3, [sp, #12]
     6cc:	9302      	str	r3, [sp, #8]
     6ce:	9301      	str	r3, [sp, #4]
     6d0:	e7ed      	b.n	6ae <usart_rx_handler+0xa2>
                    //      it is not possible to send 0 byte of data!
                    // "iiiiiiii" is the destination id in HEXADECIMAL
                    // "dd ... dd" is the data. 16 digits (8 bytes) expected.
                    msg.command = CAN_SEND;

                    if (line[1] == '0')
     6d2:	7853      	ldrb	r3, [r2, #1]
     6d4:	4d20      	ldr	r5, [pc, #128]	(758 <usart_rx_handler+0x14c>)
     6d6:	2b30      	cmp	r3, #48
     6d8:	d039      	beq.n	74e <usart_rx_handler+0x142>
                    // Format: Sniiiiiiiidddddddddddddddd
                    // where 'n' is the number of bytes to be sent (1 ... 8)
                    //      it is not possible to send 0 byte of data!
                    // "iiiiiiii" is the destination id in HEXADECIMAL
                    // "dd ... dd" is the data. 16 digits (8 bytes) expected.
                    msg.command = CAN_SEND;
     6da:	2305      	movs	r3, #5

                    if (line[1] == '0')
                        line[1] = '1';

                    msg.param1 = (hex2num((char *) line+1, 1) - 1) << 29 | 
     6dc:	2101      	movs	r1, #1
     6de:	1c68      	adds	r0, r5, #1
                    // Format: Sniiiiiiiidddddddddddddddd
                    // where 'n' is the number of bytes to be sent (1 ... 8)
                    //      it is not possible to send 0 byte of data!
                    // "iiiiiiii" is the destination id in HEXADECIMAL
                    // "dd ... dd" is the data. 16 digits (8 bytes) expected.
                    msg.command = CAN_SEND;
     6e0:	9300      	str	r3, [sp, #0]

                    if (line[1] == '0')
                        line[1] = '1';

                    msg.param1 = (hex2num((char *) line+1, 1) - 1) << 29 | 
     6e2:	f000 f8b9 	bl	858 <hex2num>
     6e6:	2108      	movs	r1, #8
     6e8:	4604      	mov	r4, r0
     6ea:	1ca8      	adds	r0, r5, #2
     6ec:	f000 f8b4 	bl	858 <hex2num>
     6f0:	3c01      	subs	r4, #1
     6f2:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
     6f6:	ea40 7044 	orr.w	r0, r0, r4, lsl #29
     6fa:	9001      	str	r0, [sp, #4]
                                  (hex2num((char *) line+2, 8) & 0x1fffffff);
                    msg.param2 = hex2num((char *) line+10, 8);
     6fc:	2108      	movs	r1, #8
     6fe:	f105 000a 	add.w	r0, r5, #10	; 0xa
     702:	f000 f8a9 	bl	858 <hex2num>
                    msg.param3 = hex2num((char *) line+18, 8);
     706:	2108      	movs	r1, #8
                    if (line[1] == '0')
                        line[1] = '1';

                    msg.param1 = (hex2num((char *) line+1, 1) - 1) << 29 | 
                                  (hex2num((char *) line+2, 8) & 0x1fffffff);
                    msg.param2 = hex2num((char *) line+10, 8);
     708:	9002      	str	r0, [sp, #8]
                    msg.param3 = hex2num((char *) line+18, 8);
     70a:	f105 0012 	add.w	r0, r5, #18	; 0x12
     70e:	f000 f8a3 	bl	858 <hex2num>
     712:	9003      	str	r0, [sp, #12]
     714:	e7cb      	b.n	6ae <usart_rx_handler+0xa2>
                case 'I':
                    // Set CAN id
                    // Format: Inxxxxxxxx
                    // where 'xxxxxxxx' is the ID value in hexadecimal
                    // 'n' is the filter's number (0 ... 13) in hexadecimal
                    msg.command = CAN_SET_ID;
     716:	2304      	movs	r3, #4
                    msg.param1 = hex2num((char *) line+1, 1);
     718:	2101      	movs	r1, #1
     71a:	4812      	ldr	r0, [pc, #72]	(764 <usart_rx_handler+0x158>)
                case 'I':
                    // Set CAN id
                    // Format: Inxxxxxxxx
                    // where 'xxxxxxxx' is the ID value in hexadecimal
                    // 'n' is the filter's number (0 ... 13) in hexadecimal
                    msg.command = CAN_SET_ID;
     71c:	9300      	str	r3, [sp, #0]
                    msg.param1 = hex2num((char *) line+1, 1);
     71e:	f000 f89b 	bl	858 <hex2num>
                    msg.param2 = hex2num((char *) line+2, 8);
     722:	2108      	movs	r1, #8
                    // Set CAN id
                    // Format: Inxxxxxxxx
                    // where 'xxxxxxxx' is the ID value in hexadecimal
                    // 'n' is the filter's number (0 ... 13) in hexadecimal
                    msg.command = CAN_SET_ID;
                    msg.param1 = hex2num((char *) line+1, 1);
     724:	9001      	str	r0, [sp, #4]
                    msg.param2 = hex2num((char *) line+2, 8);
     726:	4810      	ldr	r0, [pc, #64]	(768 <usart_rx_handler+0x15c>)
     728:	f000 f896 	bl	858 <hex2num>
                    msg.param3 = 0;
     72c:	2300      	movs	r3, #0
                    // Format: Inxxxxxxxx
                    // where 'xxxxxxxx' is the ID value in hexadecimal
                    // 'n' is the filter's number (0 ... 13) in hexadecimal
                    msg.command = CAN_SET_ID;
                    msg.param1 = hex2num((char *) line+1, 1);
                    msg.param2 = hex2num((char *) line+2, 8);
     72e:	9002      	str	r0, [sp, #8]
                    msg.param3 = 0;
     730:	9303      	str	r3, [sp, #12]
     732:	e7bc      	b.n	6ae <usart_rx_handler+0xa2>
                case 'F':
                    // Set filter mask
                    // Format: Fnxxxxxxxx
                    // where 'xxxxxxxx' is the mask in hexadecimal format
                    // 'n' is the filter's number (0 ... 13) in hexadecimal
                    msg.command = CAN_SET_FILTER;
     734:	2303      	movs	r3, #3
     736:	e7ef      	b.n	718 <usart_rx_handler+0x10c>
                case 'B':
                    // Set baud rate
                    // Format: B_xxxxxxxx
                    // where 'x' is a hexadecimal digit
                    // and '_' is "don't care"
                    msg.command = CAN_SET_BAUD;
     738:	2302      	movs	r3, #2
                    msg.param1 = hex2num((char *) line+2, 8);
     73a:	480b      	ldr	r0, [pc, #44]	(768 <usart_rx_handler+0x15c>)
     73c:	2108      	movs	r1, #8
                case 'B':
                    // Set baud rate
                    // Format: B_xxxxxxxx
                    // where 'x' is a hexadecimal digit
                    // and '_' is "don't care"
                    msg.command = CAN_SET_BAUD;
     73e:	9300      	str	r3, [sp, #0]
                    msg.param1 = hex2num((char *) line+2, 8);
     740:	f000 f88a 	bl	858 <hex2num>
                    msg.param2 = msg.param3 = 0;
     744:	2300      	movs	r3, #0
                    // Set baud rate
                    // Format: B_xxxxxxxx
                    // where 'x' is a hexadecimal digit
                    // and '_' is "don't care"
                    msg.command = CAN_SET_BAUD;
                    msg.param1 = hex2num((char *) line+2, 8);
     746:	9001      	str	r0, [sp, #4]
                    msg.param2 = msg.param3 = 0;
     748:	9303      	str	r3, [sp, #12]
     74a:	9302      	str	r3, [sp, #8]
     74c:	e7af      	b.n	6ae <usart_rx_handler+0xa2>
                    // "iiiiiiii" is the destination id in HEXADECIMAL
                    // "dd ... dd" is the data. 16 digits (8 bytes) expected.
                    msg.command = CAN_SEND;

                    if (line[1] == '0')
                        line[1] = '1';
     74e:	3301      	adds	r3, #1
     750:	706b      	strb	r3, [r5, #1]
     752:	e7c2      	b.n	6da <usart_rx_handler+0xce>
     754:	200002d4 	.word	0x200002d4
     758:	2000028c 	.word	0x2000028c
     75c:	200002cc 	.word	0x200002cc
     760:	20000110 	.word	0x20000110
     764:	2000028d 	.word	0x2000028d
     768:	2000028e 	.word	0x2000028e

0000076c <systick>:
// ---------------------------------------------------------------------------
// ISR of the SYSTICK timer (makes the LED blibking).
// ---------------------------------------------------------------------------

void systick() {
    counter++;
     76c:	4b09      	ldr	r3, [pc, #36]	(794 <systick+0x28>)

// ---------------------------------------------------------------------------
// ISR of the SYSTICK timer (makes the LED blibking).
// ---------------------------------------------------------------------------

void systick() {
     76e:	b510      	push	{r4, lr}
    counter++;
     770:	681a      	ldr	r2, [r3, #0]
     772:	3201      	adds	r2, #1
     774:	601a      	str	r2, [r3, #0]

    if (counter % 2 == 1) {
     776:	6819      	ldr	r1, [r3, #0]
     778:	f011 0f01 	tst.w	r1, #1	; 0x1
     77c:	d004      	beq.n	788 <systick+0x1c>
        gpio_set(LED_SYSTICK);
     77e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
     782:	f000 f967 	bl	a54 <gpio_set>
    } else {
        gpio_clear(LED_SYSTICK);
    }
}
     786:	bd10      	pop	{r4, pc}
    counter++;

    if (counter % 2 == 1) {
        gpio_set(LED_SYSTICK);
    } else {
        gpio_clear(LED_SYSTICK);
     788:	f44f 4000 	mov.w	r0, #32768	; 0x8000
     78c:	f000 f958 	bl	a40 <gpio_clear>
     790:	e7f9      	b.n	786 <systick+0x1a>
     792:	46c0      	nop			(mov r8, r8)
     794:	200002d0 	.word	0x200002d0

00000798 <hex_decode>:
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     798:	3830      	subs	r0, #48
     79a:	2836      	cmp	r0, #54
     79c:	d81d      	bhi.n	7da <hex_decode+0x42>
     79e:	e8df f000 	tbb	[pc, r0]
     7a2:	211f      	.short	0x211f
     7a4:	29272523 	.word	0x29272523
     7a8:	312f2d2b 	.word	0x312f2d2b
     7ac:	1c1c1c1c 	.word	0x1c1c1c1c
     7b0:	331c1c1c 	.word	0x331c1c1c
     7b4:	3b393735 	.word	0x3b393735
     7b8:	1c1c1c3d 	.word	0x1c1c1c3d
     7bc:	1c1c1c1c 	.word	0x1c1c1c1c
     7c0:	1c1c1c1c 	.word	0x1c1c1c1c
     7c4:	1c1c1c1c 	.word	0x1c1c1c1c
     7c8:	1c1c1c1c 	.word	0x1c1c1c1c
     7cc:	1c1c1c1c 	.word	0x1c1c1c1c
     7d0:	331c1c1c 	.word	0x331c1c1c
     7d4:	3b393735 	.word	0x3b393735
     7d8:	003d      	.short	0x003d
     7da:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        case 'f':
            return 15;
        default:
            return -1;
    }
}
     7de:	4770      	bx	lr
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     7e0:	2000      	movs	r0, #0
     7e2:	e7fc      	b.n	7de <hex_decode+0x46>
        case '0':
            return 0;
     7e4:	2001      	movs	r0, #1
     7e6:	e7fa      	b.n	7de <hex_decode+0x46>
        case '1':
            return 1;
     7e8:	2002      	movs	r0, #2
     7ea:	e7f8      	b.n	7de <hex_decode+0x46>
        case '2':
            return 2;
     7ec:	2003      	movs	r0, #3
     7ee:	e7f6      	b.n	7de <hex_decode+0x46>
        case '3':
            return 3;
     7f0:	2004      	movs	r0, #4
     7f2:	e7f4      	b.n	7de <hex_decode+0x46>
        case '4':
            return 4;
     7f4:	2005      	movs	r0, #5
     7f6:	e7f2      	b.n	7de <hex_decode+0x46>
        case '5':
            return 5;
     7f8:	2006      	movs	r0, #6
     7fa:	e7f0      	b.n	7de <hex_decode+0x46>
        case '6':
            return 6;
     7fc:	2007      	movs	r0, #7
     7fe:	e7ee      	b.n	7de <hex_decode+0x46>
        case '7':
            return 7;
     800:	2008      	movs	r0, #8
     802:	e7ec      	b.n	7de <hex_decode+0x46>
        case '8':
            return 8;
     804:	2009      	movs	r0, #9
     806:	e7ea      	b.n	7de <hex_decode+0x46>
        case '9':
            return 9;
     808:	200a      	movs	r0, #10
     80a:	e7e8      	b.n	7de <hex_decode+0x46>
        case 'A':
        case 'a':
            return 10;
     80c:	200b      	movs	r0, #11
     80e:	e7e6      	b.n	7de <hex_decode+0x46>
        case 'B':
        case 'b':
            return 11;
     810:	200c      	movs	r0, #12
     812:	e7e4      	b.n	7de <hex_decode+0x46>
        case 'C':
        case 'c':
            return 12;
     814:	200d      	movs	r0, #13
     816:	e7e2      	b.n	7de <hex_decode+0x46>
        case 'D':
        case 'd':
            return 13;
     818:	200e      	movs	r0, #14
     81a:	e7e0      	b.n	7de <hex_decode+0x46>
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     81c:	200f      	movs	r0, #15
     81e:	e7de      	b.n	7de <hex_decode+0x46>

00000820 <num2hex>:
const char xtab[] = "0123456789ABCDEF";

unsigned int num2hex(unsigned int num, char *str, unsigned int digits) {
    int k;

    for (k = digits - 1; k >= 0; k--) {
     820:	f112 3cff 	adds.w	ip, r2, #4294967295	; 0xffffffff
    return value;
}

const char xtab[] = "0123456789ABCDEF";

unsigned int num2hex(unsigned int num, char *str, unsigned int digits) {
     824:	b570      	push	{r4, r5, r6, lr}
     826:	460c      	mov	r4, r1
     828:	4615      	mov	r5, r2
    int k;

    for (k = digits - 1; k >= 0; k--) {
     82a:	d410      	bmi.n	84e <num2hex+0x2e>
     82c:	0093      	lsls	r3, r2, #2
     82e:	4e09      	ldr	r6, [pc, #36]	(854 <num2hex+0x34>)
     830:	f1a3 0e04 	sub.w	lr, r3, #4	; 0x4
     834:	2100      	movs	r1, #0
        str[digits - k - 1] = xtab[(num >> (4 * k)) & 0x0f];
     836:	fa20 f30e 	lsr.w	r3, r0, lr
     83a:	f003 030f 	and.w	r3, r3, #15	; 0xf
     83e:	5cf2      	ldrb	r2, [r6, r3]
const char xtab[] = "0123456789ABCDEF";

unsigned int num2hex(unsigned int num, char *str, unsigned int digits) {
    int k;

    for (k = digits - 1; k >= 0; k--) {
     840:	f1ae 0e04 	sub.w	lr, lr, #4	; 0x4
        str[digits - k - 1] = xtab[(num >> (4 * k)) & 0x0f];
     844:	550a      	strb	r2, [r1, r4]
const char xtab[] = "0123456789ABCDEF";

unsigned int num2hex(unsigned int num, char *str, unsigned int digits) {
    int k;

    for (k = digits - 1; k >= 0; k--) {
     846:	3101      	adds	r1, #1
     848:	f11c 3cff 	adds.w	ip, ip, #4294967295	; 0xffffffff
     84c:	d5f3      	bpl.n	836 <num2hex+0x16>
        str[digits - k - 1] = xtab[(num >> (4 * k)) & 0x0f];
    }

    str[digits] = 0;
     84e:	2000      	movs	r0, #0
     850:	5560      	strb	r0, [r4, r5]

    return 0;
}
     852:	bd70      	pop	{r4, r5, r6, pc}
     854:	000029f8 	.word	0x000029f8

00000858 <hex2num>:

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     858:	2900      	cmp	r1, #0
        default:
            return -1;
    }
}

unsigned int hex2num(char *str, int digits) {
     85a:	b510      	push	{r4, lr}
     85c:	4686      	mov	lr, r0
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     85e:	f340 8087 	ble.w	970 <hex2num+0x118>
     862:	2000      	movs	r0, #0
     864:	4602      	mov	r2, r0
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     866:	f812 300e 	ldrb.w	r3, [r2, lr]
unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
        value <<= 4;
     86a:	0100      	lsls	r0, r0, #4
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     86c:	3b30      	subs	r3, #48
     86e:	2b36      	cmp	r3, #54
     870:	d81d      	bhi.n	8ae <hex2num+0x56>
     872:	e8df f003 	tbb	[pc, r3]
     876:	761e      	.short	0x761e
     878:	5e646a70 	.word	0x5e646a70
     87c:	464c5258 	.word	0x464c5258
     880:	1c1c1c1c 	.word	0x1c1c1c1c
     884:	401c1c1c 	.word	0x401c1c1c
     888:	282e343a 	.word	0x282e343a
     88c:	1c1c1c22 	.word	0x1c1c1c22
     890:	1c1c1c1c 	.word	0x1c1c1c1c
     894:	1c1c1c1c 	.word	0x1c1c1c1c
     898:	1c1c1c1c 	.word	0x1c1c1c1c
     89c:	1c1c1c1c 	.word	0x1c1c1c1c
     8a0:	1c1c1c1c 	.word	0x1c1c1c1c
     8a4:	401c1c1c 	.word	0x401c1c1c
     8a8:	282e343a 	.word	0x282e343a
     8ac:	0022      	.short	0x0022
     8ae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     8b2:	3201      	adds	r2, #1
     8b4:	428a      	cmp	r2, r1
     8b6:	d1d6      	bne.n	866 <hex2num+0xe>
        value <<= 4;
        value |= hex_decode(str[k]);
    }

    return value;
}
     8b8:	bd10      	pop	{r4, pc}

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     8ba:	3201      	adds	r2, #1
     8bc:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     8be:	f040 000f 	orr.w	r0, r0, #15	; 0xf

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     8c2:	d1d0      	bne.n	866 <hex2num+0xe>
     8c4:	e7f8      	b.n	8b8 <hex2num+0x60>
     8c6:	3201      	adds	r2, #1
     8c8:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     8ca:	f040 000e 	orr.w	r0, r0, #14	; 0xe

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     8ce:	d1ca      	bne.n	866 <hex2num+0xe>
     8d0:	e7f2      	b.n	8b8 <hex2num+0x60>
     8d2:	3201      	adds	r2, #1
     8d4:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     8d6:	f040 000d 	orr.w	r0, r0, #13	; 0xd

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     8da:	d1c4      	bne.n	866 <hex2num+0xe>
     8dc:	e7ec      	b.n	8b8 <hex2num+0x60>
     8de:	3201      	adds	r2, #1
     8e0:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     8e2:	f040 000c 	orr.w	r0, r0, #12	; 0xc

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     8e6:	d1be      	bne.n	866 <hex2num+0xe>
     8e8:	e7e6      	b.n	8b8 <hex2num+0x60>
     8ea:	3201      	adds	r2, #1
     8ec:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     8ee:	f040 000b 	orr.w	r0, r0, #11	; 0xb

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     8f2:	d1b8      	bne.n	866 <hex2num+0xe>
     8f4:	e7e0      	b.n	8b8 <hex2num+0x60>
     8f6:	3201      	adds	r2, #1
     8f8:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     8fa:	f040 000a 	orr.w	r0, r0, #10	; 0xa

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     8fe:	d1b2      	bne.n	866 <hex2num+0xe>
     900:	e7da      	b.n	8b8 <hex2num+0x60>
     902:	3201      	adds	r2, #1
     904:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     906:	f040 0009 	orr.w	r0, r0, #9	; 0x9

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     90a:	d1ac      	bne.n	866 <hex2num+0xe>
     90c:	e7d4      	b.n	8b8 <hex2num+0x60>
     90e:	3201      	adds	r2, #1
     910:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     912:	f040 0008 	orr.w	r0, r0, #8	; 0x8

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     916:	d1a6      	bne.n	866 <hex2num+0xe>
     918:	e7ce      	b.n	8b8 <hex2num+0x60>
     91a:	3201      	adds	r2, #1
     91c:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     91e:	f040 0007 	orr.w	r0, r0, #7	; 0x7

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     922:	d1a0      	bne.n	866 <hex2num+0xe>
     924:	e7c8      	b.n	8b8 <hex2num+0x60>
     926:	3201      	adds	r2, #1
     928:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     92a:	f040 0006 	orr.w	r0, r0, #6	; 0x6

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     92e:	d19a      	bne.n	866 <hex2num+0xe>
     930:	e7c2      	b.n	8b8 <hex2num+0x60>
     932:	3201      	adds	r2, #1
     934:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     936:	f040 0005 	orr.w	r0, r0, #5	; 0x5

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     93a:	d194      	bne.n	866 <hex2num+0xe>
     93c:	e7bc      	b.n	8b8 <hex2num+0x60>
     93e:	3201      	adds	r2, #1
     940:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     942:	f040 0004 	orr.w	r0, r0, #4	; 0x4

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     946:	d18e      	bne.n	866 <hex2num+0xe>
     948:	e7b6      	b.n	8b8 <hex2num+0x60>
     94a:	3201      	adds	r2, #1
     94c:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     94e:	f040 0003 	orr.w	r0, r0, #3	; 0x3

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     952:	d188      	bne.n	866 <hex2num+0xe>
     954:	e7b0      	b.n	8b8 <hex2num+0x60>
     956:	3201      	adds	r2, #1
     958:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     95a:	f040 0002 	orr.w	r0, r0, #2	; 0x2

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     95e:	d182      	bne.n	866 <hex2num+0xe>
     960:	e7aa      	b.n	8b8 <hex2num+0x60>
     962:	3201      	adds	r2, #1
     964:	428a      	cmp	r2, r1
#include <num_conv.h>

unsigned int hex_decode(char digit) {
    switch(digit) {
     966:	f040 0001 	orr.w	r0, r0, #1	; 0x1

unsigned int hex2num(char *str, int digits) {
    int k;
    unsigned int value = 0;

    for (k = 0; k < digits; k++) {
     96a:	f47f af7c 	bne.w	866 <hex2num+0xe>
     96e:	e7a3      	b.n	8b8 <hex2num+0x60>
     970:	2000      	movs	r0, #0
     972:	e7a1      	b.n	8b8 <hex2num+0x60>

00000974 <__clock_enable_pll>:

    return 1;
}


int __clock_enable_pll(unsigned int divisor, unsigned int multiplier) {
     974:	b570      	push	{r4, r5, r6, lr}
     976:	4604      	mov	r4, r0
    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
     978:	2010      	movs	r0, #16

    return 1;
}


int __clock_enable_pll(unsigned int divisor, unsigned int multiplier) {
     97a:	460d      	mov	r5, r1
    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
     97c:	f000 fc4e 	bl	121c <FLASH_PrefetchBufferCmd>

    /* Flash 2 wait state */
    FLASH_SetLatency(FLASH_Latency_2);
     980:	2002      	movs	r0, #2
     982:	f000 fc33 	bl	11ec <FLASH_SetLatency>

    /* HCLK = SYSCLK */
    RCC_HCLKConfig(RCC_SYSCLK_Div1);
     986:	2000      	movs	r0, #0
     988:	f000 fa8e 	bl	ea8 <RCC_HCLKConfig>

    /* PCLK2 = HCLK */
    RCC_PCLK2Config(RCC_HCLK_Div1);
     98c:	2000      	movs	r0, #0
     98e:	f000 fa9f 	bl	ed0 <RCC_PCLK2Config>

    /* PCLK1 = HCLK/2 */
    RCC_PCLK1Config(RCC_HCLK_Div2);
     992:	f44f 6080 	mov.w	r0, #1024	; 0x400
     996:	f000 fa91 	bl	ebc <RCC_PCLK1Config>

    /* PLLCLK = 8MHz * 9 = 72 MHz */
    RCC_PLLConfig(divisor, multiplier);
     99a:	4620      	mov	r0, r4
     99c:	4629      	mov	r1, r5
     99e:	f000 fa5f 	bl	e60 <RCC_PLLConfig>

    /* Enable PLL */
    RCC_PLLCmd(ENABLE);
     9a2:	2001      	movs	r0, #1
     9a4:	f000 fa68 	bl	e78 <RCC_PLLCmd>

    /* Wait till PLL is ready */
    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
     9a8:	2039      	movs	r0, #57
     9aa:	f000 fbc9 	bl	1140 <RCC_GetFlagStatus>
     9ae:	2800      	cmp	r0, #0
     9b0:	d0fa      	beq.n	9a8 <__clock_enable_pll+0x34>

    /* Select PLL as system clock source */
    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
     9b2:	2002      	movs	r0, #2
     9b4:	f000 fa66 	bl	e84 <RCC_SYSCLKConfig>

    /* Wait till PLL is used as system clock source */
    while(RCC_GetSYSCLKSource() != 0x08);
     9b8:	f000 fa6e 	bl	e98 <RCC_GetSYSCLKSource>
     9bc:	2808      	cmp	r0, #8
     9be:	d1fb      	bne.n	9b8 <__clock_enable_pll+0x44>

    return 0;
}
     9c0:	3808      	subs	r0, #8
     9c2:	bd70      	pop	{r4, r5, r6, pc}

000009c4 <clock_enable_pll>:

int clock_enable_pll() {
     9c4:	b510      	push	{r4, lr}
    __clock_enable_pll(PLL_DIV, PLL_MUL);
     9c6:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
     9ca:	f44f 3080 	mov.w	r0, #65536	; 0x10000
     9ce:	f7ff ffd1 	bl	974 <__clock_enable_pll>
    return 0;
}
     9d2:	2000      	movs	r0, #0
     9d4:	bd10      	pop	{r4, pc}
     9d6:	46c0      	nop			(mov r8, r8)

000009d8 <clock_enable_main_osc>:
#include <stm32f10x_lib.h>
#include <config.h>

int clock_enable_main_osc() {
     9d8:	b510      	push	{r4, lr}
    ErrorStatus HSEStartUpStatus;

    /* RCC system reset(for debug purpose) */
    RCC_DeInit();
     9da:	f000 f9f1 	bl	dc0 <RCC_DeInit>

    /* Enable HSE */
    RCC_HSEConfig(RCC_HSE_ON);
     9de:	f44f 3080 	mov.w	r0, #65536	; 0x10000
     9e2:	f000 fa0f 	bl	e04 <RCC_HSEConfig>

    /* Wait till HSE is ready */
    HSEStartUpStatus = RCC_WaitForHSEStartUp();
     9e6:	f000 fbe3 	bl	11b0 <RCC_WaitForHSEStartUp>

    if (HSEStartUpStatus == SUCCESS) {
     9ea:	2801      	cmp	r0, #1

    /* Enable HSE */
    RCC_HSEConfig(RCC_HSE_ON);

    /* Wait till HSE is ready */
    HSEStartUpStatus = RCC_WaitForHSEStartUp();
     9ec:	4604      	mov	r4, r0

    if (HSEStartUpStatus == SUCCESS) {
     9ee:	d001      	beq.n	9f4 <clock_enable_main_osc+0x1c>
     9f0:	2001      	movs	r0, #1
    
        return 0;
    }

    return 1;
}
     9f2:	bd10      	pop	{r4, pc}
    /* Wait till HSE is ready */
    HSEStartUpStatus = RCC_WaitForHSEStartUp();

    if (HSEStartUpStatus == SUCCESS) {
        /* Enable Prefetch Buffer */
        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
     9f4:	2010      	movs	r0, #16
     9f6:	f000 fc11 	bl	121c <FLASH_PrefetchBufferCmd>
    
        /* HCLK = SYSCLK */
        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
     9fa:	2000      	movs	r0, #0
     9fc:	f000 fa54 	bl	ea8 <RCC_HCLKConfig>
  
        /* PCLK2 = HCLK */
        RCC_PCLK2Config(RCC_HCLK_Div1); 
     a00:	2000      	movs	r0, #0
     a02:	f000 fa65 	bl	ed0 <RCC_PCLK2Config>

        /* PCLK1 = HCLK */
        RCC_PCLK1Config(RCC_HCLK_Div1);
     a06:	2000      	movs	r0, #0
     a08:	f000 fa58 	bl	ebc <RCC_PCLK1Config>

        /* Select HSE as system clock source */
        RCC_SYSCLKConfig(RCC_SYSCLKSource_HSE);
     a0c:	4620      	mov	r0, r4
     a0e:	f000 fa39 	bl	e84 <RCC_SYSCLKConfig>

        /* Wait till HSE is used as system clock source */
        while(RCC_GetSYSCLKSource() != 0x04);
     a12:	f000 fa41 	bl	e98 <RCC_GetSYSCLKSource>
     a16:	2804      	cmp	r0, #4
     a18:	d1fb      	bne.n	a12 <clock_enable_main_osc+0x3a>
     a1a:	3804      	subs	r0, #4
     a1c:	e7e9      	b.n	9f2 <clock_enable_main_osc+0x1a>
     a1e:	46c0      	nop			(mov r8, r8)

00000a20 <systick_init>:
#include <stm32f10x_lib.h>
#include <stm32f10x_systick.h>
#include <config.h>

int systick_init(unsigned int freq) {
    SysTick_SetReload(CLOCK_FREQ * PLL_MUL / PLL_DIV / 8 / freq * 1024);
     a20:	f44f 53b0 	mov.w	r3, #5632	; 0x1600
     a24:	fbb3 f3f0 	udiv	r3, r3, r0
     a28:	0298      	lsls	r0, r3, #10
#include <systick.h>
#include <stm32f10x_lib.h>
#include <stm32f10x_systick.h>
#include <config.h>

int systick_init(unsigned int freq) {
     a2a:	b510      	push	{r4, lr}
    SysTick_SetReload(CLOCK_FREQ * PLL_MUL / PLL_DIV / 8 / freq * 1024);
     a2c:	f000 fc18 	bl	1260 <SysTick_SetReload>
    SysTick_ITConfig(ENABLE);
     a30:	2001      	movs	r0, #1
     a32:	f000 fc39 	bl	12a8 <SysTick_ITConfig>
    SysTick_CounterCmd(SysTick_Counter_Enable);
     a36:	2001      	movs	r0, #1
     a38:	f000 fc18 	bl	126c <SysTick_CounterCmd>
    
    return 0;
}
     a3c:	2000      	movs	r0, #0
     a3e:	bd10      	pop	{r4, pc}

00000a40 <gpio_clear>:
void gpio_set(unsigned int data) {
    GPIO_SetBits(GPIOB, data);
}

void gpio_clear(unsigned int data) {
    GPIO_ResetBits(GPIOB, data);
     a40:	b281      	uxth	r1, r0
     a42:	f640 4000 	movw	r0, #3072	; 0xc00

void gpio_set(unsigned int data) {
    GPIO_SetBits(GPIOB, data);
}

void gpio_clear(unsigned int data) {
     a46:	b510      	push	{r4, lr}
    GPIO_ResetBits(GPIOB, data);
     a48:	f2c4 0001 	movt	r0, #16385	; 0x4001
     a4c:	f000 fdd4 	bl	15f8 <GPIO_ResetBits>
}
     a50:	bd10      	pop	{r4, pc}
     a52:	46c0      	nop			(mov r8, r8)

00000a54 <gpio_set>:
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
}

void gpio_set(unsigned int data) {
    GPIO_SetBits(GPIOB, data);
     a54:	b281      	uxth	r1, r0
     a56:	f640 4000 	movw	r0, #3072	; 0xc00
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
}

void gpio_set(unsigned int data) {
     a5a:	b510      	push	{r4, lr}
    GPIO_SetBits(GPIOB, data);
     a5c:	f2c4 0001 	movt	r0, #16385	; 0x4001
     a60:	f000 fdc8 	bl	15f4 <GPIO_SetBits>
}
     a64:	bd10      	pop	{r4, pc}
     a66:	46c0      	nop			(mov r8, r8)

00000a68 <gpio_init>:
#include <gpio.h>
#include <stm32f10x_gpio.h>
#include <stm32f10x_rcc.h>

void gpio_init() {
     a68:	b530      	push	{r4, r5, lr}
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
     a6a:	2008      	movs	r0, #8
#include <gpio.h>
#include <stm32f10x_gpio.h>
#include <stm32f10x_rcc.h>

void gpio_init() {
     a6c:	b085      	sub	sp, #20
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
     a6e:	2101      	movs	r1, #1

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
     a70:	f640 4400 	movw	r4, #3072	; 0xc00
#include <stm32f10x_rcc.h>

void gpio_init() {
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
     a74:	f000 fb02 	bl	107c <RCC_APB2PeriphClockCmd>

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
     a78:	f2c4 0401 	movt	r4, #16385	; 0x4001
     a7c:	ad01      	add	r5, sp, #4
void gpio_init() {
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
     a7e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     a82:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
     a86:	4620      	mov	r0, r4
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
     a88:	2300      	movs	r3, #0
    GPIO_Init(GPIOB, &GPIO_InitStructure);
     a8a:	4629      	mov	r1, r5
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
     a8c:	9303      	str	r3, [sp, #12]
    GPIO_Init(GPIOB, &GPIO_InitStructure);
     a8e:	f000 fc39 	bl	1304 <GPIO_Init>

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
     a92:	f24f 0300 	movw	r3, #61440	; 0xf000
     a96:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     a9a:	2203      	movs	r2, #3
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOB, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     a9c:	2310      	movs	r3, #16
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
     a9e:	4620      	mov	r0, r4
     aa0:	4629      	mov	r1, r5
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOB, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     aa2:	9303      	str	r3, [sp, #12]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     aa4:	9202      	str	r2, [sp, #8]
    GPIO_Init(GPIOB, &GPIO_InitStructure);
     aa6:	f000 fc2d 	bl	1304 <GPIO_Init>
}
     aaa:	b005      	add	sp, #20
     aac:	bd30      	pop	{r4, r5, pc}
     aae:	46c0      	nop			(mov r8, r8)

00000ab0 <CAN_recv>:
    } while ((retval != CANTXOK) && (i <= CAN_RETRIES));

    return retval;
}

CanRxMsg *CAN_recv() {
     ab0:	b510      	push	{r4, lr}
    /* receive */
    RxMessage.StdId = 0x00;
     ab2:	f240 24ec 	movw	r4, #748	; 0x2ec
     ab6:	f2c2 0400 	movt	r4, #8192	; 0x2000
     aba:	2000      	movs	r0, #0
    RxMessage.IDE = CAN_ID_EXT;
     abc:	2304      	movs	r3, #4
    RxMessage.Data[4] = 0x00;
    RxMessage.Data[5] = 0x00;
    RxMessage.Data[6] = 0x00;
    RxMessage.Data[7] = 0x00;

    CAN_Receive(CAN_FIFO0, &RxMessage);
     abe:	4621      	mov	r1, r4
    return retval;
}

CanRxMsg *CAN_recv() {
    /* receive */
    RxMessage.StdId = 0x00;
     ac0:	6020      	str	r0, [r4, #0]
    RxMessage.IDE = CAN_ID_EXT;
    RxMessage.DLC = 0;
     ac2:	72a0      	strb	r0, [r4, #10]
    RxMessage.Data[0] = 0x00;
     ac4:	72e0      	strb	r0, [r4, #11]
    RxMessage.Data[1] = 0x00;
     ac6:	7320      	strb	r0, [r4, #12]
    RxMessage.Data[2] = 0x00;
     ac8:	7360      	strb	r0, [r4, #13]
    RxMessage.Data[3] = 0x00;
     aca:	73a0      	strb	r0, [r4, #14]
    RxMessage.Data[4] = 0x00;
     acc:	73e0      	strb	r0, [r4, #15]
    RxMessage.Data[5] = 0x00;
     ace:	7420      	strb	r0, [r4, #16]
    RxMessage.Data[6] = 0x00;
     ad0:	7460      	strb	r0, [r4, #17]
    RxMessage.Data[7] = 0x00;
     ad2:	74a0      	strb	r0, [r4, #18]
}

CanRxMsg *CAN_recv() {
    /* receive */
    RxMessage.StdId = 0x00;
    RxMessage.IDE = CAN_ID_EXT;
     ad4:	7223      	strb	r3, [r4, #8]
    RxMessage.Data[4] = 0x00;
    RxMessage.Data[5] = 0x00;
    RxMessage.Data[6] = 0x00;
    RxMessage.Data[7] = 0x00;

    CAN_Receive(CAN_FIFO0, &RxMessage);
     ad6:	f001 fa33 	bl	1f40 <CAN_Receive>

    return &RxMessage;
}
     ada:	4620      	mov	r0, r4
     adc:	bd10      	pop	{r4, pc}
     ade:	46c0      	nop			(mov r8, r8)

00000ae0 <CAN_send>:
    CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
    CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
    CAN_FilterInit(&CAN_FilterInitStructure);
}

int CAN_send(unsigned int id, unsigned int length, unsigned int data_h, unsigned int data_l) {
     ae0:	b570      	push	{r4, r5, r6, lr}
    unsigned char TransmitMailbox;
    unsigned int retval = -1, i = 0;

    /* transmit */
    TxMessage.ExtId = id;
     ae2:	4c1c      	ldr	r4, [pc, #112]	(b54 <CAN_send+0x74>)
    TxMessage.RTR = CAN_RTR_DATA;
     ae4:	2500      	movs	r5, #0
int CAN_send(unsigned int id, unsigned int length, unsigned int data_h, unsigned int data_l) {
    unsigned char TransmitMailbox;
    unsigned int retval = -1, i = 0;

    /* transmit */
    TxMessage.ExtId = id;
     ae6:	6060      	str	r0, [r4, #4]
    TxMessage.RTR = CAN_RTR_DATA;
    TxMessage.IDE = CAN_ID_EXT;
    TxMessage.DLC = length;
     ae8:	72a1      	strb	r1, [r4, #10]
    unsigned int retval = -1, i = 0;

    /* transmit */
    TxMessage.ExtId = id;
    TxMessage.RTR = CAN_RTR_DATA;
    TxMessage.IDE = CAN_ID_EXT;
     aea:	2004      	movs	r0, #4
    TxMessage.DLC = length;
    TxMessage.Data[0] = (data_h >> 24) & 0xff;
     aec:	0e11      	lsrs	r1, r2, #24
    unsigned int retval = -1, i = 0;

    /* transmit */
    TxMessage.ExtId = id;
    TxMessage.RTR = CAN_RTR_DATA;
    TxMessage.IDE = CAN_ID_EXT;
     aee:	7220      	strb	r0, [r4, #8]
    TxMessage.DLC = length;
    TxMessage.Data[0] = (data_h >> 24) & 0xff;
     af0:	72e1      	strb	r1, [r4, #11]
    TxMessage.Data[1] = (data_h >> 16) & 0xff;
     af2:	0c10      	lsrs	r0, r2, #16
    TxMessage.Data[2] = (data_h >> 8) & 0xff;
     af4:	0a11      	lsrs	r1, r2, #8
    TxMessage.Data[3] = (data_h >> 0) & 0xff;
     af6:	73a2      	strb	r2, [r4, #14]
    TxMessage.Data[4] = (data_l >> 24) & 0xff;
     af8:	0e1a      	lsrs	r2, r3, #24
    TxMessage.RTR = CAN_RTR_DATA;
    TxMessage.IDE = CAN_ID_EXT;
    TxMessage.DLC = length;
    TxMessage.Data[0] = (data_h >> 24) & 0xff;
    TxMessage.Data[1] = (data_h >> 16) & 0xff;
    TxMessage.Data[2] = (data_h >> 8) & 0xff;
     afa:	7361      	strb	r1, [r4, #13]
    TxMessage.Data[3] = (data_h >> 0) & 0xff;
    TxMessage.Data[4] = (data_l >> 24) & 0xff;
     afc:	73e2      	strb	r2, [r4, #15]
    TxMessage.Data[5] = (data_l >> 16) & 0xff;
     afe:	0c19      	lsrs	r1, r3, #16
    TxMessage.Data[6] = (data_l >> 8) & 0xff;
     b00:	0a1a      	lsrs	r2, r3, #8
    unsigned char TransmitMailbox;
    unsigned int retval = -1, i = 0;

    /* transmit */
    TxMessage.ExtId = id;
    TxMessage.RTR = CAN_RTR_DATA;
     b02:	7265      	strb	r5, [r4, #9]
    TxMessage.IDE = CAN_ID_EXT;
    TxMessage.DLC = length;
    TxMessage.Data[0] = (data_h >> 24) & 0xff;
    TxMessage.Data[1] = (data_h >> 16) & 0xff;
     b04:	7320      	strb	r0, [r4, #12]
    TxMessage.Data[2] = (data_h >> 8) & 0xff;
    TxMessage.Data[3] = (data_h >> 0) & 0xff;
    TxMessage.Data[4] = (data_l >> 24) & 0xff;
    TxMessage.Data[5] = (data_l >> 16) & 0xff;
     b06:	7421      	strb	r1, [r4, #16]
    TxMessage.Data[6] = (data_l >> 8) & 0xff;
     b08:	7462      	strb	r2, [r4, #17]
    TxMessage.Data[7] = (data_l >> 0) & 0xff;
     b0a:	74a3      	strb	r3, [r4, #18]
     b0c:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
     b10:	e00a      	b.n	b28 <CAN_send+0x48>
        TransmitMailbox = CAN_Transmit(&TxMessage);
        
        if (TransmitMailbox != CAN_NO_MB)
            while ((retval = CAN_TransmitStatus(TransmitMailbox)) == CANTXPENDING);

        i++;
     b12:	3501      	adds	r5, #1
    } while ((retval != CANTXOK) && (i <= CAN_RETRIES));
     b14:	2d10      	cmp	r5, #16
     b16:	bf8c      	ite	hi
     b18:	2300      	movhi	r3, #0
     b1a:	2301      	movls	r3, #1
     b1c:	2e01      	cmp	r6, #1
     b1e:	bf0c      	ite	eq
     b20:	2300      	moveq	r3, #0
     b22:	f003 0301 	andne.w	r3, r3, #1	; 0x1
     b26:	b193      	cbz	r3, b4e <CAN_send+0x6e>
    TxMessage.Data[5] = (data_l >> 16) & 0xff;
    TxMessage.Data[6] = (data_l >> 8) & 0xff;
    TxMessage.Data[7] = (data_l >> 0) & 0xff;

    do {
        TransmitMailbox = CAN_Transmit(&TxMessage);
     b28:	480a      	ldr	r0, [pc, #40]	(b54 <CAN_send+0x74>)
     b2a:	f000 ffbd 	bl	1aa8 <CAN_Transmit>
        
        if (TransmitMailbox != CAN_NO_MB)
     b2e:	2804      	cmp	r0, #4
    TxMessage.Data[5] = (data_l >> 16) & 0xff;
    TxMessage.Data[6] = (data_l >> 8) & 0xff;
    TxMessage.Data[7] = (data_l >> 0) & 0xff;

    do {
        TransmitMailbox = CAN_Transmit(&TxMessage);
     b30:	4604      	mov	r4, r0
        
        if (TransmitMailbox != CAN_NO_MB)
     b32:	d0ee      	beq.n	b12 <CAN_send+0x32>
            while ((retval = CAN_TransmitStatus(TransmitMailbox)) == CANTXPENDING);
     b34:	4620      	mov	r0, r4
     b36:	f001 f82d 	bl	1b94 <CAN_TransmitStatus>
     b3a:	2802      	cmp	r0, #2
     b3c:	4606      	mov	r6, r0
     b3e:	d1e8      	bne.n	b12 <CAN_send+0x32>
     b40:	4620      	mov	r0, r4
     b42:	f001 f827 	bl	1b94 <CAN_TransmitStatus>
     b46:	2802      	cmp	r0, #2
     b48:	4606      	mov	r6, r0
     b4a:	d0f3      	beq.n	b34 <CAN_send+0x54>
     b4c:	e7e1      	b.n	b12 <CAN_send+0x32>

        i++;
    } while ((retval != CANTXOK) && (i <= CAN_RETRIES));

    return retval;
}
     b4e:	4630      	mov	r0, r6
     b50:	bd70      	pop	{r4, r5, r6, pc}
     b52:	46c0      	nop			(mov r8, r8)
     b54:	200002d8 	.word	0x200002d8

00000b58 <CAN_set_filter>:
    CAN_Init(&CAN_InitStructure);

    return 0;
}

void CAN_set_filter(unsigned int filter, unsigned int mask, unsigned int id) {
     b58:	b510      	push	{r4, lr}
    /*                           ssss ssss sss */

    // unsigned int new_id = ((id & 0x1ffff800) >> 8) | ((id & 0x7ff) << 21);
    // unsigned int new_mask = ((mask & 0x1ffff800) >> 8) | ((mask & 0x7ff) << 21);

    unsigned int new_id = id << 3;
     b5a:	00d2      	lsls	r2, r2, #3
    CAN_Init(&CAN_InitStructure);

    return 0;
}

void CAN_set_filter(unsigned int filter, unsigned int mask, unsigned int id) {
     b5c:	b086      	sub	sp, #24

    // unsigned int new_id = ((id & 0x1ffff800) >> 8) | ((id & 0x7ff) << 21);
    // unsigned int new_mask = ((mask & 0x1ffff800) >> 8) | ((mask & 0x7ff) << 21);

    unsigned int new_id = id << 3;
    unsigned int new_mask = mask << 3;
     b5e:	00c9      	lsls	r1, r1, #3
    
    /* CAN filter init */
    CAN_FilterInitStructure.CAN_FilterNumber = filter;
    CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
    CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
    CAN_FilterInitStructure.CAN_FilterIdHigh = new_id >> 16;
     b60:	0c13      	lsrs	r3, r2, #16

    unsigned int new_id = id << 3;
    unsigned int new_mask = mask << 3;
    
    /* CAN filter init */
    CAN_FilterInitStructure.CAN_FilterNumber = filter;
     b62:	f88d 0004 	strb.w	r0, [sp, #4]
    CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
    CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
     b66:	2001      	movs	r0, #1
    unsigned int new_id = id << 3;
    unsigned int new_mask = mask << 3;
    
    /* CAN filter init */
    CAN_FilterInitStructure.CAN_FilterNumber = filter;
    CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
     b68:	2400      	movs	r4, #0
    CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
     b6a:	f88d 0006 	strb.w	r0, [sp, #6]
    CAN_FilterInitStructure.CAN_FilterIdHigh = new_id >> 16;
     b6e:	f8ad 3008 	strh.w	r3, [sp, #8]
    CAN_FilterInitStructure.CAN_FilterIdLow = new_id & 0xffff;
    CAN_FilterInitStructure.CAN_FilterMaskIdHigh = new_mask >> 16;
    CAN_FilterInitStructure.CAN_FilterMaskIdLow = new_mask & 0xffff;
    CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
    CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
     b72:	9005      	str	r0, [sp, #20]
    CAN_FilterInitStructure.CAN_FilterNumber = filter;
    CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
    CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
    CAN_FilterInitStructure.CAN_FilterIdHigh = new_id >> 16;
    CAN_FilterInitStructure.CAN_FilterIdLow = new_id & 0xffff;
    CAN_FilterInitStructure.CAN_FilterMaskIdHigh = new_mask >> 16;
     b74:	0c0b      	lsrs	r3, r1, #16
    CAN_FilterInitStructure.CAN_FilterMaskIdLow = new_mask & 0xffff;
    CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
    CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
    CAN_FilterInit(&CAN_FilterInitStructure);
     b76:	a801      	add	r0, sp, #4
    unsigned int new_id = id << 3;
    unsigned int new_mask = mask << 3;
    
    /* CAN filter init */
    CAN_FilterInitStructure.CAN_FilterNumber = filter;
    CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
     b78:	f88d 4005 	strb.w	r4, [sp, #5]
    CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
    CAN_FilterInitStructure.CAN_FilterIdHigh = new_id >> 16;
    CAN_FilterInitStructure.CAN_FilterIdLow = new_id & 0xffff;
     b7c:	f8ad 200a 	strh.w	r2, [sp, #10]
    CAN_FilterInitStructure.CAN_FilterMaskIdHigh = new_mask >> 16;
     b80:	f8ad 300c 	strh.w	r3, [sp, #12]
    CAN_FilterInitStructure.CAN_FilterMaskIdLow = new_mask & 0xffff;
     b84:	f8ad 100e 	strh.w	r1, [sp, #14]
    CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
     b88:	f8ad 4010 	strh.w	r4, [sp, #16]
    CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
    CAN_FilterInit(&CAN_FilterInitStructure);
     b8c:	f000 fec8 	bl	1920 <CAN_FilterInit>
}
     b90:	b006      	add	sp, #24
     b92:	bd10      	pop	{r4, pc}

00000b94 <CAN_set_prescaler>:
    CAN_Init(&CAN_InitStructure);

    return 0;
}

int CAN_set_prescaler(unsigned int prescaler) {
     b94:	b570      	push	{r4, r5, r6, lr}
     b96:	b088      	sub	sp, #32
     b98:	4605      	mov	r5, r0
    CAN_InitTypeDef  CAN_InitStructure;

    /* CAN register init */
    CAN_StructInit(&CAN_InitStructure);
     b9a:	4668      	mov	r0, sp
     b9c:	f000 ff5e 	bl	1a5c <CAN_StructInit>
    CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
#endif
    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;
    CAN_InitStructure.CAN_BS2 = CAN_BS2_7tq;
    CAN_InitStructure.CAN_Prescaler = prescaler & 0x3ff;
     ba0:	05ad      	lsls	r5, r5, #22
    /* CAN cell init */
    CAN_InitStructure.CAN_TTCM = DISABLE;
    CAN_InitStructure.CAN_ABOM = DISABLE;
    CAN_InitStructure.CAN_AWUM = DISABLE;
#ifdef CAN_NO_AUTORETRANSMIT
    CAN_InitStructure.CAN_NART = ENABLE;
     ba2:	2301      	movs	r3, #1

    /* CAN register init */
    CAN_StructInit(&CAN_InitStructure);

    /* CAN cell init */
    CAN_InitStructure.CAN_TTCM = DISABLE;
     ba4:	2400      	movs	r4, #0
    CAN_InitStructure.CAN_ABOM = DISABLE;
    CAN_InitStructure.CAN_AWUM = DISABLE;
#ifdef CAN_NO_AUTORETRANSMIT
    CAN_InitStructure.CAN_NART = ENABLE;
     ba6:	9303      	str	r3, [sp, #12]
    CAN_InitStructure.CAN_NART = DISABLE;
#endif
    CAN_InitStructure.CAN_RFLM = DISABLE;
    CAN_InitStructure.CAN_TXFP = DISABLE;
#ifdef CAN_LOOPBACK
    CAN_InitStructure.CAN_Mode = CAN_Mode_LoopBack;
     ba8:	f88d 3018 	strb.w	r3, [sp, #24]
#else
    CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
#endif
    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;
    CAN_InitStructure.CAN_BS2 = CAN_BS2_7tq;
     bac:	2206      	movs	r2, #6
    CAN_InitStructure.CAN_Mode = CAN_Mode_LoopBack;
#else
    CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
#endif
    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;
     bae:	3306      	adds	r3, #6
    CAN_InitStructure.CAN_BS2 = CAN_BS2_7tq;
    CAN_InitStructure.CAN_Prescaler = prescaler & 0x3ff;
     bb0:	0dad      	lsrs	r5, r5, #22
    CAN_Init(&CAN_InitStructure);
     bb2:	4668      	mov	r0, sp

    /* CAN register init */
    CAN_StructInit(&CAN_InitStructure);

    /* CAN cell init */
    CAN_InitStructure.CAN_TTCM = DISABLE;
     bb4:	9400      	str	r4, [sp, #0]
    CAN_InitStructure.CAN_ABOM = DISABLE;
     bb6:	9401      	str	r4, [sp, #4]
    CAN_InitStructure.CAN_AWUM = DISABLE;
     bb8:	9402      	str	r4, [sp, #8]
    CAN_InitStructure.CAN_NART = ENABLE;
#else
#warning Use CAN_NO_AUTORETRANSMIT
    CAN_InitStructure.CAN_NART = DISABLE;
#endif
    CAN_InitStructure.CAN_RFLM = DISABLE;
     bba:	9404      	str	r4, [sp, #16]
    CAN_InitStructure.CAN_TXFP = DISABLE;
     bbc:	9405      	str	r4, [sp, #20]
#ifdef CAN_LOOPBACK
    CAN_InitStructure.CAN_Mode = CAN_Mode_LoopBack;
#else
    CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
#endif
    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
     bbe:	f88d 4019 	strb.w	r4, [sp, #25]
    CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;
     bc2:	f88d 301a 	strb.w	r3, [sp, #26]
    CAN_InitStructure.CAN_BS2 = CAN_BS2_7tq;
     bc6:	f88d 201b 	strb.w	r2, [sp, #27]
    CAN_InitStructure.CAN_Prescaler = prescaler & 0x3ff;
     bca:	f8ad 501c 	strh.w	r5, [sp, #28]

int CAN_set_prescaler(unsigned int prescaler) {
    CAN_InitTypeDef  CAN_InitStructure;

    /* CAN register init */
    CAN_StructInit(&CAN_InitStructure);
     bce:	466e      	mov	r6, sp
#endif
    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;
    CAN_InitStructure.CAN_BS2 = CAN_BS2_7tq;
    CAN_InitStructure.CAN_Prescaler = prescaler & 0x3ff;
    CAN_Init(&CAN_InitStructure);
     bd0:	f000 fe06 	bl	17e0 <CAN_Init>

    return 0;
}
     bd4:	4620      	mov	r0, r4
     bd6:	b008      	add	sp, #32
     bd8:	bd70      	pop	{r4, r5, r6, pc}
     bda:	46c0      	nop			(mov r8, r8)

00000bdc <CAN_init>:

#ifndef CAN_RETRIES
#define CAN_RETRIES 16
#endif

int CAN_init(unsigned int prescaler) {
     bdc:	e92d 4170 	stmdb	sp!, {r4, r5, r6, r8, lr}
     be0:	b08d      	sub	sp, #52
    GPIO_InitTypeDef GPIO_InitStructure;
    CAN_InitTypeDef  CAN_InitStructure;

    /* CAN register init */
    CAN_DeInit();
    CAN_StructInit(&CAN_InitStructure);
     be2:	f10d 0804 	add.w	r8, sp, #4	; 0x4

#ifndef CAN_RETRIES
#define CAN_RETRIES 16
#endif

int CAN_init(unsigned int prescaler) {
     be6:	4606      	mov	r6, r0
    GPIO_InitTypeDef GPIO_InitStructure;
    CAN_InitTypeDef  CAN_InitStructure;

    /* CAN register init */
    CAN_DeInit();
     be8:	f001 f912 	bl	1e10 <CAN_DeInit>
    CAN_StructInit(&CAN_InitStructure);
     bec:	4640      	mov	r0, r8
     bee:	f000 ff35 	bl	1a5c <CAN_StructInit>

    /* CAN Periph clock enable */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);
     bf2:	2101      	movs	r1, #1
     bf4:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
     bf8:	f000 fa54 	bl	10a4 <RCC_APB1PeriphClockCmd>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

    /* Configure CAN pin: RX */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     bfc:	f640 0400 	movw	r4, #2048	; 0x800
    CAN_DeInit();
    CAN_StructInit(&CAN_InitStructure);

    /* CAN Periph clock enable */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
     c00:	2004      	movs	r0, #4
     c02:	2101      	movs	r1, #1
     c04:	f000 fa3a 	bl	107c <RCC_APB2PeriphClockCmd>

    /* Configure CAN pin: RX */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     c08:	f2c4 0401 	movt	r4, #16385	; 0x4001
     c0c:	ad09      	add	r5, sp, #36
    /* CAN Periph clock enable */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

    /* Configure CAN pin: RX */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
     c0e:	f44f 6300 	mov.w	r3, #2048	; 0x800
     c12:	f8ad 3024 	strh.w	r3, [sp, #36]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     c16:	4620      	mov	r0, r4
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

    /* Configure CAN pin: RX */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
     c18:	2348      	movs	r3, #72
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     c1a:	4629      	mov	r1, r5
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

    /* Configure CAN pin: RX */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
     c1c:	930b      	str	r3, [sp, #44]
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     c1e:	f000 fb71 	bl	1304 <GPIO_Init>
  
    /* Configure CAN pin: TX */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
     c22:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     c26:	2203      	movs	r2, #3
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
  
    /* Configure CAN pin: TX */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
     c28:	f8ad 3024 	strh.w	r3, [sp, #36]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     c2c:	4620      	mov	r0, r4
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
  
    /* Configure CAN pin: TX */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
     c2e:	2318      	movs	r3, #24
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     c30:	4629      	mov	r1, r5
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
  
    /* Configure CAN pin: TX */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
     c32:	930b      	str	r3, [sp, #44]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     c34:	920a      	str	r2, [sp, #40]
    CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
#endif
    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;
    CAN_InitStructure.CAN_BS2 = CAN_BS2_7tq;
    CAN_InitStructure.CAN_Prescaler = prescaler & 0x3ff;
     c36:	05b6      	lsls	r6, r6, #22
  
    /* Configure CAN pin: TX */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     c38:	f000 fb64 	bl	1304 <GPIO_Init>
    /* CAN cell init */
    CAN_InitStructure.CAN_TTCM = DISABLE;
    CAN_InitStructure.CAN_ABOM = DISABLE;
    CAN_InitStructure.CAN_AWUM = DISABLE;
#ifdef CAN_NO_AUTORETRANSMIT
    CAN_InitStructure.CAN_NART = ENABLE;
     c3c:	2301      	movs	r3, #1
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* CAN cell init */
    CAN_InitStructure.CAN_TTCM = DISABLE;
     c3e:	2400      	movs	r4, #0
    CAN_InitStructure.CAN_ABOM = DISABLE;
    CAN_InitStructure.CAN_AWUM = DISABLE;
#ifdef CAN_NO_AUTORETRANSMIT
    CAN_InitStructure.CAN_NART = ENABLE;
     c40:	9304      	str	r3, [sp, #16]
    CAN_InitStructure.CAN_NART = DISABLE;
#endif
    CAN_InitStructure.CAN_RFLM = DISABLE;
    CAN_InitStructure.CAN_TXFP = DISABLE;
#ifdef CAN_LOOPBACK
    CAN_InitStructure.CAN_Mode = CAN_Mode_LoopBack;
     c42:	f88d 301c 	strb.w	r3, [sp, #28]
#else
    CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
#endif
    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;
    CAN_InitStructure.CAN_BS2 = CAN_BS2_7tq;
     c46:	2206      	movs	r2, #6
    CAN_InitStructure.CAN_Mode = CAN_Mode_LoopBack;
#else
    CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
#endif
    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;
     c48:	3306      	adds	r3, #6
    CAN_InitStructure.CAN_BS2 = CAN_BS2_7tq;
    CAN_InitStructure.CAN_Prescaler = prescaler & 0x3ff;
     c4a:	0db6      	lsrs	r6, r6, #22
    CAN_Init(&CAN_InitStructure);
     c4c:	4640      	mov	r0, r8
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* CAN cell init */
    CAN_InitStructure.CAN_TTCM = DISABLE;
     c4e:	9401      	str	r4, [sp, #4]
    CAN_InitStructure.CAN_ABOM = DISABLE;
     c50:	9402      	str	r4, [sp, #8]
    CAN_InitStructure.CAN_AWUM = DISABLE;
     c52:	9403      	str	r4, [sp, #12]
    CAN_InitStructure.CAN_NART = ENABLE;
#else
#warning Use CAN_NO_AUTORETRANSMIT
    CAN_InitStructure.CAN_NART = DISABLE;
#endif
    CAN_InitStructure.CAN_RFLM = DISABLE;
     c54:	9405      	str	r4, [sp, #20]
    CAN_InitStructure.CAN_TXFP = DISABLE;
     c56:	9406      	str	r4, [sp, #24]
#ifdef CAN_LOOPBACK
    CAN_InitStructure.CAN_Mode = CAN_Mode_LoopBack;
#else
    CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
#endif
    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
     c58:	f88d 401d 	strb.w	r4, [sp, #29]
    CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;
     c5c:	f88d 301e 	strb.w	r3, [sp, #30]
    CAN_InitStructure.CAN_BS2 = CAN_BS2_7tq;
     c60:	f88d 201f 	strb.w	r2, [sp, #31]
    CAN_InitStructure.CAN_Prescaler = prescaler & 0x3ff;
     c64:	f8ad 6020 	strh.w	r6, [sp, #32]
    CAN_Init(&CAN_InitStructure);
     c68:	f000 fdba 	bl	17e0 <CAN_Init>

    return 0;
}
     c6c:	4620      	mov	r0, r4
     c6e:	b00d      	add	sp, #52
     c70:	e8bd 8170 	ldmia.w	sp!, {r4, r5, r6, r8, pc}

00000c74 <usart_rx_ready>:
    while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
    return USART_ReceiveData(USART1);
}

int usart_rx_ready() {
    if (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
     c74:	f643 0000 	movw	r0, #14336	; 0x3800
char usart_recv_char() {
    while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
    return USART_ReceiveData(USART1);
}

int usart_rx_ready() {
     c78:	b510      	push	{r4, lr}
    if (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
     c7a:	2120      	movs	r1, #32
     c7c:	f2c4 0001 	movt	r0, #16385	; 0x4001
     c80:	f001 faba 	bl	21f8 <USART_GetFlagStatus>
        return 0;
    else
        return 1;
}
     c84:	3800      	subs	r0, #0
     c86:	bf18      	it	ne
     c88:	2001      	movne	r0, #1
     c8a:	bd10      	pop	{r4, pc}

00000c8c <usart_tx_ready>:

    return 0;
}

int usart_tx_ready() {
    if (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
     c8c:	f643 0000 	movw	r0, #14336	; 0x3800
    USART_SendData(USART1, ch);

    return 0;
}

int usart_tx_ready() {
     c90:	b510      	push	{r4, lr}
    if (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
     c92:	2140      	movs	r1, #64
     c94:	f2c4 0001 	movt	r0, #16385	; 0x4001
     c98:	f001 faae 	bl	21f8 <USART_GetFlagStatus>
        return 0;
    else
        return 1;
}
     c9c:	3800      	subs	r0, #0
     c9e:	bf18      	it	ne
     ca0:	2001      	movne	r0, #1
     ca2:	bd10      	pop	{r4, pc}

00000ca4 <usart_send_char_non_blocking>:

    return 0;
}

int usart_send_char_non_blocking(char ch) {
    if (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
     ca4:	f643 0000 	movw	r0, #14336	; 0x3800
    USART_SendData(USART1, ch);

    return 0;
}

int usart_send_char_non_blocking(char ch) {
     ca8:	b510      	push	{r4, lr}
    if (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
     caa:	2140      	movs	r1, #64
     cac:	f2c4 0001 	movt	r0, #16385	; 0x4001
     cb0:	f001 faa2 	bl	21f8 <USART_GetFlagStatus>
        return 0x800000;

    USART_SendData(USART1, ch);

    return 0;
}
     cb4:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
     cb8:	bd10      	pop	{r4, pc}
     cba:	46c0      	nop			(mov r8, r8)

00000cbc <usart_recv_char>:
        return 0;
    else
        return 1;
}

char usart_recv_char() {
     cbc:	b510      	push	{r4, lr}
    while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
     cbe:	f643 0000 	movw	r0, #14336	; 0x3800
     cc2:	f2c4 0001 	movt	r0, #16385	; 0x4001
     cc6:	2120      	movs	r1, #32
     cc8:	f001 fa96 	bl	21f8 <USART_GetFlagStatus>
     ccc:	2800      	cmp	r0, #0
     cce:	d0f6      	beq.n	cbe <usart_recv_char+0x2>
    return USART_ReceiveData(USART1);
     cd0:	f643 0000 	movw	r0, #14336	; 0x3800
     cd4:	f2c4 0001 	movt	r0, #16385	; 0x4001
     cd8:	f001 fa2c 	bl	2134 <USART_ReceiveData>
}
     cdc:	b2c0      	uxtb	r0, r0
     cde:	bd10      	pop	{r4, pc}

00000ce0 <usart_send_char>:
    USART_Cmd(USART1, ENABLE);

    return 0;
}

int usart_send_char(char ch) {
     ce0:	b510      	push	{r4, lr}
     ce2:	4604      	mov	r4, r0
    while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
     ce4:	f643 0000 	movw	r0, #14336	; 0x3800
     ce8:	f2c4 0001 	movt	r0, #16385	; 0x4001
     cec:	2140      	movs	r1, #64
     cee:	f001 fa83 	bl	21f8 <USART_GetFlagStatus>
     cf2:	2800      	cmp	r0, #0
     cf4:	d0f6      	beq.n	ce4 <usart_send_char+0x4>
    USART_SendData(USART1, ch);
     cf6:	f643 0000 	movw	r0, #14336	; 0x3800
     cfa:	f2c4 0001 	movt	r0, #16385	; 0x4001
     cfe:	4621      	mov	r1, r4
     d00:	f001 fa14 	bl	212c <USART_SendData>

    return 0;
}
     d04:	2000      	movs	r0, #0
     d06:	bd10      	pop	{r4, pc}

00000d08 <usart_init>:
#include <usart.h>
#include <stm32f10x_usart.h>
#include <stm32f10x_gpio.h>
#include <stm32f10x_rcc.h>

int usart_init(unsigned int baudrate) {
     d08:	b570      	push	{r4, r5, r6, lr}
    USART_InitTypeDef USART_InitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;

    /* Enable USART1, GPIOA and AFIO clocks */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
     d0a:	2101      	movs	r1, #1
#include <usart.h>
#include <stm32f10x_usart.h>
#include <stm32f10x_gpio.h>
#include <stm32f10x_rcc.h>

int usart_init(unsigned int baudrate) {
     d0c:	b088      	sub	sp, #32
     d0e:	4606      	mov	r6, r0

    /* Configure USART1 Tx (PA.09) as alternate function push-pull */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     d10:	f640 0400 	movw	r4, #2048	; 0x800
int usart_init(unsigned int baudrate) {
    USART_InitTypeDef USART_InitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;

    /* Enable USART1, GPIOA and AFIO clocks */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
     d14:	f244 0005 	movw	r0, #16389	; 0x4005
     d18:	f000 f9b0 	bl	107c <RCC_APB2PeriphClockCmd>

    /* Configure USART1 Tx (PA.09) as alternate function push-pull */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     d1c:	ad05      	add	r5, sp, #20
     d1e:	f2c4 0401 	movt	r4, #16385	; 0x4001

    /* Enable USART1, GPIOA and AFIO clocks */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);

    /* Configure USART1 Tx (PA.09) as alternate function push-pull */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
     d22:	f44f 7300 	mov.w	r3, #512	; 0x200
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
     d26:	2218      	movs	r2, #24

    /* Enable USART1, GPIOA and AFIO clocks */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);

    /* Configure USART1 Tx (PA.09) as alternate function push-pull */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
     d28:	f8ad 3014 	strh.w	r3, [sp, #20]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     d2c:	4620      	mov	r0, r4
    /* Enable USART1, GPIOA and AFIO clocks */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);

    /* Configure USART1 Tx (PA.09) as alternate function push-pull */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     d2e:	2303      	movs	r3, #3
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     d30:	4629      	mov	r1, r5
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);

    /* Configure USART1 Tx (PA.09) as alternate function push-pull */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
     d32:	9207      	str	r2, [sp, #28]
    /* Enable USART1, GPIOA and AFIO clocks */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);

    /* Configure USART1 Tx (PA.09) as alternate function push-pull */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     d34:	9306      	str	r3, [sp, #24]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     d36:	f000 fae5 	bl	1304 <GPIO_Init>

    /* Configure USART1 Rx (PA.10) as input floating */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     d3a:	4620      	mov	r0, r4
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* Configure USART1 Rx (PA.10) as input floating */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
     d3c:	f44f 6380 	mov.w	r3, #1024	; 0x400
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

    /* Configure USART1 */
    USART_Init(USART1, &USART_InitStructure);
     d40:	f643 0400 	movw	r4, #14336	; 0x3800
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* Configure USART1 Rx (PA.10) as input floating */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
     d44:	f8ad 3014 	strh.w	r3, [sp, #20]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     d48:	4629      	mov	r1, r5
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* Configure USART1 Rx (PA.10) as input floating */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
     d4a:	2304      	movs	r3, #4
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

    /* Configure USART1 */
    USART_Init(USART1, &USART_InitStructure);
     d4c:	f2c4 0401 	movt	r4, #16385	; 0x4001
        - Even parity
        - Hardware flow control disabled (RTS and CTS signals)
        - Receive and transmit enabled
    */
    USART_InitStructure.USART_BaudRate = baudrate;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
     d50:	2500      	movs	r5, #0
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* Configure USART1 Rx (PA.10) as input floating */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
     d52:	9307      	str	r3, [sp, #28]
    GPIO_Init(GPIOA, &GPIO_InitStructure);
     d54:	f000 fad6 	bl	1304 <GPIO_Init>
    USART_InitStructure.USART_BaudRate = baudrate;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
     d58:	f04f 030c 	mov.w	r3, #12	; 0xc

    /* Configure USART1 */
    USART_Init(USART1, &USART_InitStructure);
     d5c:	4620      	mov	r0, r4
     d5e:	a901      	add	r1, sp, #4
    USART_InitStructure.USART_BaudRate = baudrate;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
     d60:	f8ad 300e 	strh.w	r3, [sp, #14]
        - One Stop Bit
        - Even parity
        - Hardware flow control disabled (RTS and CTS signals)
        - Receive and transmit enabled
    */
    USART_InitStructure.USART_BaudRate = baudrate;
     d64:	9601      	str	r6, [sp, #4]
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
     d66:	f8ad 5008 	strh.w	r5, [sp, #8]
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
     d6a:	f8ad 500a 	strh.w	r5, [sp, #10]
    USART_InitStructure.USART_Parity = USART_Parity_No;
     d6e:	f8ad 500c 	strh.w	r5, [sp, #12]
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
     d72:	f8ad 5010 	strh.w	r5, [sp, #16]
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

    /* Configure USART1 */
    USART_Init(USART1, &USART_InitStructure);
     d76:	f001 fa7d 	bl	2274 <USART_Init>

    /* Enable the USART1 */
    USART_Cmd(USART1, ENABLE);
     d7a:	4620      	mov	r0, r4
     d7c:	2101      	movs	r1, #1
     d7e:	f001 f957 	bl	2030 <USART_Cmd>

    return 0;
}
     d82:	4628      	mov	r0, r5
     d84:	b008      	add	sp, #32
     d86:	bd70      	pop	{r4, r5, r6, pc}

00000d88 <usart_send_str>:
        return 0;
    else
        return 1;
}

int usart_send_str(char *str) {
     d88:	b570      	push	{r4, r5, r6, lr}
    unsigned int counter;

    for (counter = 0; str[counter]; counter++)
     d8a:	7804      	ldrb	r4, [r0, #0]
        return 0;
    else
        return 1;
}

int usart_send_str(char *str) {
     d8c:	4606      	mov	r6, r0
    unsigned int counter;

    for (counter = 0; str[counter]; counter++)
     d8e:	b1a4      	cbz	r4, dba <usart_send_str+0x32>
     d90:	2500      	movs	r5, #0

    return 0;
}

int usart_send_char(char ch) {
    while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
     d92:	f643 0000 	movw	r0, #14336	; 0x3800
     d96:	f2c4 0001 	movt	r0, #16385	; 0x4001
     d9a:	2140      	movs	r1, #64
     d9c:	f001 fa2c 	bl	21f8 <USART_GetFlagStatus>
     da0:	2800      	cmp	r0, #0
     da2:	d0f6      	beq.n	d92 <usart_send_str+0xa>
    USART_SendData(USART1, ch);
     da4:	f643 0000 	movw	r0, #14336	; 0x3800
     da8:	4621      	mov	r1, r4
     daa:	f2c4 0001 	movt	r0, #16385	; 0x4001
}

int usart_send_str(char *str) {
    unsigned int counter;

    for (counter = 0; str[counter]; counter++)
     dae:	3501      	adds	r5, #1
    return 0;
}

int usart_send_char(char ch) {
    while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
    USART_SendData(USART1, ch);
     db0:	f001 f9bc 	bl	212c <USART_SendData>
}

int usart_send_str(char *str) {
    unsigned int counter;

    for (counter = 0; str[counter]; counter++)
     db4:	5dac      	ldrb	r4, [r5, r6]
     db6:	2c00      	cmp	r4, #0
     db8:	d1eb      	bne.n	d92 <usart_send_str+0xa>
        usart_send_char(str[counter]);

    return 0;
}
     dba:	2000      	movs	r0, #0
     dbc:	bd70      	pop	{r4, r5, r6, pc}
     dbe:	46c0      	nop			(mov r8, r8)

00000dc0 <RCC_DeInit>:
* Return         : None
*******************************************************************************/
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (u32)0x00000001;
     dc0:	f241 0000 	movw	r0, #4096	; 0x1000
     dc4:	f2c4 0002 	movt	r0, #16386	; 0x4002
     dc8:	6803      	ldr	r3, [r0, #0]
     dca:	f043 0301 	orr.w	r3, r3, #1	; 0x1
     dce:	6003      	str	r3, [r0, #0]

  /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
  RCC->CFGR &= (u32)0xF8FF0000;
     dd0:	6842      	ldr	r2, [r0, #4]
     dd2:	f240 0300 	movw	r3, #0	; 0x0
     dd6:	f6cf 03ff 	movt	r3, #63743	; 0xf8ff
     dda:	401a      	ands	r2, r3
     ddc:	6042      	str	r2, [r0, #4]
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (u32)0xFEF6FFFF;
     dde:	6801      	ldr	r1, [r0, #0]
     de0:	f64f 73ff 	movw	r3, #65535	; 0xffff
     de4:	f6cf 63f6 	movt	r3, #65270	; 0xfef6
     de8:	4019      	ands	r1, r3
     dea:	6001      	str	r1, [r0, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (u32)0xFFFBFFFF;
     dec:	6803      	ldr	r3, [r0, #0]
     dee:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
     df2:	6003      	str	r3, [r0, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
  RCC->CFGR &= (u32)0xFF80FFFF;
     df4:	6842      	ldr	r2, [r0, #4]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
     df6:	2300      	movs	r3, #0

  /* Reset HSEBYP bit */
  RCC->CR &= (u32)0xFFFBFFFF;

  /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
  RCC->CFGR &= (u32)0xFF80FFFF;
     df8:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
     dfc:	6042      	str	r2, [r0, #4]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
     dfe:	6083      	str	r3, [r0, #8]
}
     e00:	4770      	bx	lr
     e02:	46c0      	nop			(mov r8, r8)

00000e04 <RCC_HSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
     e04:	f241 0100 	movw	r1, #4096	; 0x1000
     e08:	f2c4 0102 	movt	r1, #16386	; 0x4002
     e0c:	680b      	ldr	r3, [r1, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;

  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
     e0e:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
     e12:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
     e16:	600b      	str	r3, [r1, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
     e18:	680a      	ldr	r2, [r1, #0]
     e1a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
     e1e:	600a      	str	r2, [r1, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
     e20:	bf02      	ittt	eq
     e22:	680b      	ldreq	r3, [r1, #0]
     e24:	f443 3380 	orreq.w	r3, r3, #65536	; 0x10000
     e28:	600b      	streq	r3, [r1, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;

  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
     e2a:	d006      	beq.n	e3a <RCC_HSEConfig+0x36>
     e2c:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
     e30:	d103      	bne.n	e3a <RCC_HSEConfig+0x36>
      RCC->CR |= CR_HSEON_Set;
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
     e32:	680b      	ldr	r3, [r1, #0]
     e34:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
     e38:	600b      	str	r3, [r1, #0]
      break;            
      
    default:
      break;      
  }
}
     e3a:	4770      	bx	lr

00000e3c <RCC_AdjustHSICalibrationValue>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
     e3c:	f241 0200 	movw	r2, #4096	; 0x1000
     e40:	f2c4 0202 	movt	r2, #16386	; 0x4002
     e44:	6813      	ldr	r3, [r2, #0]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= CR_HSITRIM_Mask;
     e46:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (u32)HSICalibrationValue << 3;
     e4a:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
     e4e:	6013      	str	r3, [r2, #0]
}
     e50:	4770      	bx	lr
     e52:	46c0      	nop			(mov r8, r8)

00000e54 <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_HSION_BB = (u32)NewState;
     e54:	f240 0300 	movw	r3, #0	; 0x0
     e58:	f2c4 2342 	movt	r3, #16962	; 0x4242
     e5c:	6018      	str	r0, [r3, #0]
}
     e5e:	4770      	bx	lr

00000e60 <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
     e60:	f241 0300 	movw	r3, #4096	; 0x1000
     e64:	f2c4 0302 	movt	r3, #16386	; 0x4002
     e68:	685a      	ldr	r2, [r3, #4]

  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;

  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
     e6a:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
     e6e:	4310      	orrs	r0, r2
     e70:	4308      	orrs	r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
     e72:	6058      	str	r0, [r3, #4]
}
     e74:	4770      	bx	lr
     e76:	46c0      	nop			(mov r8, r8)

00000e78 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_PLLON_BB = (u32)NewState;
     e78:	f240 0360 	movw	r3, #96	; 0x60
     e7c:	f2c4 2342 	movt	r3, #16962	; 0x4242
     e80:	6018      	str	r0, [r3, #0]
}
     e82:	4770      	bx	lr

00000e84 <RCC_SYSCLKConfig>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
     e84:	f241 0300 	movw	r3, #4096	; 0x1000
     e88:	f2c4 0302 	movt	r3, #16386	; 0x4002
     e8c:	685a      	ldr	r2, [r3, #4]

  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
     e8e:	f022 0203 	bic.w	r2, r2, #3	; 0x3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
     e92:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
     e94:	6058      	str	r0, [r3, #4]
}
     e96:	4770      	bx	lr

00000e98 <RCC_GetSYSCLKSource>:
*                       - 0x04: HSE used as system clock
*                       - 0x08: PLL used as system clock
*******************************************************************************/
u8 RCC_GetSYSCLKSource(void)
{
  return ((u8)(RCC->CFGR & CFGR_SWS_Mask));
     e98:	f241 0300 	movw	r3, #4096	; 0x1000
     e9c:	f2c4 0302 	movt	r3, #16386	; 0x4002
     ea0:	6858      	ldr	r0, [r3, #4]
}
     ea2:	f000 000c 	and.w	r0, r0, #12	; 0xc
     ea6:	4770      	bx	lr

00000ea8 <RCC_HCLKConfig>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
     ea8:	f241 0300 	movw	r3, #4096	; 0x1000
     eac:	f2c4 0302 	movt	r3, #16386	; 0x4002
     eb0:	685a      	ldr	r2, [r3, #4]

  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
     eb2:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
     eb6:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
     eb8:	6058      	str	r0, [r3, #4]
}
     eba:	4770      	bx	lr

00000ebc <RCC_PCLK1Config>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
     ebc:	f241 0300 	movw	r3, #4096	; 0x1000
     ec0:	f2c4 0302 	movt	r3, #16386	; 0x4002
     ec4:	685a      	ldr	r2, [r3, #4]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
     ec6:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
     eca:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
     ecc:	6058      	str	r0, [r3, #4]
}
     ece:	4770      	bx	lr

00000ed0 <RCC_PCLK2Config>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
     ed0:	f241 0200 	movw	r2, #4096	; 0x1000
     ed4:	f2c4 0202 	movt	r2, #16386	; 0x4002
     ed8:	6853      	ldr	r3, [r2, #4]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
     eda:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
     ede:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
     ee2:	6053      	str	r3, [r2, #4]
}
     ee4:	4770      	bx	lr
     ee6:	46c0      	nop			(mov r8, r8)

00000ee8 <RCC_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
     ee8:	b141      	cbz	r1, efc <RCC_ITConfig+0x14>
  {
    /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
    *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
     eea:	f241 0209 	movw	r2, #4105	; 0x1009
     eee:	f2c4 0202 	movt	r2, #16386	; 0x4002
     ef2:	7813      	ldrb	r3, [r2, #0]
     ef4:	ea40 0303 	orr.w	r3, r0, r3
     ef8:	7013      	strb	r3, [r2, #0]
  else
  {
    /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
    *(vu8 *) CIR_BYTE2_ADDRESS &= (u8)~RCC_IT;
  }
}
     efa:	4770      	bx	lr
    *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
    *(vu8 *) CIR_BYTE2_ADDRESS &= (u8)~RCC_IT;
     efc:	f241 0309 	movw	r3, #4105	; 0x1009
     f00:	f2c4 0302 	movt	r3, #16386	; 0x4002
     f04:	781a      	ldrb	r2, [r3, #0]
     f06:	43c1      	mvns	r1, r0
     f08:	400a      	ands	r2, r1
     f0a:	701a      	strb	r2, [r3, #0]
     f0c:	e7f5      	b.n	efa <RCC_ITConfig+0x12>
     f0e:	46c0      	nop			(mov r8, r8)

00000f10 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
     f10:	f240 03d8 	movw	r3, #216	; 0xd8
     f14:	f2c4 2342 	movt	r3, #16962	; 0x4242
     f18:	6018      	str	r0, [r3, #0]
}
     f1a:	4770      	bx	lr

00000f1c <RCC_ADCCLKConfig>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));

  tmpreg = RCC->CFGR;
     f1c:	f241 0300 	movw	r3, #4096	; 0x1000
     f20:	f2c4 0302 	movt	r3, #16386	; 0x4002
     f24:	685a      	ldr	r2, [r3, #4]

  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
     f26:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000

  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
     f2a:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
     f2c:	6058      	str	r0, [r3, #4]
}
     f2e:	4770      	bx	lr

00000f30 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
     f30:	f241 0220 	movw	r2, #4128	; 0x1020
     f34:	f2c4 0202 	movt	r2, #16386	; 0x4002
     f38:	2300      	movs	r3, #0

  /* Reset LSEBYP bit */
  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
     f3a:	2801      	cmp	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
     f3c:	7013      	strb	r3, [r2, #0]

  /* Reset LSEBYP bit */
  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
     f3e:	7013      	strb	r3, [r2, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
     f40:	bf08      	it	eq
     f42:	7010      	strbeq	r0, [r2, #0]

  /* Reset LSEBYP bit */
  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
     f44:	d003      	beq.n	f4e <RCC_LSEConfig+0x1e>
     f46:	2804      	cmp	r0, #4
     f48:	d101      	bne.n	f4e <RCC_LSEConfig+0x1e>
      *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(vu8 *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
     f4a:	2305      	movs	r3, #5
     f4c:	7013      	strb	r3, [r2, #0]
      break;            
      
    default:
      break;      
  }
}
     f4e:	4770      	bx	lr

00000f50 <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CSR_LSION_BB = (u32)NewState;
     f50:	f240 4380 	movw	r3, #1152	; 0x480
     f54:	f2c4 2342 	movt	r3, #16962	; 0x4242
     f58:	6018      	str	r0, [r3, #0]
}
     f5a:	4770      	bx	lr

00000f5c <RCC_RTCCLKConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
     f5c:	f241 0300 	movw	r3, #4096	; 0x1000
     f60:	f2c4 0302 	movt	r3, #16386	; 0x4002
     f64:	6a1a      	ldr	r2, [r3, #32]
     f66:	4310      	orrs	r0, r2
     f68:	6218      	str	r0, [r3, #32]
}
     f6a:	4770      	bx	lr

00000f6c <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
     f6c:	f240 433c 	movw	r3, #1084	; 0x43c
     f70:	f2c4 2342 	movt	r3, #16962	; 0x4242
     f74:	6018      	str	r0, [r3, #0]
}
     f76:	4770      	bx	lr

00000f78 <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
     f78:	f241 0100 	movw	r1, #4096	; 0x1000
     f7c:	f2c4 0102 	movt	r1, #16386	; 0x4002
     f80:	684b      	ldr	r3, [r1, #4]
*                    will hold the clocks frequencies.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
     f82:	b430      	push	{r4, r5}
  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;

  switch (tmp)
     f84:	f003 030c 	and.w	r3, r3, #12	; 0xc
     f88:	2b04      	cmp	r3, #4
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
      break;

    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
     f8a:	bf04      	itt	eq
     f8c:	f641 3300 	movweq	r3, #6912	; 0x1b00
     f90:	f2c0 03b7 	movteq	r3, #183	; 0xb7
*                    will hold the clocks frequencies.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
     f94:	4605      	mov	r5, r0
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
      break;

    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
     f96:	bf04      	itt	eq
     f98:	6003      	streq	r3, [r0, #0]
     f9a:	4619      	moveq	r1, r3
  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;

  switch (tmp)
     f9c:	d007      	beq.n	fae <RCC_GetClocksFreq+0x36>
     f9e:	2b08      	cmp	r3, #8
     fa0:	d02b      	beq.n	ffa <RCC_GetClocksFreq+0x82>
        }
      }
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
     fa2:	f241 2300 	movw	r3, #4608	; 0x1200
     fa6:	f2c0 037a 	movt	r3, #122	; 0x7a
     faa:	6003      	str	r3, [r0, #0]
     fac:	4619      	mov	r1, r3
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
     fae:	f241 0400 	movw	r4, #4096	; 0x1000
     fb2:	f2c4 0402 	movt	r4, #16386	; 0x4002
     fb6:	6863      	ldr	r3, [r4, #4]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];

  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
     fb8:	4825      	ldr	r0, [pc, #148]	(1050 <RCC_GetClocksFreq+0xd8>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
     fba:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];

  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
     fbe:	091b      	lsrs	r3, r3, #4
     fc0:	5cc2      	ldrb	r2, [r0, r3]
     fc2:	40d1      	lsrs	r1, r2
     fc4:	6069      	str	r1, [r5, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
     fc6:	6863      	ldr	r3, [r4, #4]
     fc8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  tmp = tmp >> 8;
  presc = APBAHBPrescTable[tmp];

  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
     fcc:	0a1b      	lsrs	r3, r3, #8
     fce:	5cc2      	ldrb	r2, [r0, r3]
     fd0:	fa31 f202 	lsrs.w	r2, r1, r2
     fd4:	60aa      	str	r2, [r5, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
     fd6:	6863      	ldr	r3, [r4, #4]
     fd8:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
  tmp = tmp >> 11;
  presc = APBAHBPrescTable[tmp];

  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
     fdc:	0adb      	lsrs	r3, r3, #11
     fde:	5cc2      	ldrb	r2, [r0, r3]
     fe0:	40d1      	lsrs	r1, r2
     fe2:	60e9      	str	r1, [r5, #12]

  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
     fe4:	6863      	ldr	r3, [r4, #4]
     fe6:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];

  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
     fea:	eb00 3093 	add.w	r0, r0, r3, lsr #14
     fee:	7c02      	ldrb	r2, [r0, #16]
     ff0:	fbb1 f1f2 	udiv	r1, r1, r2
     ff4:	6129      	str	r1, [r5, #16]
}
     ff6:	bc30      	pop	{r4, r5}
     ff8:	4770      	bx	lr
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
      break;

    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
     ffa:	684b      	ldr	r3, [r1, #4]
      pllmull = ( pllmull >> 18) + 2;

      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
     ffc:	684a      	ldr	r2, [r1, #4]
      break;

    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
      pllmull = ( pllmull >> 18) + 2;
     ffe:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
    1002:	0c9b      	lsrs	r3, r3, #18
    1004:	1c98      	adds	r0, r3, #2

      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;

      if (pllsource == 0x00)
    1006:	f412 3f80 	tst.w	r2, #65536	; 0x10000
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
    100a:	bf01      	itttt	eq
    100c:	f640 1300 	movweq	r3, #2304	; 0x900
    1010:	f2c0 033d 	movteq	r3, #61	; 0x3d
    1014:	fb00 f303 	muleq.w	r3, r0, r3
    1018:	602b      	streq	r3, [r5, #0]
    101a:	bf08      	it	eq
    101c:	4619      	moveq	r1, r3
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
      pllmull = ( pllmull >> 18) + 2;

      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;

      if (pllsource == 0x00)
    101e:	d0c6      	beq.n	fae <RCC_GetClocksFreq+0x36>
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
      }
      else
      {/* HSE selected as PLL clock entry */

        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
    1020:	684b      	ldr	r3, [r1, #4]
    1022:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        {/* HSE oscillator clock divided by 2 */

          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
    1026:	bf15      	itete	ne
    1028:	f648 5380 	movwne	r3, #36224	; 0x8d80
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
    102c:	f641 3300 	movweq	r3, #6912	; 0x1b00
      {/* HSE selected as PLL clock entry */

        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
        {/* HSE oscillator clock divided by 2 */

          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
    1030:	f2c0 035b 	movtne	r3, #91	; 0x5b
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
    1034:	f2c0 03b7 	movteq	r3, #183	; 0xb7
      {/* HSE selected as PLL clock entry */

        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
        {/* HSE oscillator clock divided by 2 */

          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
    1038:	bf17      	itett	ne
    103a:	fb00 f303 	mulne.w	r3, r0, r3
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
    103e:	fb00 f303 	muleq.w	r3, r0, r3
      {/* HSE selected as PLL clock entry */

        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
        {/* HSE oscillator clock divided by 2 */

          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
    1042:	602b      	strne	r3, [r5, #0]
    1044:	4619      	movne	r1, r3
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
    1046:	bf04      	itt	eq
    1048:	602b      	streq	r3, [r5, #0]
    104a:	4619      	moveq	r1, r3
    104c:	e7af      	b.n	fae <RCC_GetClocksFreq+0x36>
    104e:	46c0      	nop			(mov r8, r8)
    1050:	00002a0c 	.word	0x00002a0c

00001054 <RCC_AHBPeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
    1054:	b141      	cbz	r1, 1068 <RCC_AHBPeriphClockCmd+0x14>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
    1056:	f241 0200 	movw	r2, #4096	; 0x1000
    105a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    105e:	6953      	ldr	r3, [r2, #20]
    1060:	ea40 0303 	orr.w	r3, r0, r3
    1064:	6153      	str	r3, [r2, #20]
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
  }
}
    1066:	4770      	bx	lr
  {
    RCC->AHBENR |= RCC_AHBPeriph;
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
    1068:	f241 0300 	movw	r3, #4096	; 0x1000
    106c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    1070:	6959      	ldr	r1, [r3, #20]
    1072:	43c2      	mvns	r2, r0
    1074:	400a      	ands	r2, r1
    1076:	615a      	str	r2, [r3, #20]
    1078:	e7f5      	b.n	1066 <RCC_AHBPeriphClockCmd+0x12>
    107a:	46c0      	nop			(mov r8, r8)

0000107c <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
    107c:	b141      	cbz	r1, 1090 <RCC_APB2PeriphClockCmd+0x14>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
    107e:	f241 0200 	movw	r2, #4096	; 0x1000
    1082:	f2c4 0202 	movt	r2, #16386	; 0x4002
    1086:	6993      	ldr	r3, [r2, #24]
    1088:	ea40 0303 	orr.w	r3, r0, r3
    108c:	6193      	str	r3, [r2, #24]
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
    108e:	4770      	bx	lr
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
    1090:	f241 0300 	movw	r3, #4096	; 0x1000
    1094:	f2c4 0302 	movt	r3, #16386	; 0x4002
    1098:	6999      	ldr	r1, [r3, #24]
    109a:	43c2      	mvns	r2, r0
    109c:	400a      	ands	r2, r1
    109e:	619a      	str	r2, [r3, #24]
    10a0:	e7f5      	b.n	108e <RCC_APB2PeriphClockCmd+0x12>
    10a2:	46c0      	nop			(mov r8, r8)

000010a4 <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
    10a4:	b141      	cbz	r1, 10b8 <RCC_APB1PeriphClockCmd+0x14>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
    10a6:	f241 0200 	movw	r2, #4096	; 0x1000
    10aa:	f2c4 0202 	movt	r2, #16386	; 0x4002
    10ae:	69d3      	ldr	r3, [r2, #28]
    10b0:	ea40 0303 	orr.w	r3, r0, r3
    10b4:	61d3      	str	r3, [r2, #28]
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
  }
}
    10b6:	4770      	bx	lr
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
    10b8:	f241 0300 	movw	r3, #4096	; 0x1000
    10bc:	f2c4 0302 	movt	r3, #16386	; 0x4002
    10c0:	69d9      	ldr	r1, [r3, #28]
    10c2:	43c2      	mvns	r2, r0
    10c4:	400a      	ands	r2, r1
    10c6:	61da      	str	r2, [r3, #28]
    10c8:	e7f5      	b.n	10b6 <RCC_APB1PeriphClockCmd+0x12>
    10ca:	46c0      	nop			(mov r8, r8)

000010cc <RCC_APB2PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
    10cc:	b141      	cbz	r1, 10e0 <RCC_APB2PeriphResetCmd+0x14>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
    10ce:	f241 0200 	movw	r2, #4096	; 0x1000
    10d2:	f2c4 0202 	movt	r2, #16386	; 0x4002
    10d6:	68d3      	ldr	r3, [r2, #12]
    10d8:	ea40 0303 	orr.w	r3, r0, r3
    10dc:	60d3      	str	r3, [r2, #12]
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
  }
}
    10de:	4770      	bx	lr
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
    10e0:	f241 0300 	movw	r3, #4096	; 0x1000
    10e4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    10e8:	68d9      	ldr	r1, [r3, #12]
    10ea:	43c2      	mvns	r2, r0
    10ec:	400a      	ands	r2, r1
    10ee:	60da      	str	r2, [r3, #12]
    10f0:	e7f5      	b.n	10de <RCC_APB2PeriphResetCmd+0x12>
    10f2:	46c0      	nop			(mov r8, r8)

000010f4 <RCC_APB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
    10f4:	b141      	cbz	r1, 1108 <RCC_APB1PeriphResetCmd+0x14>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
    10f6:	f241 0200 	movw	r2, #4096	; 0x1000
    10fa:	f2c4 0202 	movt	r2, #16386	; 0x4002
    10fe:	6913      	ldr	r3, [r2, #16]
    1100:	ea40 0303 	orr.w	r3, r0, r3
    1104:	6113      	str	r3, [r2, #16]
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
  }
}
    1106:	4770      	bx	lr
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
    1108:	f241 0300 	movw	r3, #4096	; 0x1000
    110c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    1110:	6919      	ldr	r1, [r3, #16]
    1112:	43c2      	mvns	r2, r0
    1114:	400a      	ands	r2, r1
    1116:	611a      	str	r2, [r3, #16]
    1118:	e7f5      	b.n	1106 <RCC_APB1PeriphResetCmd+0x12>
    111a:	46c0      	nop			(mov r8, r8)

0000111c <RCC_BackupResetCmd>:
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
    111c:	f240 4340 	movw	r3, #1088	; 0x440
    1120:	f2c4 2342 	movt	r3, #16962	; 0x4242
    1124:	6018      	str	r0, [r3, #0]
}
    1126:	4770      	bx	lr

00001128 <RCC_ClockSecuritySystemCmd>:
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_CSSON_BB = (u32)NewState;
    1128:	f240 034c 	movw	r3, #76	; 0x4c
    112c:	f2c4 2342 	movt	r3, #16962	; 0x4242
    1130:	6018      	str	r0, [r3, #0]
}
    1132:	4770      	bx	lr

00001134 <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO[2:0] bits to select the MCO source */
  *(vu8 *) CFGR_BYTE4_ADDRESS = RCC_MCO;
    1134:	f241 0307 	movw	r3, #4103	; 0x1007
    1138:	f2c4 0302 	movt	r3, #16386	; 0x4002
    113c:	7018      	strb	r0, [r3, #0]
}
    113e:	4770      	bx	lr

00001140 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
    1140:	0943      	lsrs	r3, r0, #5

  if (tmp == 1)               /* The flag to check is in CR register */
    1142:	2b01      	cmp	r3, #1
  {
    statusreg = RCC->CR;
    1144:	bf04      	itt	eq
    1146:	f241 0300 	movweq	r3, #4096	; 0x1000
    114a:	f2c4 0302 	movteq	r3, #16386	; 0x4002
    114e:	bf08      	it	eq
    1150:	681b      	ldreq	r3, [r3, #0]
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;

  if (tmp == 1)               /* The flag to check is in CR register */
    1152:	d00c      	beq.n	116e <RCC_GetFlagStatus+0x2e>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
    1154:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
    1156:	bf0b      	itete	eq
    1158:	f241 0300 	movweq	r3, #4096	; 0x1000
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
    115c:	f241 0300 	movwne	r3, #4096	; 0x1000
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
    1160:	f2c4 0302 	movteq	r3, #16386	; 0x4002
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
    1164:	f2c4 0302 	movtne	r3, #16386	; 0x4002
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
    1168:	bf0c      	ite	eq
    116a:	6a1b      	ldreq	r3, [r3, #32]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
    116c:	6a5b      	ldrne	r3, [r3, #36]
    116e:	f000 001f 	and.w	r0, r0, #31	; 0x1f
    1172:	fa33 f000 	lsrs.w	r0, r3, r0
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
    1176:	f000 0001 	and.w	r0, r0, #1	; 0x1
    117a:	4770      	bx	lr

0000117c <RCC_ClearFlag>:
* Return         : None
*******************************************************************************/
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= CSR_RMVF_Set;
    117c:	f241 0200 	movw	r2, #4096	; 0x1000
    1180:	f2c4 0202 	movt	r2, #16386	; 0x4002
    1184:	6a53      	ldr	r3, [r2, #36]
    1186:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    118a:	6253      	str	r3, [r2, #36]
}
    118c:	4770      	bx	lr
    118e:	46c0      	nop			(mov r8, r8)

00001190 <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (u32)RESET)
    1190:	f241 0300 	movw	r3, #4096	; 0x1000
    1194:	f2c4 0302 	movt	r3, #16386	; 0x4002
    1198:	689a      	ldr	r2, [r3, #8]
    119a:	4210      	tst	r0, r2
    bitstatus = RESET;
  }

  /* Return the RCC_IT status */
  return  bitstatus;
}
    119c:	bf0c      	ite	eq
    119e:	2000      	moveq	r0, #0
    11a0:	2001      	movne	r0, #1
    11a2:	4770      	bx	lr

000011a4 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(vu8 *) CIR_BYTE3_ADDRESS = RCC_IT;
    11a4:	f241 030a 	movw	r3, #4106	; 0x100a
    11a8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    11ac:	7018      	strb	r0, [r3, #0]
}
    11ae:	4770      	bx	lr

000011b0 <RCC_WaitForHSEStartUp>:
* Return         : An ErrorStatus enumuration value:
*                         - SUCCESS: HSE oscillator is stable and ready to use
*                         - ERROR: HSE oscillator not yet ready
*******************************************************************************/
ErrorStatus RCC_WaitForHSEStartUp(void)
{
    11b0:	b410      	push	{r4}
    11b2:	480d      	ldr	r0, [pc, #52]	(11e8 <RCC_WaitForHSEStartUp+0x38>)
  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;

  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
    11b4:	f241 0400 	movw	r4, #4096	; 0x1000
    11b8:	f2c4 0402 	movt	r4, #16386	; 0x4002
    11bc:	6823      	ldr	r3, [r4, #0]
    11be:	0c5b      	lsrs	r3, r3, #17
    11c0:	f003 0301 	and.w	r3, r3, #1	; 0x1
  ErrorStatus status = ERROR;

  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    11c4:	6003      	str	r3, [r0, #0]
    StartUpCounter++;  
    11c6:	6842      	ldr	r2, [r0, #4]
    11c8:	3201      	adds	r2, #1
    11ca:	6042      	str	r2, [r0, #4]
  } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
    11cc:	6803      	ldr	r3, [r0, #0]
    11ce:	b92b      	cbnz	r3, 11dc <RCC_WaitForHSEStartUp+0x2c>
    11d0:	4b05      	ldr	r3, [pc, #20]	(11e8 <RCC_WaitForHSEStartUp+0x38>)
    11d2:	f240 12ff 	movw	r2, #511	; 0x1ff
    11d6:	6859      	ldr	r1, [r3, #4]
    11d8:	4291      	cmp	r1, r2
    11da:	d1eb      	bne.n	11b4 <RCC_WaitForHSEStartUp+0x4>
  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;

  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
    11dc:	6820      	ldr	r0, [r4, #0]
    11de:	0c40      	lsrs	r0, r0, #17
  {
    status = ERROR;
  }  

  return (status);
}
    11e0:	f000 0001 	and.w	r0, r0, #1	; 0x1
    11e4:	bc10      	pop	{r4}
    11e6:	4770      	bx	lr
    11e8:	20000000 	.word	0x20000000

000011ec <FLASH_SetLatency>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Sets the Latency value */
  FLASH->ACR &= ACR_LATENCY_Mask;
    11ec:	f242 0200 	movw	r2, #8192	; 0x2000
    11f0:	f2c4 0202 	movt	r2, #16386	; 0x4002
    11f4:	6813      	ldr	r3, [r2, #0]
    11f6:	f003 0338 	and.w	r3, r3, #56	; 0x38
    11fa:	6013      	str	r3, [r2, #0]
  FLASH->ACR |= FLASH_Latency;
    11fc:	6811      	ldr	r1, [r2, #0]
    11fe:	4308      	orrs	r0, r1
    1200:	6010      	str	r0, [r2, #0]
}
    1202:	4770      	bx	lr

00001204 <FLASH_HalfCycleAccessCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
  
  /* Enable or disable the Half cycle access */
  FLASH->ACR &= ACR_HLFCYA_Mask;
    1204:	f242 0200 	movw	r2, #8192	; 0x2000
    1208:	f2c4 0202 	movt	r2, #16386	; 0x4002
    120c:	6813      	ldr	r3, [r2, #0]
    120e:	f023 0308 	bic.w	r3, r3, #8	; 0x8
    1212:	6013      	str	r3, [r2, #0]
  FLASH->ACR |= FLASH_HalfCycleAccess;
    1214:	6811      	ldr	r1, [r2, #0]
    1216:	4308      	orrs	r0, r1
    1218:	6010      	str	r0, [r2, #0]
}
    121a:	4770      	bx	lr

0000121c <FLASH_PrefetchBufferCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
    121c:	f242 0200 	movw	r2, #8192	; 0x2000
    1220:	f2c4 0202 	movt	r2, #16386	; 0x4002
    1224:	6813      	ldr	r3, [r2, #0]
    1226:	f023 0310 	bic.w	r3, r3, #16	; 0x10
    122a:	6013      	str	r3, [r2, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
    122c:	6811      	ldr	r1, [r2, #0]
    122e:	4308      	orrs	r0, r1
    1230:	6010      	str	r0, [r2, #0]
}
    1232:	4770      	bx	lr

00001234 <SysTick_CLKSourceConfig>:
void SysTick_CLKSourceConfig(u32 SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));

  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
    1234:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
    1236:	bf0b      	itete	eq
    1238:	f24e 0210 	movweq	r2, #57360	; 0xe010
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
    123c:	f24e 0210 	movwne	r2, #57360	; 0xe010
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));

  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
    1240:	f2ce 0200 	movteq	r2, #57344	; 0xe000
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
    1244:	f2ce 0200 	movtne	r2, #57344	; 0xe000
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));

  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
    1248:	bf0b      	itete	eq
    124a:	6813      	ldreq	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
    124c:	6813      	ldrne	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));

  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
    124e:	f043 0304 	orreq.w	r3, r3, #4	; 0x4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
    1252:	f023 0304 	bicne.w	r3, r3, #4	; 0x4
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));

  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
    1256:	bf0c      	ite	eq
    1258:	6013      	streq	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
    125a:	6013      	strne	r3, [r2, #0]
  }
}
    125c:	4770      	bx	lr
    125e:	46c0      	nop			(mov r8, r8)

00001260 <SysTick_SetReload>:
void SysTick_SetReload(u32 Reload)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_RELOAD(Reload));

  SysTick->LOAD = Reload;
    1260:	f24e 0310 	movw	r3, #57360	; 0xe010
    1264:	f2ce 0300 	movt	r3, #57344	; 0xe000
    1268:	6058      	str	r0, [r3, #4]
}
    126a:	4770      	bx	lr

0000126c <SysTick_CounterCmd>:
void SysTick_CounterCmd(u32 SysTick_Counter)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_COUNTER(SysTick_Counter));

  if (SysTick_Counter == SysTick_Counter_Enable)
    126c:	2801      	cmp	r0, #1
    126e:	d009      	beq.n	1284 <SysTick_CounterCmd+0x18>
  {
    SysTick->CTRL |= SysTick_Counter_Enable;
  }
  else if (SysTick_Counter == SysTick_Counter_Disable) 
    1270:	f110 0f02 	cmn.w	r0, #2	; 0x2
    1274:	d00f      	beq.n	1296 <SysTick_CounterCmd+0x2a>
  {
    SysTick->CTRL &= SysTick_Counter_Disable;
  }
  else /* SysTick_Counter == SysTick_Counter_Clear */
  {
    SysTick->VAL = SysTick_Counter_Clear;
    1276:	f24e 0310 	movw	r3, #57360	; 0xe010
    127a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    127e:	2200      	movs	r2, #0
    1280:	609a      	str	r2, [r3, #8]
  }    
}
    1282:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_SYSTICK_COUNTER(SysTick_Counter));

  if (SysTick_Counter == SysTick_Counter_Enable)
  {
    SysTick->CTRL |= SysTick_Counter_Enable;
    1284:	f24e 0210 	movw	r2, #57360	; 0xe010
    1288:	f2ce 0200 	movt	r2, #57344	; 0xe000
    128c:	6813      	ldr	r3, [r2, #0]
    128e:	f043 0301 	orr.w	r3, r3, #1	; 0x1
    1292:	6013      	str	r3, [r2, #0]
    1294:	e7f5      	b.n	1282 <SysTick_CounterCmd+0x16>
  }
  else if (SysTick_Counter == SysTick_Counter_Disable) 
  {
    SysTick->CTRL &= SysTick_Counter_Disable;
    1296:	f24e 0210 	movw	r2, #57360	; 0xe010
    129a:	f2ce 0200 	movt	r2, #57344	; 0xe000
    129e:	6813      	ldr	r3, [r2, #0]
    12a0:	f023 0301 	bic.w	r3, r3, #1	; 0x1
    12a4:	6013      	str	r3, [r2, #0]
    12a6:	e7ec      	b.n	1282 <SysTick_CounterCmd+0x16>

000012a8 <SysTick_ITConfig>:
void SysTick_ITConfig(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
    12a8:	b140      	cbz	r0, 12bc <SysTick_ITConfig+0x14>
  {
    SysTick->CTRL |= CTRL_TICKINT_Set;
    12aa:	f24e 0210 	movw	r2, #57360	; 0xe010
    12ae:	f2ce 0200 	movt	r2, #57344	; 0xe000
    12b2:	6813      	ldr	r3, [r2, #0]
    12b4:	f043 0302 	orr.w	r3, r3, #2	; 0x2
    12b8:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= CTRL_TICKINT_Reset;
  }
}
    12ba:	4770      	bx	lr
  {
    SysTick->CTRL |= CTRL_TICKINT_Set;
  }
  else
  {
    SysTick->CTRL &= CTRL_TICKINT_Reset;
    12bc:	f24e 0210 	movw	r2, #57360	; 0xe010
    12c0:	f2ce 0200 	movt	r2, #57344	; 0xe000
    12c4:	6813      	ldr	r3, [r2, #0]
    12c6:	f023 0302 	bic.w	r3, r3, #2	; 0x2
    12ca:	6013      	str	r3, [r2, #0]
    12cc:	e7f5      	b.n	12ba <SysTick_ITConfig+0x12>
    12ce:	46c0      	nop			(mov r8, r8)

000012d0 <SysTick_GetCounter>:
* Output         : None
* Return         : SysTick current value
*******************************************************************************/
u32 SysTick_GetCounter(void)
{
  return(SysTick->VAL);
    12d0:	f24e 0310 	movw	r3, #57360	; 0xe010
    12d4:	f2ce 0300 	movt	r3, #57344	; 0xe000
    12d8:	6898      	ldr	r0, [r3, #8]
}
    12da:	4770      	bx	lr

000012dc <SysTick_GetFlagStatus>:
  assert_param(IS_SYSTICK_FLAG(SysTick_FLAG));

  /* Get the SysTick register index */
  tmp = SysTick_FLAG >> 3;

  if (tmp == 2) /* The flag to check is in CTRL register */
    12dc:	08c3      	lsrs	r3, r0, #3
    12de:	2b02      	cmp	r3, #2
  {
    statusreg = SysTick->CTRL;
    12e0:	bf0b      	itete	eq
    12e2:	f24e 0310 	movweq	r3, #57360	; 0xe010
  }
  else          /* The flag to check is in CALIB register */
  {
    statusreg = SysTick->CALIB;
    12e6:	f24e 0310 	movwne	r3, #57360	; 0xe010
  /* Get the SysTick register index */
  tmp = SysTick_FLAG >> 3;

  if (tmp == 2) /* The flag to check is in CTRL register */
  {
    statusreg = SysTick->CTRL;
    12ea:	f2ce 0300 	movteq	r3, #57344	; 0xe000
  }
  else          /* The flag to check is in CALIB register */
  {
    statusreg = SysTick->CALIB;
    12ee:	f2ce 0300 	movtne	r3, #57344	; 0xe000
*                       - SysTick_FLAG_NOREF
* Output         : None
* Return         : None
*******************************************************************************/
FlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG)
{
    12f2:	4602      	mov	r2, r0
  /* Get the SysTick register index */
  tmp = SysTick_FLAG >> 3;

  if (tmp == 2) /* The flag to check is in CTRL register */
  {
    statusreg = SysTick->CTRL;
    12f4:	bf0c      	ite	eq
    12f6:	6818      	ldreq	r0, [r3, #0]
  }
  else          /* The flag to check is in CALIB register */
  {
    statusreg = SysTick->CALIB;
    12f8:	68d8      	ldrne	r0, [r3, #12]
    12fa:	40d0      	lsrs	r0, r2
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
    12fc:	f000 0001 	and.w	r0, r0, #1	; 0x1
    1300:	4770      	bx	lr
    1302:	46c0      	nop			(mov r8, r8)

00001304 <GPIO_Init>:
*                    peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
    1304:	b510      	push	{r4, lr}
    1306:	4604      	mov	r4, r0
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
    1308:	6888      	ldr	r0, [r1, #8]

  if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
    130a:	f010 0f10 	tst.w	r0, #16	; 0x10
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
    130e:	bf18      	it	ne
    1310:	684b      	ldrne	r3, [r1, #4]
  }

/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
    1312:	8809      	ldrh	r1, [r1, #0]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
    1314:	f000 0e0f 	and.w	lr, r0, #15	; 0xf
  if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
    1318:	bf18      	it	ne
    131a:	ea4e 0e03 	orrne.w	lr, lr, r3
  }

/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
    131e:	f011 0fff 	tst.w	r1, #255	; 0xff
    1322:	d029      	beq.n	1378 <GPIO_Init+0x74>

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    1324:	f001 0201 	and.w	r2, r1, #1	; 0x1

/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    1328:	6823      	ldr	r3, [r4, #0]
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

      if (currentpin == pos)
    132a:	2a00      	cmp	r2, #0
    132c:	f040 8126 	bne.w	157c <GPIO_Init+0x278>

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    1330:	f001 0202 	and.w	r2, r1, #2	; 0x2

      if (currentpin == pos)
    1334:	2a00      	cmp	r2, #0
    1336:	f040 80fe 	bne.w	1536 <GPIO_Init+0x232>

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    133a:	f001 0204 	and.w	r2, r1, #4	; 0x4

      if (currentpin == pos)
    133e:	2a00      	cmp	r2, #0
    1340:	f040 810a 	bne.w	1558 <GPIO_Init+0x254>

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    1344:	f001 0208 	and.w	r2, r1, #8	; 0x8

      if (currentpin == pos)
    1348:	2a00      	cmp	r2, #0
    134a:	f040 80af 	bne.w	14ac <GPIO_Init+0x1a8>

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    134e:	f001 0210 	and.w	r2, r1, #16	; 0x10

      if (currentpin == pos)
    1352:	2a00      	cmp	r2, #0
    1354:	f040 80bb 	bne.w	14ce <GPIO_Init+0x1ca>

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    1358:	f001 0220 	and.w	r2, r1, #32	; 0x20

      if (currentpin == pos)
    135c:	2a00      	cmp	r2, #0
    135e:	f040 80c7 	bne.w	14f0 <GPIO_Init+0x1ec>

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    1362:	f001 0240 	and.w	r2, r1, #64	; 0x40

      if (currentpin == pos)
    1366:	2a00      	cmp	r2, #0
    1368:	f040 80d3 	bne.w	1512 <GPIO_Init+0x20e>
    136c:	f001 0280 	and.w	r2, r1, #128	; 0x80
    1370:	2a00      	cmp	r2, #0
    1372:	f040 8115 	bne.w	15a0 <GPIO_Init+0x29c>
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
        }
      }
    }
    GPIOx->CRL = tmpreg;
    1376:	6023      	str	r3, [r4, #0]
  }

/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
    1378:	29ff      	cmp	r1, #255
    137a:	d920      	bls.n	13be <GPIO_Init+0xba>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    137c:	f401 7280 	and.w	r2, r1, #256	; 0x100

/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    1380:	6863      	ldr	r3, [r4, #4]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
    1382:	2a00      	cmp	r2, #0
    1384:	d128      	bne.n	13d8 <GPIO_Init+0xd4>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    1386:	f401 7200 	and.w	r2, r1, #512	; 0x200
      if (currentpin == pos)
    138a:	2a00      	cmp	r2, #0
    138c:	d133      	bne.n	13f6 <GPIO_Init+0xf2>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    138e:	f401 6280 	and.w	r2, r1, #1024	; 0x400
      if (currentpin == pos)
    1392:	2a00      	cmp	r2, #0
    1394:	d13e      	bne.n	1414 <GPIO_Init+0x110>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    1396:	f401 6200 	and.w	r2, r1, #2048	; 0x800
      if (currentpin == pos)
    139a:	2a00      	cmp	r2, #0
    139c:	d149      	bne.n	1432 <GPIO_Init+0x12e>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    139e:	f401 5280 	and.w	r2, r1, #4096	; 0x1000
      if (currentpin == pos)
    13a2:	2a00      	cmp	r2, #0
    13a4:	d154      	bne.n	1450 <GPIO_Init+0x14c>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    13a6:	f401 5200 	and.w	r2, r1, #8192	; 0x2000
      if (currentpin == pos)
    13aa:	2a00      	cmp	r2, #0
    13ac:	d15f      	bne.n	146e <GPIO_Init+0x16a>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    13ae:	f401 4280 	and.w	r2, r1, #16384	; 0x4000
      if (currentpin == pos)
    13b2:	2a00      	cmp	r2, #0
    13b4:	d16a      	bne.n	148c <GPIO_Init+0x188>
    13b6:	f401 4100 	and.w	r1, r1, #32768	; 0x8000
    13ba:	b909      	cbnz	r1, 13c0 <GPIO_Init+0xbc>
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
    13bc:	6063      	str	r3, [r4, #4]
  }
}
    13be:	bd10      	pop	{r4, pc}
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    13c0:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    13c4:	2828      	cmp	r0, #40
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    13c6:	ea43 730e 	orr.w	r3, r3, lr, lsl #28

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
    13ca:	bf08      	it	eq
    13cc:	6161      	streq	r1, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    13ce:	d0f5      	beq.n	13bc <GPIO_Init+0xb8>
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    13d0:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
    13d2:	bf08      	it	eq
    13d4:	6121      	streq	r1, [r4, #16]
    13d6:	e7f1      	b.n	13bc <GPIO_Init+0xb8>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    13d8:	f023 030f 	bic.w	r3, r3, #15	; 0xf

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    13dc:	2828      	cmp	r0, #40
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    13de:	ea4e 0303 	orr.w	r3, lr, r3

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
    13e2:	bf08      	it	eq
    13e4:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    13e6:	d0ce      	beq.n	1386 <GPIO_Init+0x82>
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    13e8:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
    13ea:	bf08      	it	eq
    13ec:	6122      	streq	r2, [r4, #16]
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    13ee:	f401 7200 	and.w	r2, r1, #512	; 0x200
      if (currentpin == pos)
    13f2:	2a00      	cmp	r2, #0
    13f4:	d0cb      	beq.n	138e <GPIO_Init+0x8a>
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    13f6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    13fa:	2828      	cmp	r0, #40
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    13fc:	ea43 130e 	orr.w	r3, r3, lr, lsl #4

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
    1400:	bf08      	it	eq
    1402:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1404:	d0c3      	beq.n	138e <GPIO_Init+0x8a>
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    1406:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
    1408:	bf08      	it	eq
    140a:	6122      	streq	r2, [r4, #16]
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    140c:	f401 6280 	and.w	r2, r1, #1024	; 0x400
      if (currentpin == pos)
    1410:	2a00      	cmp	r2, #0
    1412:	d0c0      	beq.n	1396 <GPIO_Init+0x92>
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    1414:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1418:	2828      	cmp	r0, #40
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    141a:	ea43 230e 	orr.w	r3, r3, lr, lsl #8

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
    141e:	bf08      	it	eq
    1420:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1422:	d0b8      	beq.n	1396 <GPIO_Init+0x92>
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    1424:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
    1426:	bf08      	it	eq
    1428:	6122      	streq	r2, [r4, #16]
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    142a:	f401 6200 	and.w	r2, r1, #2048	; 0x800
      if (currentpin == pos)
    142e:	2a00      	cmp	r2, #0
    1430:	d0b5      	beq.n	139e <GPIO_Init+0x9a>
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    1432:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1436:	2828      	cmp	r0, #40
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    1438:	ea43 330e 	orr.w	r3, r3, lr, lsl #12

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
    143c:	bf08      	it	eq
    143e:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1440:	d0ad      	beq.n	139e <GPIO_Init+0x9a>
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    1442:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
    1444:	bf08      	it	eq
    1446:	6122      	streq	r2, [r4, #16]
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    1448:	f401 5280 	and.w	r2, r1, #4096	; 0x1000
      if (currentpin == pos)
    144c:	2a00      	cmp	r2, #0
    144e:	d0aa      	beq.n	13a6 <GPIO_Init+0xa2>
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    1450:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1454:	2828      	cmp	r0, #40
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    1456:	ea43 430e 	orr.w	r3, r3, lr, lsl #16

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
    145a:	bf08      	it	eq
    145c:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    145e:	d0a2      	beq.n	13a6 <GPIO_Init+0xa2>
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    1460:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
    1462:	bf08      	it	eq
    1464:	6122      	streq	r2, [r4, #16]
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    1466:	f401 5200 	and.w	r2, r1, #8192	; 0x2000
      if (currentpin == pos)
    146a:	2a00      	cmp	r2, #0
    146c:	d09f      	beq.n	13ae <GPIO_Init+0xaa>
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    146e:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1472:	2828      	cmp	r0, #40
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    1474:	ea43 530e 	orr.w	r3, r3, lr, lsl #20

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
    1478:	bf08      	it	eq
    147a:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    147c:	d097      	beq.n	13ae <GPIO_Init+0xaa>
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    147e:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
    1480:	bf08      	it	eq
    1482:	6122      	streq	r2, [r4, #16]
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    1484:	f401 4280 	and.w	r2, r1, #16384	; 0x4000
      if (currentpin == pos)
    1488:	2a00      	cmp	r2, #0
    148a:	d094      	beq.n	13b6 <GPIO_Init+0xb2>
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    148c:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1490:	2828      	cmp	r0, #40
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    1492:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
    1496:	bf08      	it	eq
    1498:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    149a:	d08c      	beq.n	13b6 <GPIO_Init+0xb2>
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    149c:	2848      	cmp	r0, #72
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
    149e:	f401 4100 	and.w	r1, r1, #32768	; 0x8000
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
    14a2:	bf08      	it	eq
    14a4:	6122      	streq	r2, [r4, #16]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
    14a6:	2900      	cmp	r1, #0
    14a8:	d088      	beq.n	13bc <GPIO_Init+0xb8>
    14aa:	e789      	b.n	13c0 <GPIO_Init+0xbc>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    14ac:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    14b0:	2828      	cmp	r0, #40
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    14b2:	ea43 330e 	orr.w	r3, r3, lr, lsl #12

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
    14b6:	bf08      	it	eq
    14b8:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    14ba:	f43f af48 	beq.w	134e <GPIO_Init+0x4a>
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    14be:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
    14c0:	bf08      	it	eq
    14c2:	6122      	streq	r2, [r4, #16]

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    14c4:	f001 0210 	and.w	r2, r1, #16	; 0x10

      if (currentpin == pos)
    14c8:	2a00      	cmp	r2, #0
    14ca:	f43f af45 	beq.w	1358 <GPIO_Init+0x54>
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    14ce:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    14d2:	2828      	cmp	r0, #40
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    14d4:	ea43 430e 	orr.w	r3, r3, lr, lsl #16

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
    14d8:	bf08      	it	eq
    14da:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    14dc:	f43f af3c 	beq.w	1358 <GPIO_Init+0x54>
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    14e0:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
    14e2:	bf08      	it	eq
    14e4:	6122      	streq	r2, [r4, #16]

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    14e6:	f001 0220 	and.w	r2, r1, #32	; 0x20

      if (currentpin == pos)
    14ea:	2a00      	cmp	r2, #0
    14ec:	f43f af39 	beq.w	1362 <GPIO_Init+0x5e>
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    14f0:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    14f4:	2828      	cmp	r0, #40
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    14f6:	ea43 530e 	orr.w	r3, r3, lr, lsl #20

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
    14fa:	bf08      	it	eq
    14fc:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    14fe:	f43f af30 	beq.w	1362 <GPIO_Init+0x5e>
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    1502:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
    1504:	bf08      	it	eq
    1506:	6122      	streq	r2, [r4, #16]

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    1508:	f001 0240 	and.w	r2, r1, #64	; 0x40

      if (currentpin == pos)
    150c:	2a00      	cmp	r2, #0
    150e:	f43f af2d 	beq.w	136c <GPIO_Init+0x68>
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    1512:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1516:	2828      	cmp	r0, #40
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    1518:	ea43 630e 	orr.w	r3, r3, lr, lsl #24

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
    151c:	bf08      	it	eq
    151e:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1520:	f43f af24 	beq.w	136c <GPIO_Init+0x68>
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    1524:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
    1526:	bf08      	it	eq
    1528:	6122      	streq	r2, [r4, #16]
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

      if (currentpin == pos)
    152a:	f001 0280 	and.w	r2, r1, #128	; 0x80
    152e:	2a00      	cmp	r2, #0
    1530:	f43f af21 	beq.w	1376 <GPIO_Init+0x72>
    1534:	e034      	b.n	15a0 <GPIO_Init+0x29c>
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    1536:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    153a:	2828      	cmp	r0, #40
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    153c:	ea43 130e 	orr.w	r3, r3, lr, lsl #4

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
    1540:	bf08      	it	eq
    1542:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1544:	f43f aef9 	beq.w	133a <GPIO_Init+0x36>
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    1548:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
    154a:	bf08      	it	eq
    154c:	6122      	streq	r2, [r4, #16]

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    154e:	f001 0204 	and.w	r2, r1, #4	; 0x4

      if (currentpin == pos)
    1552:	2a00      	cmp	r2, #0
    1554:	f43f aef6 	beq.w	1344 <GPIO_Init+0x40>
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    1558:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    155c:	2828      	cmp	r0, #40
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    155e:	ea43 230e 	orr.w	r3, r3, lr, lsl #8

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
    1562:	bf08      	it	eq
    1564:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1566:	f43f aeed 	beq.w	1344 <GPIO_Init+0x40>
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    156a:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
    156c:	bf08      	it	eq
    156e:	6122      	streq	r2, [r4, #16]

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    1570:	f001 0208 	and.w	r2, r1, #8	; 0x8

      if (currentpin == pos)
    1574:	2a00      	cmp	r2, #0
    1576:	f43f aeea 	beq.w	134e <GPIO_Init+0x4a>
    157a:	e797      	b.n	14ac <GPIO_Init+0x1a8>
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    157c:	f023 030f 	bic.w	r3, r3, #15	; 0xf

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    1580:	2828      	cmp	r0, #40
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    1582:	ea4e 0303 	orr.w	r3, lr, r3

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
    1586:	bf08      	it	eq
    1588:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    158a:	f43f aed1 	beq.w	1330 <GPIO_Init+0x2c>
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    158e:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
    1590:	bf08      	it	eq
    1592:	6122      	streq	r2, [r4, #16]

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    1594:	f001 0202 	and.w	r2, r1, #2	; 0x2

      if (currentpin == pos)
    1598:	2a00      	cmp	r2, #0
    159a:	f43f aece 	beq.w	133a <GPIO_Init+0x36>
    159e:	e7ca      	b.n	1536 <GPIO_Init+0x232>
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
    15a0:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    15a4:	2828      	cmp	r0, #40
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
    15a6:	ea43 730e 	orr.w	r3, r3, lr, lsl #28

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
    15aa:	bf08      	it	eq
    15ac:	6162      	streq	r2, [r4, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    15ae:	f43f aee2 	beq.w	1376 <GPIO_Init+0x72>
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    15b2:	2848      	cmp	r0, #72
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
    15b4:	bf08      	it	eq
    15b6:	6122      	streq	r2, [r4, #16]
    15b8:	e6dd      	b.n	1376 <GPIO_Init+0x72>
    15ba:	46c0      	nop			(mov r8, r8)

000015bc <GPIO_StructInit>:
* Return         : None
*******************************************************************************/
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
    15bc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    15c0:	8003      	strh	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
    15c2:	2204      	movs	r2, #4
*******************************************************************************/
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
    15c4:	2302      	movs	r3, #2
    15c6:	6043      	str	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
    15c8:	6082      	str	r2, [r0, #8]
}
    15ca:	4770      	bx	lr

000015cc <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
    15cc:	6883      	ldr	r3, [r0, #8]
    15ce:	4219      	tst	r1, r3
  else
  {
    bitstatus = (u8)Bit_RESET;
  }
  return bitstatus;
}
    15d0:	bf0c      	ite	eq
    15d2:	2000      	moveq	r0, #0
    15d4:	2001      	movne	r0, #1
    15d6:	4770      	bx	lr

000015d8 <GPIO_ReadInputData>:
u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((u16)GPIOx->IDR);
    15d8:	6880      	ldr	r0, [r0, #8]
}
    15da:	b280      	uxth	r0, r0
    15dc:	4770      	bx	lr
    15de:	46c0      	nop			(mov r8, r8)

000015e0 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
    15e0:	68c3      	ldr	r3, [r0, #12]
    15e2:	4219      	tst	r1, r3
  else
  {
    bitstatus = (u8)Bit_RESET;
  }
  return bitstatus;
}
    15e4:	bf0c      	ite	eq
    15e6:	2000      	moveq	r0, #0
    15e8:	2001      	movne	r0, #1
    15ea:	4770      	bx	lr

000015ec <GPIO_ReadOutputData>:
u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    
  return ((u16)GPIOx->ODR);
    15ec:	68c0      	ldr	r0, [r0, #12]
}
    15ee:	b280      	uxth	r0, r0
    15f0:	4770      	bx	lr
    15f2:	46c0      	nop			(mov r8, r8)

000015f4 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
    15f4:	6101      	str	r1, [r0, #16]
}
    15f6:	4770      	bx	lr

000015f8 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
    15f8:	6141      	str	r1, [r0, #20]
}
    15fa:	4770      	bx	lr

000015fc <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
    15fc:	b10a      	cbz	r2, 1602 <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
    15fe:	6101      	str	r1, [r0, #16]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
  }
}
    1600:	4770      	bx	lr
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
    1602:	6141      	str	r1, [r0, #20]
    1604:	e7fc      	b.n	1600 <GPIO_WriteBit+0x4>
    1606:	46c0      	nop			(mov r8, r8)

00001608 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
    1608:	60c1      	str	r1, [r0, #12]
}
    160a:	4770      	bx	lr

0000160c <GPIO_PinLockConfig>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
    160c:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
    1610:	6183      	str	r3, [r0, #24]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
    1612:	6181      	str	r1, [r0, #24]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
    1614:	6183      	str	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
    1616:	6982      	ldr	r2, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
    1618:	6983      	ldr	r3, [r0, #24]
}
    161a:	4770      	bx	lr

0000161c <GPIO_EventOutputConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
    161c:	f240 0200 	movw	r2, #0	; 0x0
    1620:	f2c4 0201 	movt	r2, #16385	; 0x4001
*                    This parameter can be GPIO_PinSourcex where x can be (0..15).
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
{
    1624:	b410      	push	{r4}
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
    1626:	f64f 7380 	movw	r3, #65408	; 0xff80

  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
    162a:	6814      	ldr	r4, [r2, #0]
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
    162c:	f2c0 0300 	movt	r3, #0	; 0x0
    1630:	ea04 0303 	and.w	r3, r4, r3
  tmpreg |= (u32)GPIO_PortSource << 0x04;
    1634:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
  tmpreg |= GPIO_PinSource;
    1638:	4319      	orrs	r1, r3

  AFIO->EVCR = tmpreg;
    163a:	6011      	str	r1, [r2, #0]
}
    163c:	bc10      	pop	{r4}
    163e:	4770      	bx	lr

00001640 <GPIO_EventOutputCmd>:
void GPIO_EventOutputCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
    1640:	f240 031c 	movw	r3, #28	; 0x1c
    1644:	f2c4 2320 	movt	r3, #16928	; 0x4220
    1648:	6018      	str	r0, [r3, #0]
}
    164a:	4770      	bx	lr

0000164c <GPIO_PinRemapConfig>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
{
    164c:	b530      	push	{r4, r5, lr}
  tmpreg = AFIO->MAPR;

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
    164e:	f400 1340 	and.w	r3, r0, #3145728	; 0x300000
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
{
    1652:	460d      	mov	r5, r1

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  tmpreg = AFIO->MAPR;
    1654:	f240 0100 	movw	r1, #0	; 0x0
    1658:	f2c4 0101 	movt	r1, #16385	; 0x4001

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
    165c:	ea4f 4e00 	mov.w	lr, r0, lsl #16

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
    1660:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  tmpreg = AFIO->MAPR;
    1664:	684c      	ldr	r4, [r1, #4]

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
    1666:	ea4f 4e1e 	mov.w	lr, lr, lsr #16

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
    166a:	d020      	beq.n	16ae <GPIO_PinRemapConfig+0x62>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
    166c:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
    1670:	d014      	beq.n	169c <GPIO_PinRemapConfig+0x50>
  {
    tmp1 = ((u32)0x03) << tmpmask;
    tmpreg &= ~tmp1;
    1672:	f400 2270 	and.w	r2, r0, #983040	; 0xf0000
    1676:	0c12      	lsrs	r2, r2, #16
    1678:	2303      	movs	r3, #3
    167a:	4093      	lsls	r3, r2
    167c:	43db      	mvns	r3, r3
    167e:	4023      	ands	r3, r4
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
    1680:	f043 6270 	orr.w	r2, r3, #251658240	; 0xf000000
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }

  if (NewState != DISABLE)
    1684:	b125      	cbz	r5, 1690 <GPIO_PinRemapConfig+0x44>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
    1686:	0d43      	lsrs	r3, r0, #21
    1688:	011b      	lsls	r3, r3, #4
    168a:	fa0e f303 	lsl.w	r3, lr, r3
    168e:	431a      	orrs	r2, r3
  }

  AFIO->MAPR = tmpreg;
    1690:	f240 0300 	movw	r3, #0	; 0x0
    1694:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1698:	605a      	str	r2, [r3, #4]
}
    169a:	bd30      	pop	{r4, r5, pc}
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
    169c:	0d43      	lsrs	r3, r0, #21
    169e:	011b      	lsls	r3, r3, #4
    16a0:	fa0e f303 	lsl.w	r3, lr, r3
    16a4:	43db      	mvns	r3, r3
    16a6:	4023      	ands	r3, r4
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
    16a8:	f043 6270 	orr.w	r2, r3, #251658240	; 0xf000000
    16ac:	e7ea      	b.n	1684 <GPIO_PinRemapConfig+0x38>
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
    16ae:	684b      	ldr	r3, [r1, #4]
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    16b0:	f024 6270 	bic.w	r2, r4, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
    16b4:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    16b8:	604b      	str	r3, [r1, #4]
    16ba:	e7e3      	b.n	1684 <GPIO_PinRemapConfig+0x38>

000016bc <GPIO_EXTILineConfig>:
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));

  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
    16bc:	f240 0300 	movw	r3, #0	; 0x0
    16c0:	f2c4 0301 	movt	r3, #16385	; 0x4001
*                   This parameter can be GPIO_PinSourcex where x can be (0..15).
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
{
    16c4:	b410      	push	{r4}

  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
    16c6:	f001 0403 	and.w	r4, r1, #3	; 0x3

  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
    16ca:	f001 01fc 	and.w	r1, r1, #252	; 0xfc
    16ce:	18c9      	adds	r1, r1, r3

  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
    16d0:	00a4      	lsls	r4, r4, #2

  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
    16d2:	230f      	movs	r3, #15
    16d4:	40a3      	lsls	r3, r4
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
    16d6:	40a0      	lsls	r0, r4
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));

  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
    16d8:	688a      	ldr	r2, [r1, #8]
    16da:	43db      	mvns	r3, r3
    16dc:	4013      	ands	r3, r2
    16de:	608b      	str	r3, [r1, #8]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
    16e0:	688a      	ldr	r2, [r1, #8]
    16e2:	4310      	orrs	r0, r2
    16e4:	6088      	str	r0, [r1, #8]
}
    16e6:	bc10      	pop	{r4}
    16e8:	4770      	bx	lr
    16ea:	46c0      	nop			(mov r8, r8)

000016ec <GPIO_AFIODeInit>:
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_AFIODeInit(void)
{
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
    16ec:	2001      	movs	r0, #1
    16ee:	4601      	mov	r1, r0
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_AFIODeInit(void)
{
    16f0:	b510      	push	{r4, lr}
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
    16f2:	f7ff fceb 	bl	10cc <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
    16f6:	2001      	movs	r0, #1
    16f8:	2100      	movs	r1, #0
    16fa:	f7ff fce7 	bl	10cc <RCC_APB2PeriphResetCmd>
}
    16fe:	bd10      	pop	{r4, pc}

00001700 <GPIO_DeInit>:
* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
    1700:	b500      	push	{lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  switch (*(u32*)&GPIOx)
    1702:	f241 4300 	movw	r3, #5120	; 0x1400
    1706:	f2c4 0301 	movt	r3, #16385	; 0x4001
* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
    170a:	b083      	sub	sp, #12
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  switch (*(u32*)&GPIOx)
    170c:	4298      	cmp	r0, r3
* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
    170e:	9001      	str	r0, [sp, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  switch (*(u32*)&GPIOx)
    1710:	d05d      	beq.n	17ce <GPIO_DeInit+0xce>
    1712:	d91b      	bls.n	174c <GPIO_DeInit+0x4c>
    1714:	f641 4300 	movw	r3, #7168	; 0x1c00
    1718:	f2c4 0301 	movt	r3, #16385	; 0x4001
    171c:	4298      	cmp	r0, r3
    171e:	d044      	beq.n	17aa <GPIO_DeInit+0xaa>
    1720:	f242 0300 	movw	r3, #8192	; 0x2000
    1724:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1728:	4298      	cmp	r0, r3
    172a:	d033      	beq.n	1794 <GPIO_DeInit+0x94>
    172c:	f641 0300 	movw	r3, #6144	; 0x1800
    1730:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1734:	4298      	cmp	r0, r3
    1736:	d107      	bne.n	1748 <GPIO_DeInit+0x48>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
      break;
      
    case GPIOE_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
    1738:	2040      	movs	r0, #64
    173a:	2101      	movs	r1, #1
    173c:	f7ff fcc6 	bl	10cc <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
    1740:	2040      	movs	r0, #64
    1742:	2100      	movs	r1, #0
    1744:	f7ff fcc2 	bl	10cc <RCC_APB2PeriphResetCmd>
      break;                       

    default:
      break;
  }
}
    1748:	b003      	add	sp, #12
    174a:	bd00      	pop	{pc}
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  switch (*(u32*)&GPIOx)
    174c:	f640 4300 	movw	r3, #3072	; 0xc00
    1750:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1754:	4298      	cmp	r0, r3
    1756:	d031      	beq.n	17bc <GPIO_DeInit+0xbc>
    1758:	f241 0300 	movw	r3, #4096	; 0x1000
    175c:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1760:	4298      	cmp	r0, r3
    1762:	d00e      	beq.n	1782 <GPIO_DeInit+0x82>
    1764:	f640 0300 	movw	r3, #2048	; 0x800
    1768:	f2c4 0301 	movt	r3, #16385	; 0x4001
    176c:	4298      	cmp	r0, r3
    176e:	d1eb      	bne.n	1748 <GPIO_DeInit+0x48>
  {
    case GPIOA_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
    1770:	2004      	movs	r0, #4
    1772:	2101      	movs	r1, #1
    1774:	f7ff fcaa 	bl	10cc <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
    1778:	2004      	movs	r0, #4
    177a:	2100      	movs	r1, #0
    177c:	f7ff fca6 	bl	10cc <RCC_APB2PeriphResetCmd>
    1780:	e7e2      	b.n	1748 <GPIO_DeInit+0x48>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
      break;

    case GPIOC_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
    1782:	2010      	movs	r0, #16
    1784:	2101      	movs	r1, #1
    1786:	f7ff fca1 	bl	10cc <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
    178a:	2010      	movs	r0, #16
    178c:	2100      	movs	r1, #0
    178e:	f7ff fc9d 	bl	10cc <RCC_APB2PeriphResetCmd>
    1792:	e7d9      	b.n	1748 <GPIO_DeInit+0x48>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
      break;

    case GPIOG_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
    1794:	2101      	movs	r1, #1
    1796:	f44f 7080 	mov.w	r0, #256	; 0x100
    179a:	f7ff fc97 	bl	10cc <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    179e:	f44f 7080 	mov.w	r0, #256	; 0x100
    17a2:	2100      	movs	r1, #0
    17a4:	f7ff fc92 	bl	10cc <RCC_APB2PeriphResetCmd>
    17a8:	e7ce      	b.n	1748 <GPIO_DeInit+0x48>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
      break; 

    case GPIOF_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
    17aa:	2080      	movs	r0, #128
    17ac:	2101      	movs	r1, #1
    17ae:	f7ff fc8d 	bl	10cc <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
    17b2:	2080      	movs	r0, #128
    17b4:	2100      	movs	r1, #0
    17b6:	f7ff fc89 	bl	10cc <RCC_APB2PeriphResetCmd>
    17ba:	e7c5      	b.n	1748 <GPIO_DeInit+0x48>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
      break;

    case GPIOB_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
    17bc:	2008      	movs	r0, #8
    17be:	2101      	movs	r1, #1
    17c0:	f7ff fc84 	bl	10cc <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
    17c4:	2008      	movs	r0, #8
    17c6:	2100      	movs	r1, #0
    17c8:	f7ff fc80 	bl	10cc <RCC_APB2PeriphResetCmd>
    17cc:	e7bc      	b.n	1748 <GPIO_DeInit+0x48>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
      break;

    case GPIOD_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
    17ce:	2020      	movs	r0, #32
    17d0:	2101      	movs	r1, #1
    17d2:	f7ff fc7b 	bl	10cc <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
    17d6:	2020      	movs	r0, #32
    17d8:	2100      	movs	r1, #0
    17da:	f7ff fc77 	bl	10cc <RCC_APB2PeriphResetCmd>
    17de:	e7b3      	b.n	1748 <GPIO_DeInit+0x48>

000017e0 <CAN_Init>:
  assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
  assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
  assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));

  /* Request initialisation */
  CAN->MCR = CAN_MCR_INRQ;
    17e0:	f246 4100 	movw	r1, #25600	; 0x6400
    17e4:	f2c4 0100 	movt	r1, #16384	; 0x4000
    17e8:	2201      	movs	r2, #1
    17ea:	600a      	str	r2, [r1, #0]

  /* ...and check acknowledged */
  if ((CAN->MSR & CAN_MSR_INAK) == 0)
    17ec:	684b      	ldr	r3, [r1, #4]
* Output         : None.
* Return         : Constant indicates initialization succeed which will be 
*                  CANINITFAILED or CANINITOK.
*******************************************************************************/
u8 CAN_Init(CAN_InitTypeDef* CAN_InitStruct)
{
    17ee:	b410      	push	{r4}
    17f0:	4604      	mov	r4, r0

  /* Request initialisation */
  CAN->MCR = CAN_MCR_INRQ;

  /* ...and check acknowledged */
  if ((CAN->MSR & CAN_MSR_INAK) == 0)
    17f2:	ea13 0002 	ands.w	r0, r3, r2
    17f6:	f000 8091 	beq.w	191c <CAN_Init+0x13c>
    InitStatus = CANINITFAILED;
  }
  else
  {
    /* Set the time triggered communication mode */
    if (CAN_InitStruct->CAN_TTCM == ENABLE)
    17fa:	6823      	ldr	r3, [r4, #0]
    17fc:	2b01      	cmp	r3, #1
    {
      CAN->MCR |= CAN_MCR_TTCM;
    17fe:	bf0b      	itete	eq
    1800:	680b      	ldreq	r3, [r1, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_TTCM;
    1802:	680b      	ldrne	r3, [r1, #0]
  else
  {
    /* Set the time triggered communication mode */
    if (CAN_InitStruct->CAN_TTCM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_TTCM;
    1804:	f043 0380 	orreq.w	r3, r3, #128	; 0x80
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_TTCM;
    1808:	f023 0380 	bicne.w	r3, r3, #128	; 0x80
  else
  {
    /* Set the time triggered communication mode */
    if (CAN_InitStruct->CAN_TTCM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_TTCM;
    180c:	bf0c      	ite	eq
    180e:	600b      	streq	r3, [r1, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_TTCM;
    1810:	600b      	strne	r3, [r1, #0]
    }

    /* Set the automatic bus-off management */
    if (CAN_InitStruct->CAN_ABOM == ENABLE)
    1812:	6863      	ldr	r3, [r4, #4]
    1814:	2b01      	cmp	r3, #1
    {
      CAN->MCR |= CAN_MCR_ABOM;
    1816:	bf0b      	itete	eq
    1818:	f246 4200 	movweq	r2, #25600	; 0x6400
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_ABOM;
    181c:	f246 4200 	movwne	r2, #25600	; 0x6400
    }

    /* Set the automatic bus-off management */
    if (CAN_InitStruct->CAN_ABOM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_ABOM;
    1820:	f2c4 0200 	movteq	r2, #16384	; 0x4000
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_ABOM;
    1824:	f2c4 0200 	movtne	r2, #16384	; 0x4000
    }

    /* Set the automatic bus-off management */
    if (CAN_InitStruct->CAN_ABOM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_ABOM;
    1828:	bf0b      	itete	eq
    182a:	6813      	ldreq	r3, [r2, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_ABOM;
    182c:	6813      	ldrne	r3, [r2, #0]
    }

    /* Set the automatic bus-off management */
    if (CAN_InitStruct->CAN_ABOM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_ABOM;
    182e:	f043 0340 	orreq.w	r3, r3, #64	; 0x40
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_ABOM;
    1832:	f023 0340 	bicne.w	r3, r3, #64	; 0x40
    }

    /* Set the automatic bus-off management */
    if (CAN_InitStruct->CAN_ABOM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_ABOM;
    1836:	bf0c      	ite	eq
    1838:	6013      	streq	r3, [r2, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_ABOM;
    183a:	6013      	strne	r3, [r2, #0]
    }

    /* Set the automatic wake-up mode */
    if (CAN_InitStruct->CAN_AWUM == ENABLE)
    183c:	68a3      	ldr	r3, [r4, #8]
    183e:	2b01      	cmp	r3, #1
    {
      CAN->MCR |= CAN_MCR_AWUM;
    1840:	bf0b      	itete	eq
    1842:	f246 4200 	movweq	r2, #25600	; 0x6400
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_AWUM;
    1846:	f246 4200 	movwne	r2, #25600	; 0x6400
    }

    /* Set the automatic wake-up mode */
    if (CAN_InitStruct->CAN_AWUM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_AWUM;
    184a:	f2c4 0200 	movteq	r2, #16384	; 0x4000
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_AWUM;
    184e:	f2c4 0200 	movtne	r2, #16384	; 0x4000
    }

    /* Set the automatic wake-up mode */
    if (CAN_InitStruct->CAN_AWUM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_AWUM;
    1852:	bf0b      	itete	eq
    1854:	6813      	ldreq	r3, [r2, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_AWUM;
    1856:	6813      	ldrne	r3, [r2, #0]
    }

    /* Set the automatic wake-up mode */
    if (CAN_InitStruct->CAN_AWUM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_AWUM;
    1858:	f043 0320 	orreq.w	r3, r3, #32	; 0x20
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_AWUM;
    185c:	f023 0320 	bicne.w	r3, r3, #32	; 0x20
    }

    /* Set the automatic wake-up mode */
    if (CAN_InitStruct->CAN_AWUM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_AWUM;
    1860:	bf0c      	ite	eq
    1862:	6013      	streq	r3, [r2, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_AWUM;
    1864:	6013      	strne	r3, [r2, #0]
    }

    /* Set the no automatic retransmission */
    if (CAN_InitStruct->CAN_NART == ENABLE)
    1866:	68e3      	ldr	r3, [r4, #12]
    1868:	2b01      	cmp	r3, #1
    {
      CAN->MCR |= CAN_MCR_NART;
    186a:	bf0b      	itete	eq
    186c:	f246 4200 	movweq	r2, #25600	; 0x6400
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_NART;
    1870:	f246 4200 	movwne	r2, #25600	; 0x6400
    }

    /* Set the no automatic retransmission */
    if (CAN_InitStruct->CAN_NART == ENABLE)
    {
      CAN->MCR |= CAN_MCR_NART;
    1874:	f2c4 0200 	movteq	r2, #16384	; 0x4000
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_NART;
    1878:	f2c4 0200 	movtne	r2, #16384	; 0x4000
    }

    /* Set the no automatic retransmission */
    if (CAN_InitStruct->CAN_NART == ENABLE)
    {
      CAN->MCR |= CAN_MCR_NART;
    187c:	bf0b      	itete	eq
    187e:	6813      	ldreq	r3, [r2, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_NART;
    1880:	6813      	ldrne	r3, [r2, #0]
    }

    /* Set the no automatic retransmission */
    if (CAN_InitStruct->CAN_NART == ENABLE)
    {
      CAN->MCR |= CAN_MCR_NART;
    1882:	f043 0310 	orreq.w	r3, r3, #16	; 0x10
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_NART;
    1886:	f023 0310 	bicne.w	r3, r3, #16	; 0x10
    }

    /* Set the no automatic retransmission */
    if (CAN_InitStruct->CAN_NART == ENABLE)
    {
      CAN->MCR |= CAN_MCR_NART;
    188a:	bf0c      	ite	eq
    188c:	6013      	streq	r3, [r2, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_NART;
    188e:	6013      	strne	r3, [r2, #0]
    }

    /* Set the receive FIFO locked mode */
    if (CAN_InitStruct->CAN_RFLM == ENABLE)
    1890:	6923      	ldr	r3, [r4, #16]
    1892:	2b01      	cmp	r3, #1
    {
      CAN->MCR |= CAN_MCR_RFLM;
    1894:	bf0b      	itete	eq
    1896:	f246 4200 	movweq	r2, #25600	; 0x6400
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_RFLM;
    189a:	f246 4200 	movwne	r2, #25600	; 0x6400
    }

    /* Set the receive FIFO locked mode */
    if (CAN_InitStruct->CAN_RFLM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_RFLM;
    189e:	f2c4 0200 	movteq	r2, #16384	; 0x4000
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_RFLM;
    18a2:	f2c4 0200 	movtne	r2, #16384	; 0x4000
    }

    /* Set the receive FIFO locked mode */
    if (CAN_InitStruct->CAN_RFLM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_RFLM;
    18a6:	bf0b      	itete	eq
    18a8:	6813      	ldreq	r3, [r2, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_RFLM;
    18aa:	6813      	ldrne	r3, [r2, #0]
    }

    /* Set the receive FIFO locked mode */
    if (CAN_InitStruct->CAN_RFLM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_RFLM;
    18ac:	f043 0308 	orreq.w	r3, r3, #8	; 0x8
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_RFLM;
    18b0:	f023 0308 	bicne.w	r3, r3, #8	; 0x8
    }

    /* Set the receive FIFO locked mode */
    if (CAN_InitStruct->CAN_RFLM == ENABLE)
    {
      CAN->MCR |= CAN_MCR_RFLM;
    18b4:	bf0c      	ite	eq
    18b6:	6013      	streq	r3, [r2, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_RFLM;
    18b8:	6013      	strne	r3, [r2, #0]
    }

    /* Set the transmit FIFO priority */
    if (CAN_InitStruct->CAN_TXFP == ENABLE)
    18ba:	6963      	ldr	r3, [r4, #20]
    18bc:	2b01      	cmp	r3, #1
    {
      CAN->MCR |= CAN_MCR_TXFP;
    18be:	bf0b      	itete	eq
    18c0:	f246 4200 	movweq	r2, #25600	; 0x6400
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_TXFP;
    18c4:	f246 4200 	movwne	r2, #25600	; 0x6400
    }

    /* Set the transmit FIFO priority */
    if (CAN_InitStruct->CAN_TXFP == ENABLE)
    {
      CAN->MCR |= CAN_MCR_TXFP;
    18c8:	f2c4 0200 	movteq	r2, #16384	; 0x4000
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_TXFP;
    18cc:	f2c4 0200 	movtne	r2, #16384	; 0x4000
    }

    /* Set the transmit FIFO priority */
    if (CAN_InitStruct->CAN_TXFP == ENABLE)
    {
      CAN->MCR |= CAN_MCR_TXFP;
    18d0:	bf0b      	itete	eq
    18d2:	6813      	ldreq	r3, [r2, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_TXFP;
    18d4:	6813      	ldrne	r3, [r2, #0]
    }

    /* Set the transmit FIFO priority */
    if (CAN_InitStruct->CAN_TXFP == ENABLE)
    {
      CAN->MCR |= CAN_MCR_TXFP;
    18d6:	f043 0304 	orreq.w	r3, r3, #4	; 0x4
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_TXFP;
    18da:	f023 0304 	bicne.w	r3, r3, #4	; 0x4
    }

    /* Set the transmit FIFO priority */
    if (CAN_InitStruct->CAN_TXFP == ENABLE)
    {
      CAN->MCR |= CAN_MCR_TXFP;
    18de:	bf0c      	ite	eq
    18e0:	6013      	streq	r3, [r2, #0]
    }
    else
    {
      CAN->MCR &= ~CAN_MCR_TXFP;
    18e2:	6013      	strne	r3, [r2, #0]
    }

    /* Set the bit timing register */
    CAN->BTR = (u32)((u32)CAN_InitStruct->CAN_Mode << 30) | ((u32)CAN_InitStruct->CAN_SJW << 24) |
    18e4:	7e22      	ldrb	r2, [r4, #24]
    18e6:	7e61      	ldrb	r1, [r4, #25]
    18e8:	7ea3      	ldrb	r3, [r4, #26]
    18ea:	0792      	lsls	r2, r2, #30
    18ec:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
    18f0:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    18f4:	7ee1      	ldrb	r1, [r4, #27]
    18f6:	8ba3      	ldrh	r3, [r4, #28]
    18f8:	ea42 5201 	orr.w	r2, r2, r1, lsl #20
    18fc:	3b01      	subs	r3, #1
    18fe:	f246 4100 	movw	r1, #25600	; 0x6400
    1902:	f2c4 0100 	movt	r1, #16384	; 0x4000
    1906:	431a      	orrs	r2, r3
    1908:	61ca      	str	r2, [r1, #28]
               ((u32)CAN_InitStruct->CAN_Prescaler - 1);

    InitStatus = CANINITOK;

    /* Request leave initialisation */
    CAN->MCR &= ~CAN_MCR_INRQ;
    190a:	680b      	ldr	r3, [r1, #0]
    190c:	f023 0301 	bic.w	r3, r3, #1	; 0x1
    1910:	600b      	str	r3, [r1, #0]
    for(WaitAck = 0x400; WaitAck > 0x0; WaitAck--)
    {
    }
    
    /* ...and check acknowledged */
    if ((CAN->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
    1912:	684a      	ldr	r2, [r1, #4]
    1914:	f002 0201 	and.w	r2, r2, #1	; 0x1
    1918:	f082 0001 	eor.w	r0, r2, #1	; 0x1
    }
  }

  /* At this step, return the status of initialization */
  return InitStatus;
}
    191c:	bc10      	pop	{r4}
    191e:	4770      	bx	lr

00001920 <CAN_FilterInit>:

  FilterNumber_BitPos = 
  (u16)((u16)0x0001 << ((u16)CAN_FilterInitStruct->CAN_FilterNumber));

  /* Initialisation mode for the filter */
  CAN->FMR |= CAN_FMR_FINIT;
    1920:	f246 4100 	movw	r1, #25600	; 0x6400
    1924:	f2c4 0100 	movt	r1, #16384	; 0x4000
    1928:	f8d1 3200 	ldr.w	r3, [r1, #512]
*                  structure that contains the configuration information.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
{
    192c:	b510      	push	{r4, lr}

  FilterNumber_BitPos = 
  (u16)((u16)0x0001 << ((u16)CAN_FilterInitStruct->CAN_FilterNumber));

  /* Initialisation mode for the filter */
  CAN->FMR |= CAN_FMR_FINIT;
    192e:	f043 0301 	orr.w	r3, r3, #1	; 0x1
  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));

  FilterNumber_BitPos = 
    1932:	f890 e000 	ldrb.w	lr, [r0]
  (u16)((u16)0x0001 << ((u16)CAN_FilterInitStruct->CAN_FilterNumber));

  /* Initialisation mode for the filter */
  CAN->FMR |= CAN_FMR_FINIT;
    1936:	f8c1 3200 	str.w	r3, [r1, #512]

  /* Filter Deactivation */
  CAN->FA1R &= ~(u32)FilterNumber_BitPos;
    193a:	2301      	movs	r3, #1
    193c:	fa03 f30e 	lsl.w	r3, r3, lr
    1940:	f8d1 221c 	ldr.w	r2, [r1, #540]
    1944:	b29c      	uxth	r4, r3
    1946:	ea6f 0c04 	mvn.w	ip, r4
    194a:	ea0c 0202 	and.w	r2, ip, r2
    194e:	f8c1 221c 	str.w	r2, [r1, #540]

  /* Filter Scale */
  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
    1952:	7883      	ldrb	r3, [r0, #2]
    1954:	2b00      	cmp	r3, #0
    1956:	d149      	bne.n	19ec <CAN_FilterInit+0xcc>
  {
    /* 16-bit scale for the filter */
    CAN->FS1R &= ~(u32)FilterNumber_BitPos;
    1958:	f8d1 320c 	ldr.w	r3, [r1, #524]

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    195c:	ea4f 02ce 	mov.w	r2, lr, lsl #3

  /* Filter Scale */
  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
  {
    /* 16-bit scale for the filter */
    CAN->FS1R &= ~(u32)FilterNumber_BitPos;
    1960:	ea0c 0303 	and.w	r3, ip, r3
    1964:	f8c1 320c 	str.w	r3, [r1, #524]

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    1968:	8941      	ldrh	r1, [r0, #10]
    196a:	88c3      	ldrh	r3, [r0, #6]
    196c:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    1970:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    1974:	f502 42c8 	add.w	r2, r2, #25600	; 0x6400
    1978:	f8c2 3240 	str.w	r3, [r2, #576]
    ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
        ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    197c:	8901      	ldrh	r1, [r0, #8]
    197e:	8883      	ldrh	r3, [r0, #4]
    1980:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    1984:	f8c2 3244 	str.w	r3, [r2, #580]
        ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow);

  }

  /* Filter Mode */
  if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
    1988:	7843      	ldrb	r3, [r0, #1]
    198a:	2b00      	cmp	r3, #0
    198c:	d14b      	bne.n	1a26 <CAN_FilterInit+0x106>
  {
    /*Id/Mask mode for the filter*/
    CAN->FM1R &= ~(u32)FilterNumber_BitPos;
    198e:	f246 4200 	movw	r2, #25600	; 0x6400
    1992:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1996:	f8d2 3204 	ldr.w	r3, [r2, #516]
    199a:	ea0c 0303 	and.w	r3, ip, r3
    199e:	f8c2 3204 	str.w	r3, [r2, #516]
    /*Identifier list mode for the filter*/
    CAN->FM1R |= (u32)FilterNumber_BitPos;
  }

  /* Filter FIFO assignment */
  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
    19a2:	8983      	ldrh	r3, [r0, #12]
    19a4:	2b00      	cmp	r3, #0
    19a6:	d14b      	bne.n	1a40 <CAN_FilterInit+0x120>
  {
    /* FIFO 0 assignation for the filter */
    CAN->FFA1R &= ~(u32)FilterNumber_BitPos;
    19a8:	f246 4200 	movw	r2, #25600	; 0x6400
    19ac:	f2c4 0200 	movt	r2, #16384	; 0x4000
    19b0:	f8d2 3214 	ldr.w	r3, [r2, #532]
    19b4:	ea0c 0303 	and.w	r3, ip, r3
    19b8:	f8c2 3214 	str.w	r3, [r2, #532]
    /* FIFO 1 assignation for the filter */
    CAN->FFA1R |= (u32)FilterNumber_BitPos;
  }
  
  /* Filter activation */
  if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
    19bc:	6903      	ldr	r3, [r0, #16]
    19be:	2b01      	cmp	r3, #1
  {
    CAN->FA1R |= FilterNumber_BitPos;
    19c0:	bf01      	itttt	eq
    19c2:	f246 4200 	movweq	r2, #25600	; 0x6400
    19c6:	f2c4 0200 	movteq	r2, #16384	; 0x4000
    19ca:	f8d2 321c 	ldreq.w	r3, [r2, #540]
    19ce:	4323      	orreq	r3, r4
    19d0:	bf08      	it	eq
    19d2:	f8c2 321c 	streq.w	r3, [r2, #540]
  }

  /* Leave the initialisation mode for the filter */
  CAN->FMR &= ~CAN_FMR_FINIT;
    19d6:	f246 4200 	movw	r2, #25600	; 0x6400
    19da:	f2c4 0200 	movt	r2, #16384	; 0x4000
    19de:	f8d2 3200 	ldr.w	r3, [r2, #512]
    19e2:	f023 0301 	bic.w	r3, r3, #1	; 0x1
    19e6:	f8c2 3200 	str.w	r3, [r2, #512]
}
    19ea:	bd10      	pop	{r4, pc}
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
        ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh);
  }
  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
    19ec:	2b01      	cmp	r3, #1
    19ee:	d1cb      	bne.n	1988 <CAN_FilterInit+0x68>
  {
    /* 32-bit scale for the filter */
    CAN->FS1R |= FilterNumber_BitPos;
    19f0:	f8d1 320c 	ldr.w	r3, [r1, #524]

    /* 32-bit identifier or First 32-bit identifier */
    CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    19f4:	ea4f 02ce 	mov.w	r2, lr, lsl #3
        ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh);
  }
  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
  {
    /* 32-bit scale for the filter */
    CAN->FS1R |= FilterNumber_BitPos;
    19f8:	ea44 0303 	orr.w	r3, r4, r3
    19fc:	f8c1 320c 	str.w	r3, [r1, #524]

    /* 32-bit identifier or First 32-bit identifier */
    CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    1a00:	8881      	ldrh	r1, [r0, #4]
    1a02:	88c3      	ldrh	r3, [r0, #6]
    1a04:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    1a08:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    1a0c:	f502 42c8 	add.w	r2, r2, #25600	; 0x6400
    1a10:	f8c2 3240 	str.w	r3, [r2, #576]
    ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
        ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdLow);

    /* 32-bit mask or Second 32-bit identifier */
    CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    1a14:	8901      	ldrh	r1, [r0, #8]
    1a16:	8943      	ldrh	r3, [r0, #10]
    1a18:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    1a1c:	f8c2 3244 	str.w	r3, [r2, #580]
        ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow);

  }

  /* Filter Mode */
  if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
    1a20:	7843      	ldrb	r3, [r0, #1]
    1a22:	2b00      	cmp	r3, #0
    1a24:	d0b3      	beq.n	198e <CAN_FilterInit+0x6e>
    CAN->FM1R &= ~(u32)FilterNumber_BitPos;
  }
  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
  {
    /*Identifier list mode for the filter*/
    CAN->FM1R |= (u32)FilterNumber_BitPos;
    1a26:	f246 4200 	movw	r2, #25600	; 0x6400
    1a2a:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1a2e:	f8d2 3204 	ldr.w	r3, [r2, #516]
    1a32:	ea44 0303 	orr.w	r3, r4, r3
    1a36:	f8c2 3204 	str.w	r3, [r2, #516]
  }

  /* Filter FIFO assignment */
  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
    1a3a:	8983      	ldrh	r3, [r0, #12]
    1a3c:	2b00      	cmp	r3, #0
    1a3e:	d0b3      	beq.n	19a8 <CAN_FilterInit+0x88>
  {
    /* FIFO 0 assignation for the filter */
    CAN->FFA1R &= ~(u32)FilterNumber_BitPos;
  }
  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
    1a40:	2b01      	cmp	r3, #1
  {
    /* FIFO 1 assignation for the filter */
    CAN->FFA1R |= (u32)FilterNumber_BitPos;
    1a42:	bf01      	itttt	eq
    1a44:	f246 4200 	movweq	r2, #25600	; 0x6400
    1a48:	f2c4 0200 	movteq	r2, #16384	; 0x4000
    1a4c:	f8d2 3214 	ldreq.w	r3, [r2, #532]
    1a50:	4323      	orreq	r3, r4
    1a52:	bf08      	it	eq
    1a54:	f8c2 3214 	streq.w	r3, [r2, #532]
    1a58:	e7b0      	b.n	19bc <CAN_FilterInit+0x9c>
    1a5a:	46c0      	nop			(mov r8, r8)

00001a5c <CAN_StructInit>:
void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
{
  /* Reset CAN init structure parameters values */

  /* Initialize the time triggered communication mode */
  CAN_InitStruct->CAN_TTCM = DISABLE;
    1a5c:	2300      	movs	r3, #0
    1a5e:	6003      	str	r3, [r0, #0]

  /* Initialize the automatic bus-off management */
  CAN_InitStruct->CAN_ABOM = DISABLE;
    1a60:	6043      	str	r3, [r0, #4]

  /* Initialize the automatic wake-up mode */
  CAN_InitStruct->CAN_AWUM = DISABLE;
    1a62:	6083      	str	r3, [r0, #8]

  /* Initialize the no automatic retransmission */
  CAN_InitStruct->CAN_NART = DISABLE;
    1a64:	60c3      	str	r3, [r0, #12]

  /* Initialize the receive FIFO locked mode */
  CAN_InitStruct->CAN_RFLM = DISABLE;
    1a66:	6103      	str	r3, [r0, #16]

  /* Initialize the transmit FIFO priority */
  CAN_InitStruct->CAN_TXFP = DISABLE;
    1a68:	6143      	str	r3, [r0, #20]

  /* Initialize the CAN_Mode member */
  CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
    1a6a:	7603      	strb	r3, [r0, #24]

  /* Initialize the CAN_SJW member */
  CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
    1a6c:	7643      	strb	r3, [r0, #25]

  /* Initialize the CAN_BS1 member */
  CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;

  /* Initialize the CAN_BS2 member */
  CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
    1a6e:	3302      	adds	r3, #2

  /* Initialize the CAN_SJW member */
  CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;

  /* Initialize the CAN_BS1 member */
  CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
    1a70:	2203      	movs	r2, #3

  /* Initialize the CAN_BS2 member */
  CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
    1a72:	76c3      	strb	r3, [r0, #27]

  /* Initialize the CAN_Prescaler member */
  CAN_InitStruct->CAN_Prescaler = 1;
    1a74:	f04f 0301 	mov.w	r3, #1	; 0x1

  /* Initialize the CAN_SJW member */
  CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;

  /* Initialize the CAN_BS1 member */
  CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
    1a78:	7682      	strb	r2, [r0, #26]

  /* Initialize the CAN_BS2 member */
  CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;

  /* Initialize the CAN_Prescaler member */
  CAN_InitStruct->CAN_Prescaler = 1;
    1a7a:	8383      	strh	r3, [r0, #28]
}
    1a7c:	4770      	bx	lr
    1a7e:	46c0      	nop			(mov r8, r8)

00001a80 <CAN_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_CAN_ITConfig(CAN_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
    1a80:	b141      	cbz	r1, 1a94 <CAN_ITConfig+0x14>
  {
    /* Enable the selected CAN interrupt */
    CAN->IER |= CAN_IT;
    1a82:	f246 4200 	movw	r2, #25600	; 0x6400
    1a86:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1a8a:	6953      	ldr	r3, [r2, #20]
    1a8c:	ea40 0303 	orr.w	r3, r0, r3
    1a90:	6153      	str	r3, [r2, #20]
  else
  {
    /* Disable the selected CAN interrupt */
    CAN->IER &= ~CAN_IT;
  }
}
    1a92:	4770      	bx	lr
    CAN->IER |= CAN_IT;
  }
  else
  {
    /* Disable the selected CAN interrupt */
    CAN->IER &= ~CAN_IT;
    1a94:	f246 4300 	movw	r3, #25600	; 0x6400
    1a98:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1a9c:	6959      	ldr	r1, [r3, #20]
    1a9e:	43c2      	mvns	r2, r0
    1aa0:	400a      	ands	r2, r1
    1aa2:	615a      	str	r2, [r3, #20]
    1aa4:	e7f5      	b.n	1a92 <CAN_ITConfig+0x12>
    1aa6:	46c0      	nop			(mov r8, r8)

00001aa8 <CAN_Transmit>:
  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
  assert_param(IS_CAN_RTR(TxMessage->RTR));
  assert_param(IS_CAN_DLC(TxMessage->DLC));

  /* Select one empty transmit mailbox */
  if ((CAN->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
    1aa8:	f246 4200 	movw	r2, #25600	; 0x6400
    1aac:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1ab0:	6893      	ldr	r3, [r2, #8]
* Output         : None.
* Return         : The number of the mailbox that is used for transmission
*                  or CAN_NO_MB if there is no empty mailbox.
*******************************************************************************/
u8 CAN_Transmit(CanTxMsg* TxMessage)
{
    1ab2:	b530      	push	{r4, r5, lr}
  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
  assert_param(IS_CAN_RTR(TxMessage->RTR));
  assert_param(IS_CAN_DLC(TxMessage->DLC));

  /* Select one empty transmit mailbox */
  if ((CAN->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
    1ab4:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
* Output         : None.
* Return         : The number of the mailbox that is used for transmission
*                  or CAN_NO_MB if there is no empty mailbox.
*******************************************************************************/
u8 CAN_Transmit(CanTxMsg* TxMessage)
{
    1ab8:	4605      	mov	r5, r0
  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
  assert_param(IS_CAN_RTR(TxMessage->RTR));
  assert_param(IS_CAN_DLC(TxMessage->DLC));

  /* Select one empty transmit mailbox */
  if ((CAN->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
    1aba:	bf18      	it	ne
    1abc:	f04f 0c00 	movne.w	ip, #0	; 0x0
    1ac0:	d10f      	bne.n	1ae2 <CAN_Transmit+0x3a>
  {
    TransmitMailbox = 0;
  }
  else if ((CAN->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
    1ac2:	6893      	ldr	r3, [r2, #8]
    1ac4:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
    1ac8:	bf18      	it	ne
    1aca:	f04f 0c01 	movne.w	ip, #1	; 0x1
    1ace:	d108      	bne.n	1ae2 <CAN_Transmit+0x3a>
  {
    TransmitMailbox = 1;
  }
  else if ((CAN->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
    1ad0:	6893      	ldr	r3, [r2, #8]
    1ad2:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
    1ad6:	bf08      	it	eq
    1ad8:	f04f 0c04 	moveq.w	ip, #4	; 0x4
    1adc:	d04d      	beq.n	1b7a <CAN_Transmit+0xd2>
    1ade:	f04f 0c02 	mov.w	ip, #2	; 0x2
  }

  if (TransmitMailbox != CAN_NO_MB)
  {
    /* Set up the Id */
    CAN->sTxMailBox[TransmitMailbox].TIR &= CAN_TMIDxR_TXRQ;
    1ae2:	ea4f 1e0c 	mov.w	lr, ip, lsl #4
    1ae6:	f10e 4480 	add.w	r4, lr, #1073741824	; 0x40000000
    1aea:	f504 44c8 	add.w	r4, r4, #25600	; 0x6400
    1aee:	f8d4 3180 	ldr.w	r3, [r4, #384]
    1af2:	f003 0301 	and.w	r3, r3, #1	; 0x1
    1af6:	f8c4 3180 	str.w	r3, [r4, #384]
    if (TxMessage->IDE == CAN_ID_STD)
    1afa:	7a28      	ldrb	r0, [r5, #8]
    1afc:	2800      	cmp	r0, #0
    1afe:	d03e      	beq.n	1b7e <CAN_Transmit+0xd6>
      CAN->sTxMailBox[TransmitMailbox].TIR |= (TxMessage->StdId | TxMessage->IDE |
                                               TxMessage->RTR);
    }
    else
    {
      TxMessage->ExtId &= (u32)0x1FFFFFFF;
    1b00:	686b      	ldr	r3, [r5, #4]
      TxMessage->ExtId <<= 3;

      CAN->sTxMailBox[TransmitMailbox].TIR |= (TxMessage->ExtId | TxMessage->IDE | 
    1b02:	7a6a      	ldrb	r2, [r5, #9]
                                               TxMessage->RTR);
    }
    else
    {
      TxMessage->ExtId &= (u32)0x1FFFFFFF;
      TxMessage->ExtId <<= 3;
    1b04:	00db      	lsls	r3, r3, #3
    1b06:	606b      	str	r3, [r5, #4]

      CAN->sTxMailBox[TransmitMailbox].TIR |= (TxMessage->ExtId | TxMessage->IDE | 
    1b08:	f8d4 1180 	ldr.w	r1, [r4, #384]
    1b0c:	ea40 0202 	orr.w	r2, r0, r2
    1b10:	430a      	orrs	r2, r1
    1b12:	431a      	orrs	r2, r3
    1b14:	f8c4 2180 	str.w	r2, [r4, #384]
                                               TxMessage->RTR);
    }
    
    /* Set up the DLC */
    TxMessage->DLC &= (u8)0x0000000F;
    1b18:	7aa9      	ldrb	r1, [r5, #10]
    CAN->sTxMailBox[TransmitMailbox].TDTR &= (u32)0xFFFFFFF0;
    1b1a:	f10e 4080 	add.w	r0, lr, #1073741824	; 0x40000000
      CAN->sTxMailBox[TransmitMailbox].TIR |= (TxMessage->ExtId | TxMessage->IDE | 
                                               TxMessage->RTR);
    }
    
    /* Set up the DLC */
    TxMessage->DLC &= (u8)0x0000000F;
    1b1e:	f001 010f 	and.w	r1, r1, #15	; 0xf
    1b22:	72a9      	strb	r1, [r5, #10]
    CAN->sTxMailBox[TransmitMailbox].TDTR &= (u32)0xFFFFFFF0;
    1b24:	f500 40c8 	add.w	r0, r0, #25600	; 0x6400
    1b28:	f8d0 3184 	ldr.w	r3, [r0, #388]
    1b2c:	f023 030f 	bic.w	r3, r3, #15	; 0xf
    1b30:	f8c0 3184 	str.w	r3, [r0, #388]
    CAN->sTxMailBox[TransmitMailbox].TDTR |= TxMessage->DLC;
    1b34:	f8d0 2184 	ldr.w	r2, [r0, #388]
    1b38:	4311      	orrs	r1, r2
    1b3a:	f8c0 1184 	str.w	r1, [r0, #388]

    /* Set up the data field */
    CAN->sTxMailBox[TransmitMailbox].TDLR = (((u32)TxMessage->Data[3] << 24) | 
    1b3e:	7b6b      	ldrb	r3, [r5, #13]
    1b40:	7bac      	ldrb	r4, [r5, #14]
    1b42:	7aea      	ldrb	r2, [r5, #11]
    1b44:	041b      	lsls	r3, r3, #16
    1b46:	7b29      	ldrb	r1, [r5, #12]
    1b48:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
    1b4c:	4313      	orrs	r3, r2
    1b4e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    1b52:	f8c0 3188 	str.w	r3, [r0, #392]
                                             ((u32)TxMessage->Data[2] << 16) |
                                             ((u32)TxMessage->Data[1] << 8) | 
                                             ((u32)TxMessage->Data[0]));
    CAN->sTxMailBox[TransmitMailbox].TDHR = (((u32)TxMessage->Data[7] << 24) | 
    1b56:	7c6b      	ldrb	r3, [r5, #17]
    1b58:	7ca9      	ldrb	r1, [r5, #18]
    1b5a:	7bea      	ldrb	r2, [r5, #15]
    1b5c:	041b      	lsls	r3, r3, #16
    1b5e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    1b62:	7c29      	ldrb	r1, [r5, #16]
    1b64:	4313      	orrs	r3, r2
    1b66:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    1b6a:	f8c0 318c 	str.w	r3, [r0, #396]
                                             ((u32)TxMessage->Data[6] << 16) |
                                             ((u32)TxMessage->Data[5] << 8) |
                                             ((u32)TxMessage->Data[4]));

    /* Request transmission */
    CAN->sTxMailBox[TransmitMailbox].TIR |= CAN_TMIDxR_TXRQ;
    1b6e:	f8d0 2180 	ldr.w	r2, [r0, #384]
    1b72:	f042 0201 	orr.w	r2, r2, #1	; 0x1
    1b76:	f8c0 2180 	str.w	r2, [r0, #384]
  }

  return TransmitMailbox;
}
    1b7a:	4660      	mov	r0, ip
    1b7c:	bd30      	pop	{r4, r5, pc}
  {
    /* Set up the Id */
    CAN->sTxMailBox[TransmitMailbox].TIR &= CAN_TMIDxR_TXRQ;
    if (TxMessage->IDE == CAN_ID_STD)
    {
      TxMessage->StdId &= (u32)0x000007FF;
    1b7e:	682b      	ldr	r3, [r5, #0]
      TxMessage->StdId = TxMessage->StdId << 21;
      
      CAN->sTxMailBox[TransmitMailbox].TIR |= (TxMessage->StdId | TxMessage->IDE |
    1b80:	7a6a      	ldrb	r2, [r5, #9]
    /* Set up the Id */
    CAN->sTxMailBox[TransmitMailbox].TIR &= CAN_TMIDxR_TXRQ;
    if (TxMessage->IDE == CAN_ID_STD)
    {
      TxMessage->StdId &= (u32)0x000007FF;
      TxMessage->StdId = TxMessage->StdId << 21;
    1b82:	055b      	lsls	r3, r3, #21
    1b84:	602b      	str	r3, [r5, #0]
      
      CAN->sTxMailBox[TransmitMailbox].TIR |= (TxMessage->StdId | TxMessage->IDE |
    1b86:	f8d4 1180 	ldr.w	r1, [r4, #384]
    1b8a:	430a      	orrs	r2, r1
    1b8c:	431a      	orrs	r2, r3
    1b8e:	f8c4 2180 	str.w	r2, [r4, #384]
    1b92:	e7c1      	b.n	1b18 <CAN_Transmit+0x70>

00001b94 <CAN_TransmitStatus>:
  u8 State = 0;

  /* Check the parameters */
  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));

  switch (TransmitMailbox)
    1b94:	2801      	cmp	r0, #1
    1b96:	d030      	beq.n	1bfa <CAN_TransmitStatus+0x66>
    1b98:	d216      	bcs.n	1bc8 <CAN_TransmitStatus+0x34>
  {
    case (0): State |= (u8)((CAN->TSR & CAN_TSR_RQCP0) << 2);
    1b9a:	f246 4000 	movw	r0, #25600	; 0x6400
    1b9e:	f2c4 0000 	movt	r0, #16384	; 0x4000
    1ba2:	6882      	ldr	r2, [r0, #8]
      State |= (u8)((CAN->TSR & CAN_TSR_TXOK0) >> 0);
    1ba4:	6881      	ldr	r1, [r0, #8]
      State |= (u8)((CAN->TSR & CAN_TSR_TME0) >> 26);
    1ba6:	6883      	ldr	r3, [r0, #8]
  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));

  switch (TransmitMailbox)
  {
    case (0): State |= (u8)((CAN->TSR & CAN_TSR_RQCP0) << 2);
      State |= (u8)((CAN->TSR & CAN_TSR_TXOK0) >> 0);
    1ba8:	f002 0201 	and.w	r2, r2, #1	; 0x1
    1bac:	f001 0102 	and.w	r1, r1, #2	; 0x2
    1bb0:	ea41 0182 	orr.w	r1, r1, r2, lsl #2
      State |= (u8)((CAN->TSR & CAN_TSR_TME0) >> 26);
    1bb4:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
    1bb8:	ea41 6093 	orr.w	r0, r1, r3, lsr #26
    default:
      State = CANTXFAILED;
      break;
  }

  switch (State)
    1bbc:	b130      	cbz	r0, 1bcc <CAN_TransmitStatus+0x38>
    1bbe:	2807      	cmp	r0, #7
    1bc0:	bf14      	ite	ne
    1bc2:	2000      	movne	r0, #0
    1bc4:	2001      	moveq	r0, #1
      State = CANTXFAILED;
      break;
  }

  return State;
}
    1bc6:	4770      	bx	lr
  u8 State = 0;

  /* Check the parameters */
  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));

  switch (TransmitMailbox)
    1bc8:	2802      	cmp	r0, #2
    1bca:	d001      	beq.n	1bd0 <CAN_TransmitStatus+0x3c>
    default:
      State = CANTXFAILED;
      break;
  }

  switch (State)
    1bcc:	2002      	movs	r0, #2
    1bce:	e7fa      	b.n	1bc6 <CAN_TransmitStatus+0x32>
      break;
    case (1): State |= (u8)((CAN->TSR & CAN_TSR_RQCP1) >> 6);
      State |= (u8)((CAN->TSR & CAN_TSR_TXOK1) >> 8);
      State |= (u8)((CAN->TSR & CAN_TSR_TME1) >> 27);
      break;
    case (2): State |= (u8)((CAN->TSR & CAN_TSR_RQCP2) >> 14);
    1bd0:	f246 4300 	movw	r3, #25600	; 0x6400
    1bd4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1bd8:	689a      	ldr	r2, [r3, #8]
      State |= (u8)((CAN->TSR & CAN_TSR_TXOK2) >> 16);
    1bda:	6899      	ldr	r1, [r3, #8]
    1bdc:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
      State |= (u8)((CAN->TSR & CAN_TSR_TME2) >> 28);
    1be0:	6898      	ldr	r0, [r3, #8]
    case (1): State |= (u8)((CAN->TSR & CAN_TSR_RQCP1) >> 6);
      State |= (u8)((CAN->TSR & CAN_TSR_TXOK1) >> 8);
      State |= (u8)((CAN->TSR & CAN_TSR_TME1) >> 27);
      break;
    case (2): State |= (u8)((CAN->TSR & CAN_TSR_RQCP2) >> 14);
      State |= (u8)((CAN->TSR & CAN_TSR_TXOK2) >> 16);
    1be2:	f401 3100 	and.w	r1, r1, #131072	; 0x20000
    1be6:	0b92      	lsrs	r2, r2, #14
    1be8:	ea42 4211 	orr.w	r2, r2, r1, lsr #16
      State |= (u8)((CAN->TSR & CAN_TSR_TME2) >> 28);
    1bec:	f000 5080 	and.w	r0, r0, #268435456	; 0x10000000
    1bf0:	ea42 7010 	orr.w	r0, r2, r0, lsr #28
    default:
      State = CANTXFAILED;
      break;
  }

  switch (State)
    1bf4:	2800      	cmp	r0, #0
    1bf6:	d0e9      	beq.n	1bcc <CAN_TransmitStatus+0x38>
    1bf8:	e7e1      	b.n	1bbe <CAN_TransmitStatus+0x2a>
  {
    case (0): State |= (u8)((CAN->TSR & CAN_TSR_RQCP0) << 2);
      State |= (u8)((CAN->TSR & CAN_TSR_TXOK0) >> 0);
      State |= (u8)((CAN->TSR & CAN_TSR_TME0) >> 26);
      break;
    case (1): State |= (u8)((CAN->TSR & CAN_TSR_RQCP1) >> 6);
    1bfa:	f246 4300 	movw	r3, #25600	; 0x6400
    1bfe:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1c02:	689a      	ldr	r2, [r3, #8]
      State |= (u8)((CAN->TSR & CAN_TSR_TXOK1) >> 8);
    1c04:	6899      	ldr	r1, [r3, #8]
    1c06:	f402 7280 	and.w	r2, r2, #256	; 0x100
      State |= (u8)((CAN->TSR & CAN_TSR_TME1) >> 27);
    1c0a:	6898      	ldr	r0, [r3, #8]
    case (0): State |= (u8)((CAN->TSR & CAN_TSR_RQCP0) << 2);
      State |= (u8)((CAN->TSR & CAN_TSR_TXOK0) >> 0);
      State |= (u8)((CAN->TSR & CAN_TSR_TME0) >> 26);
      break;
    case (1): State |= (u8)((CAN->TSR & CAN_TSR_RQCP1) >> 6);
      State |= (u8)((CAN->TSR & CAN_TSR_TXOK1) >> 8);
    1c0c:	f401 7100 	and.w	r1, r1, #512	; 0x200
    1c10:	0992      	lsrs	r2, r2, #6
    1c12:	ea42 2211 	orr.w	r2, r2, r1, lsr #8
      State |= (u8)((CAN->TSR & CAN_TSR_TME1) >> 27);
    1c16:	f000 6000 	and.w	r0, r0, #134217728	; 0x8000000
    1c1a:	ea42 60d0 	orr.w	r0, r2, r0, lsr #27
    default:
      State = CANTXFAILED;
      break;
  }

  switch (State)
    1c1e:	2800      	cmp	r0, #0
    1c20:	d0d4      	beq.n	1bcc <CAN_TransmitStatus+0x38>
    1c22:	e7cc      	b.n	1bbe <CAN_TransmitStatus+0x2a>

00001c24 <CAN_CancelTransmit>:
{
  /* Check the parameters */
  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));

  /* abort transmission */
  switch (Mailbox)
    1c24:	2801      	cmp	r0, #1
    1c26:	d014      	beq.n	1c52 <CAN_CancelTransmit+0x2e>
    1c28:	d30a      	bcc.n	1c40 <CAN_CancelTransmit+0x1c>
    1c2a:	2802      	cmp	r0, #2
    1c2c:	d107      	bne.n	1c3e <CAN_CancelTransmit+0x1a>
  {
    case (0): CAN->TSR |= CAN_TSR_ABRQ0;
      break;
    case (1): CAN->TSR |= CAN_TSR_ABRQ1;
      break;
    case (2): CAN->TSR |= CAN_TSR_ABRQ2;
    1c2e:	f246 4200 	movw	r2, #25600	; 0x6400
    1c32:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1c36:	6893      	ldr	r3, [r2, #8]
    1c38:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    1c3c:	6093      	str	r3, [r2, #8]
      break;
    default:
      break;
  }
}
    1c3e:	4770      	bx	lr
  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));

  /* abort transmission */
  switch (Mailbox)
  {
    case (0): CAN->TSR |= CAN_TSR_ABRQ0;
    1c40:	f246 4200 	movw	r2, #25600	; 0x6400
    1c44:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1c48:	6893      	ldr	r3, [r2, #8]
    1c4a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1c4e:	6093      	str	r3, [r2, #8]
    1c50:	e7f5      	b.n	1c3e <CAN_CancelTransmit+0x1a>
      break;
    case (1): CAN->TSR |= CAN_TSR_ABRQ1;
    1c52:	f246 4200 	movw	r2, #25600	; 0x6400
    1c56:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1c5a:	6893      	ldr	r3, [r2, #8]
    1c5c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    1c60:	6093      	str	r3, [r2, #8]
    1c62:	e7ec      	b.n	1c3e <CAN_CancelTransmit+0x1a>

00001c64 <CAN_FIFORelease>:
{
  /* Check the parameters */
  assert_param(IS_CAN_FIFO(FIFONumber));

  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
    1c64:	b930      	cbnz	r0, 1c74 <CAN_FIFORelease+0x10>
  {
    CAN->RF0R = CAN_RF0R_RFOM0;
    1c66:	f246 4300 	movw	r3, #25600	; 0x6400
    1c6a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1c6e:	2220      	movs	r2, #32
    1c70:	60da      	str	r2, [r3, #12]
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    CAN->RF1R = CAN_RF1R_RFOM1;
  }
}
    1c72:	4770      	bx	lr
    CAN->RF0R = CAN_RF0R_RFOM0;
  }
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    CAN->RF1R = CAN_RF1R_RFOM1;
    1c74:	f246 4300 	movw	r3, #25600	; 0x6400
    1c78:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1c7c:	2220      	movs	r2, #32
    1c7e:	611a      	str	r2, [r3, #16]
    1c80:	e7f7      	b.n	1c72 <CAN_FIFORelease+0xe>
    1c82:	46c0      	nop			(mov r8, r8)

00001c84 <CAN_MessagePending>:
  u8 MessagePending=0;

  /* Check the parameters */
  assert_param(IS_CAN_FIFO(FIFONumber));

  if (FIFONumber == CAN_FIFO0)
    1c84:	b938      	cbnz	r0, 1c96 <CAN_MessagePending+0x12>
  {
    MessagePending = (u8)(CAN->RF0R&(u32)0x03);
    1c86:	f246 4300 	movw	r3, #25600	; 0x6400
    1c8a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1c8e:	68da      	ldr	r2, [r3, #12]
    1c90:	f002 0003 	and.w	r0, r2, #3	; 0x3
  else
  {
    MessagePending = 0;
  }
  return MessagePending;
}
    1c94:	4770      	bx	lr

  if (FIFONumber == CAN_FIFO0)
  {
    MessagePending = (u8)(CAN->RF0R&(u32)0x03);
  }
  else if (FIFONumber == CAN_FIFO1)
    1c96:	2801      	cmp	r0, #1
  {
    MessagePending = (u8)(CAN->RF1R&(u32)0x03);
    1c98:	bf01      	itttt	eq
    1c9a:	f246 4300 	movweq	r3, #25600	; 0x6400
    1c9e:	f2c4 0300 	movteq	r3, #16384	; 0x4000
    1ca2:	691a      	ldreq	r2, [r3, #16]
    1ca4:	f002 0003 	andeq.w	r0, r2, #3	; 0x3

  if (FIFONumber == CAN_FIFO0)
  {
    MessagePending = (u8)(CAN->RF0R&(u32)0x03);
  }
  else if (FIFONumber == CAN_FIFO1)
    1ca8:	bf18      	it	ne
    1caa:	2000      	movne	r0, #0
    1cac:	e7f2      	b.n	1c94 <CAN_MessagePending+0x10>
    1cae:	46c0      	nop			(mov r8, r8)

00001cb0 <CAN_Sleep>:
u8 CAN_Sleep(void)
{
  u8 SleepStatus = 0;

  /* Sleep mode entering request */
  CAN->MCR |= CAN_MCR_SLEEP;
    1cb0:	f246 4300 	movw	r3, #25600	; 0x6400
    1cb4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1cb8:	681a      	ldr	r2, [r3, #0]
    1cba:	f042 0202 	orr.w	r2, r2, #2	; 0x2
    1cbe:	601a      	str	r2, [r3, #0]
  SleepStatus = CANSLEEPOK;

  /* Sleep mode status */
  if ((CAN->MCR&CAN_MCR_SLEEP) == 0)
    1cc0:	6818      	ldr	r0, [r3, #0]
    1cc2:	0840      	lsrs	r0, r0, #1
    SleepStatus = CANSLEEPFAILED;
  }

  /* At this step, sleep mode status */
  return SleepStatus;
}
    1cc4:	f000 0001 	and.w	r0, r0, #1	; 0x1
    1cc8:	4770      	bx	lr
    1cca:	46c0      	nop			(mov r8, r8)

00001ccc <CAN_WakeUp>:
u8 CAN_WakeUp(void)
{
  u8 WakeUpStatus = 0;

  /* Wake up request */
  CAN->MCR &= ~CAN_MCR_SLEEP;
    1ccc:	f246 4300 	movw	r3, #25600	; 0x6400
    1cd0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1cd4:	681a      	ldr	r2, [r3, #0]
    1cd6:	f022 0202 	bic.w	r2, r2, #2	; 0x2
    1cda:	601a      	str	r2, [r3, #0]
  WakeUpStatus = CANWAKEUPFAILED;

  /* Sleep mode status */
  if ((CAN->MCR&CAN_MCR_SLEEP) == 0)
    1cdc:	6818      	ldr	r0, [r3, #0]
    1cde:	0840      	lsrs	r0, r0, #1
    1ce0:	f080 0001 	eor.w	r0, r0, #1	; 0x1
    WakeUpStatus = CANWAKEUPOK;
  }

  /* At this step, sleep mode status */
  return WakeUpStatus;
}
    1ce4:	f000 0001 	and.w	r0, r0, #1	; 0x1
    1ce8:	4770      	bx	lr
    1cea:	46c0      	nop			(mov r8, r8)

00001cec <CAN_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_CAN_FLAG(CAN_FLAG));

  /* Check the status of the specified CAN flag */
  if ((CAN->ESR & CAN_FLAG) != (u32)RESET)
    1cec:	f246 4300 	movw	r3, #25600	; 0x6400
    1cf0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1cf4:	699a      	ldr	r2, [r3, #24]
    1cf6:	4210      	tst	r0, r2
    /* CAN_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the CAN_FLAG status */
  return  bitstatus;
}
    1cf8:	bf0c      	ite	eq
    1cfa:	2000      	moveq	r0, #0
    1cfc:	2001      	movne	r0, #1
    1cfe:	4770      	bx	lr

00001d00 <CAN_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_CAN_FLAG(CAN_FLAG));

  /* Clear the selected CAN flags */
  CAN->ESR &= ~CAN_FLAG;
    1d00:	f246 4300 	movw	r3, #25600	; 0x6400
    1d04:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1d08:	699a      	ldr	r2, [r3, #24]
    1d0a:	43c0      	mvns	r0, r0
    1d0c:	4010      	ands	r0, r2
    1d0e:	6198      	str	r0, [r3, #24]
}
    1d10:	4770      	bx	lr
    1d12:	46c0      	nop			(mov r8, r8)

00001d14 <CAN_ClearITPendingBit>:
void CAN_ClearITPendingBit(u32 CAN_IT)
{
  /* Check the parameters */
  assert_param(IS_CAN_ITStatus(CAN_IT));

  switch (CAN_IT)
    1d14:	2820      	cmp	r0, #32
    1d16:	d04e      	beq.n	1db6 <CAN_ClearITPendingBit+0xa2>
    1d18:	d90d      	bls.n	1d36 <CAN_ClearITPendingBit+0x22>
    1d1a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    1d1e:	d05f      	beq.n	1de0 <CAN_ClearITPendingBit+0xcc>
    1d20:	d927      	bls.n	1d72 <CAN_ClearITPendingBit+0x5e>
    1d22:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
    1d26:	d06b      	beq.n	1e00 <CAN_ClearITPendingBit+0xec>
    1d28:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
    1d2c:	d061      	beq.n	1df2 <CAN_ClearITPendingBit+0xde>
    1d2e:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
    1d32:	d037      	beq.n	1da4 <CAN_ClearITPendingBit+0x90>
      CAN->MSR = CAN_MSR_SLAKI;  /* rc_w1*/
      break;
    default :
      break;
  }
}
    1d34:	4770      	bx	lr
void CAN_ClearITPendingBit(u32 CAN_IT)
{
  /* Check the parameters */
  assert_param(IS_CAN_ITStatus(CAN_IT));

  switch (CAN_IT)
    1d36:	2806      	cmp	r0, #6
  {
    case CAN_IT_RQCP0:
      CAN->TSR = CAN_TSR_RQCP0; /* rc_w1*/
      break;
    case CAN_IT_RQCP1:
      CAN->TSR = CAN_TSR_RQCP1; /* rc_w1*/
    1d38:	bf01      	itttt	eq
    1d3a:	f246 4300 	movweq	r3, #25600	; 0x6400
    1d3e:	f2c4 0300 	movteq	r3, #16384	; 0x4000
    1d42:	f44f 7280 	moveq.w	r2, #256	; 0x100
    1d46:	609a      	streq	r2, [r3, #8]
void CAN_ClearITPendingBit(u32 CAN_IT)
{
  /* Check the parameters */
  assert_param(IS_CAN_ITStatus(CAN_IT));

  switch (CAN_IT)
    1d48:	d0f4      	beq.n	1d34 <CAN_ClearITPendingBit+0x20>
    1d4a:	d920      	bls.n	1d8e <CAN_ClearITPendingBit+0x7a>
    1d4c:	2807      	cmp	r0, #7
      break;
    case CAN_IT_RQCP1:
      CAN->TSR = CAN_TSR_RQCP1; /* rc_w1*/
      break;
    case CAN_IT_RQCP2:
      CAN->TSR = CAN_TSR_RQCP2; /* rc_w1*/
    1d4e:	bf01      	itttt	eq
    1d50:	f246 4300 	movweq	r3, #25600	; 0x6400
    1d54:	f2c4 0300 	movteq	r3, #16384	; 0x4000
    1d58:	f44f 3280 	moveq.w	r2, #65536	; 0x10000
    1d5c:	609a      	streq	r2, [r3, #8]
void CAN_ClearITPendingBit(u32 CAN_IT)
{
  /* Check the parameters */
  assert_param(IS_CAN_ITStatus(CAN_IT));

  switch (CAN_IT)
    1d5e:	d0e9      	beq.n	1d34 <CAN_ClearITPendingBit+0x20>
    1d60:	2808      	cmp	r0, #8
    1d62:	d1e7      	bne.n	1d34 <CAN_ClearITPendingBit+0x20>
      break;
    case CAN_IT_FF0:
      CAN->RF0R = CAN_RF0R_FULL0; /* rc_w1*/
      break;
    case CAN_IT_FOV0:
      CAN->RF0R = CAN_RF0R_FOVR0; /* rc_w1*/
    1d64:	f246 4300 	movw	r3, #25600	; 0x6400
    1d68:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1d6c:	2210      	movs	r2, #16
    1d6e:	60da      	str	r2, [r3, #12]
    1d70:	e7e0      	b.n	1d34 <CAN_ClearITPendingBit+0x20>
void CAN_ClearITPendingBit(u32 CAN_IT)
{
  /* Check the parameters */
  assert_param(IS_CAN_ITStatus(CAN_IT));

  switch (CAN_IT)
    1d72:	2840      	cmp	r0, #64
    1d74:	d026      	beq.n	1dc4 <CAN_ClearITPendingBit+0xb0>
    1d76:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    1d7a:	d1db      	bne.n	1d34 <CAN_ClearITPendingBit+0x20>
      break;
    case CAN_IT_FOV1:
      CAN->RF1R = CAN_RF1R_FOVR1; /* rc_w1*/
      break;
    case CAN_IT_EWG:
      CAN->ESR &= ~ CAN_ESR_EWGF; /* rw */
    1d7c:	f246 4200 	movw	r2, #25600	; 0x6400
    1d80:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1d84:	6993      	ldr	r3, [r2, #24]
    1d86:	f023 0301 	bic.w	r3, r3, #1	; 0x1
    1d8a:	6193      	str	r3, [r2, #24]
    1d8c:	e7d2      	b.n	1d34 <CAN_ClearITPendingBit+0x20>
void CAN_ClearITPendingBit(u32 CAN_IT)
{
  /* Check the parameters */
  assert_param(IS_CAN_ITStatus(CAN_IT));

  switch (CAN_IT)
    1d8e:	2804      	cmp	r0, #4
    1d90:	d01f      	beq.n	1dd2 <CAN_ClearITPendingBit+0xbe>
    1d92:	2805      	cmp	r0, #5
    1d94:	d1ce      	bne.n	1d34 <CAN_ClearITPendingBit+0x20>
  {
    case CAN_IT_RQCP0:
      CAN->TSR = CAN_TSR_RQCP0; /* rc_w1*/
    1d96:	f246 4300 	movw	r3, #25600	; 0x6400
    1d9a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1d9e:	2201      	movs	r2, #1
    1da0:	609a      	str	r2, [r3, #8]
    1da2:	e7c7      	b.n	1d34 <CAN_ClearITPendingBit+0x20>
      break;
    case CAN_IT_EPV:
      CAN->ESR &= ~ CAN_ESR_EPVF; /* rw */
      break;
    case CAN_IT_BOF:
      CAN->ESR &= ~ CAN_ESR_BOFF; /* rw */
    1da4:	f246 4200 	movw	r2, #25600	; 0x6400
    1da8:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1dac:	6993      	ldr	r3, [r2, #24]
    1dae:	f023 0304 	bic.w	r3, r3, #4	; 0x4
    1db2:	6193      	str	r3, [r2, #24]
    1db4:	e7be      	b.n	1d34 <CAN_ClearITPendingBit+0x20>
      break;
    case CAN_IT_FOV0:
      CAN->RF0R = CAN_RF0R_FOVR0; /* rc_w1*/
      break;
    case CAN_IT_FF1:
      CAN->RF1R = CAN_RF1R_FULL1; /* rc_w1*/
    1db6:	f246 4300 	movw	r3, #25600	; 0x6400
    1dba:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1dbe:	2208      	movs	r2, #8
    1dc0:	611a      	str	r2, [r3, #16]
    1dc2:	e7b7      	b.n	1d34 <CAN_ClearITPendingBit+0x20>
      break;
    case CAN_IT_FOV1:
      CAN->RF1R = CAN_RF1R_FOVR1; /* rc_w1*/
    1dc4:	f246 4300 	movw	r3, #25600	; 0x6400
    1dc8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1dcc:	2210      	movs	r2, #16
    1dce:	611a      	str	r2, [r3, #16]
    1dd0:	e7b0      	b.n	1d34 <CAN_ClearITPendingBit+0x20>
      break;
    case CAN_IT_RQCP2:
      CAN->TSR = CAN_TSR_RQCP2; /* rc_w1*/
      break;
    case CAN_IT_FF0:
      CAN->RF0R = CAN_RF0R_FULL0; /* rc_w1*/
    1dd2:	f246 4300 	movw	r3, #25600	; 0x6400
    1dd6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1dda:	2208      	movs	r2, #8
    1ddc:	60da      	str	r2, [r3, #12]
    1dde:	e7a9      	b.n	1d34 <CAN_ClearITPendingBit+0x20>
      break;
    case CAN_IT_EWG:
      CAN->ESR &= ~ CAN_ESR_EWGF; /* rw */
      break;
    case CAN_IT_EPV:
      CAN->ESR &= ~ CAN_ESR_EPVF; /* rw */
    1de0:	f246 4200 	movw	r2, #25600	; 0x6400
    1de4:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1de8:	6993      	ldr	r3, [r2, #24]
    1dea:	f023 0302 	bic.w	r3, r3, #2	; 0x2
    1dee:	6193      	str	r3, [r2, #24]
    1df0:	e7a0      	b.n	1d34 <CAN_ClearITPendingBit+0x20>
      break;
    case CAN_IT_WKU:
      CAN->MSR = CAN_MSR_WKUI;  /* rc_w1*/
      break;
    case CAN_IT_SLK:
      CAN->MSR = CAN_MSR_SLAKI;  /* rc_w1*/
    1df2:	f246 4300 	movw	r3, #25600	; 0x6400
    1df6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1dfa:	2210      	movs	r2, #16
    1dfc:	605a      	str	r2, [r3, #4]
    1dfe:	e799      	b.n	1d34 <CAN_ClearITPendingBit+0x20>
      break;
    case CAN_IT_BOF:
      CAN->ESR &= ~ CAN_ESR_BOFF; /* rw */
      break;
    case CAN_IT_WKU:
      CAN->MSR = CAN_MSR_WKUI;  /* rc_w1*/
    1e00:	f246 4300 	movw	r3, #25600	; 0x6400
    1e04:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1e08:	2208      	movs	r2, #8
    1e0a:	605a      	str	r2, [r3, #4]
    1e0c:	e792      	b.n	1d34 <CAN_ClearITPendingBit+0x20>
    1e0e:	46c0      	nop			(mov r8, r8)

00001e10 <CAN_DeInit>:
* Return         : None.
*******************************************************************************/
void CAN_DeInit(void)
{
  /* Enable CAN reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, ENABLE);
    1e10:	2101      	movs	r1, #1
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CAN_DeInit(void)
{
    1e12:	b510      	push	{r4, lr}
  /* Enable CAN reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, ENABLE);
    1e14:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
    1e18:	f7ff f96c 	bl	10f4 <RCC_APB1PeriphResetCmd>
  /* Release CAN from reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, DISABLE);
    1e1c:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
    1e20:	2100      	movs	r1, #0
    1e22:	f7ff f967 	bl	10f4 <RCC_APB1PeriphResetCmd>
}
    1e26:	bd10      	pop	{r4, pc}

00001e28 <CAN_GetITStatus>:
  ITStatus pendingbitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_CAN_ITStatus(CAN_IT));

  switch (CAN_IT)
    1e28:	2820      	cmp	r0, #32
    1e2a:	d05c      	beq.n	1ee6 <CAN_GetITStatus+0xbe>
    1e2c:	d90e      	bls.n	1e4c <CAN_GetITStatus+0x24>
    1e2e:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    1e32:	d046      	beq.n	1ec2 <CAN_GetITStatus+0x9a>
    1e34:	d91a      	bls.n	1e6c <CAN_GetITStatus+0x44>
    1e36:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
    1e3a:	d066      	beq.n	1f0a <CAN_GetITStatus+0xe2>
    1e3c:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
    1e40:	d05a      	beq.n	1ef8 <CAN_GetITStatus+0xd0>
    1e42:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
    1e46:	d02a      	beq.n	1e9e <CAN_GetITStatus+0x76>
    1e48:	2000      	movs	r0, #0
      break;
  }

  /* Return the CAN_IT status */
  return  pendingbitstatus;
}
    1e4a:	4770      	bx	lr
  ITStatus pendingbitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_CAN_ITStatus(CAN_IT));

  switch (CAN_IT)
    1e4c:	2806      	cmp	r0, #6
    1e4e:	d041      	beq.n	1ed4 <CAN_GetITStatus+0xac>
    1e50:	d919      	bls.n	1e86 <CAN_GetITStatus+0x5e>
    1e52:	2807      	cmp	r0, #7
    1e54:	d02c      	beq.n	1eb0 <CAN_GetITStatus+0x88>
    1e56:	2808      	cmp	r0, #8
    1e58:	d1f6      	bne.n	1e48 <CAN_GetITStatus+0x20>
      break;
    case CAN_IT_FF0:
      pendingbitstatus = CheckITStatus(CAN->RF0R, CAN_RF0R_FULL0);
      break;
    case CAN_IT_FOV0:
      pendingbitstatus = CheckITStatus(CAN->RF0R, CAN_RF0R_FOVR0);
    1e5a:	f246 4300 	movw	r3, #25600	; 0x6400
    1e5e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1e62:	68da      	ldr	r2, [r3, #12]
    1e64:	0912      	lsrs	r2, r2, #4
    1e66:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1e6a:	e7ee      	b.n	1e4a <CAN_GetITStatus+0x22>
  ITStatus pendingbitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_CAN_ITStatus(CAN_IT));

  switch (CAN_IT)
    1e6c:	2840      	cmp	r0, #64
    1e6e:	d05e      	beq.n	1f2e <CAN_GetITStatus+0x106>
    1e70:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    1e74:	d1e8      	bne.n	1e48 <CAN_GetITStatus+0x20>
      break;
    case CAN_IT_FOV1:
      pendingbitstatus = CheckITStatus(CAN->RF1R, CAN_RF1R_FOVR1);
      break;
    case CAN_IT_EWG:
      pendingbitstatus = CheckITStatus(CAN->ESR, CAN_ESR_EWGF);
    1e76:	f246 4300 	movw	r3, #25600	; 0x6400
    1e7a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1e7e:	699a      	ldr	r2, [r3, #24]
    1e80:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1e84:	e7e1      	b.n	1e4a <CAN_GetITStatus+0x22>
  ITStatus pendingbitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_CAN_ITStatus(CAN_IT));

  switch (CAN_IT)
    1e86:	2804      	cmp	r0, #4
    1e88:	d048      	beq.n	1f1c <CAN_GetITStatus+0xf4>
    1e8a:	2805      	cmp	r0, #5
    1e8c:	d1dc      	bne.n	1e48 <CAN_GetITStatus+0x20>
  {
    case CAN_IT_RQCP0:
      pendingbitstatus = CheckITStatus(CAN->TSR, CAN_TSR_RQCP0);
    1e8e:	f246 4300 	movw	r3, #25600	; 0x6400
    1e92:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1e96:	689a      	ldr	r2, [r3, #8]
    1e98:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1e9c:	e7d5      	b.n	1e4a <CAN_GetITStatus+0x22>
      break;
    case CAN_IT_EPV:
      pendingbitstatus = CheckITStatus(CAN->ESR, CAN_ESR_EPVF);
      break;
    case CAN_IT_BOF:
      pendingbitstatus = CheckITStatus(CAN->ESR, CAN_ESR_BOFF);
    1e9e:	f246 4300 	movw	r3, #25600	; 0x6400
    1ea2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1ea6:	699a      	ldr	r2, [r3, #24]
    1ea8:	0892      	lsrs	r2, r2, #2
    1eaa:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1eae:	e7cc      	b.n	1e4a <CAN_GetITStatus+0x22>
      break;
    case CAN_IT_RQCP1:
      pendingbitstatus = CheckITStatus(CAN->TSR, CAN_TSR_RQCP1);
      break;
    case CAN_IT_RQCP2:
      pendingbitstatus = CheckITStatus(CAN->TSR, CAN_TSR_RQCP2);
    1eb0:	f246 4300 	movw	r3, #25600	; 0x6400
    1eb4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1eb8:	689a      	ldr	r2, [r3, #8]
    1eba:	0c12      	lsrs	r2, r2, #16
    1ebc:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1ec0:	e7c3      	b.n	1e4a <CAN_GetITStatus+0x22>
      break;
    case CAN_IT_EWG:
      pendingbitstatus = CheckITStatus(CAN->ESR, CAN_ESR_EWGF);
      break;
    case CAN_IT_EPV:
      pendingbitstatus = CheckITStatus(CAN->ESR, CAN_ESR_EPVF);
    1ec2:	f246 4300 	movw	r3, #25600	; 0x6400
    1ec6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1eca:	699a      	ldr	r2, [r3, #24]
    1ecc:	0852      	lsrs	r2, r2, #1
    1ece:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1ed2:	e7ba      	b.n	1e4a <CAN_GetITStatus+0x22>
  {
    case CAN_IT_RQCP0:
      pendingbitstatus = CheckITStatus(CAN->TSR, CAN_TSR_RQCP0);
      break;
    case CAN_IT_RQCP1:
      pendingbitstatus = CheckITStatus(CAN->TSR, CAN_TSR_RQCP1);
    1ed4:	f246 4300 	movw	r3, #25600	; 0x6400
    1ed8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1edc:	689a      	ldr	r2, [r3, #8]
    1ede:	0a12      	lsrs	r2, r2, #8
    1ee0:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1ee4:	e7b1      	b.n	1e4a <CAN_GetITStatus+0x22>
      break;
    case CAN_IT_FOV0:
      pendingbitstatus = CheckITStatus(CAN->RF0R, CAN_RF0R_FOVR0);
      break;
    case CAN_IT_FF1:
      pendingbitstatus = CheckITStatus(CAN->RF1R, CAN_RF1R_FULL1);
    1ee6:	f246 4300 	movw	r3, #25600	; 0x6400
    1eea:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1eee:	691a      	ldr	r2, [r3, #16]
    1ef0:	08d2      	lsrs	r2, r2, #3
    1ef2:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1ef6:	e7a8      	b.n	1e4a <CAN_GetITStatus+0x22>
      break;
    case CAN_IT_BOF:
      pendingbitstatus = CheckITStatus(CAN->ESR, CAN_ESR_BOFF);
      break;
    case CAN_IT_SLK:
      pendingbitstatus = CheckITStatus(CAN->MSR, CAN_MSR_SLAKI);
    1ef8:	f246 4300 	movw	r3, #25600	; 0x6400
    1efc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1f00:	685a      	ldr	r2, [r3, #4]
    1f02:	0912      	lsrs	r2, r2, #4
    1f04:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1f08:	e79f      	b.n	1e4a <CAN_GetITStatus+0x22>
      break;
    case CAN_IT_WKU:
      pendingbitstatus = CheckITStatus(CAN->MSR, CAN_MSR_WKUI);
    1f0a:	f246 4300 	movw	r3, #25600	; 0x6400
    1f0e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1f12:	685a      	ldr	r2, [r3, #4]
    1f14:	08d2      	lsrs	r2, r2, #3
    1f16:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1f1a:	e796      	b.n	1e4a <CAN_GetITStatus+0x22>
      break;
    case CAN_IT_RQCP2:
      pendingbitstatus = CheckITStatus(CAN->TSR, CAN_TSR_RQCP2);
      break;
    case CAN_IT_FF0:
      pendingbitstatus = CheckITStatus(CAN->RF0R, CAN_RF0R_FULL0);
    1f1c:	f246 4300 	movw	r3, #25600	; 0x6400
    1f20:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1f24:	68da      	ldr	r2, [r3, #12]
    1f26:	08d2      	lsrs	r2, r2, #3
    1f28:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1f2c:	e78d      	b.n	1e4a <CAN_GetITStatus+0x22>
      break;
    case CAN_IT_FF1:
      pendingbitstatus = CheckITStatus(CAN->RF1R, CAN_RF1R_FULL1);
      break;
    case CAN_IT_FOV1:
      pendingbitstatus = CheckITStatus(CAN->RF1R, CAN_RF1R_FOVR1);
    1f2e:	f246 4300 	movw	r3, #25600	; 0x6400
    1f32:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1f36:	691a      	ldr	r2, [r3, #16]
    1f38:	0912      	lsrs	r2, r2, #4
    1f3a:	f002 0001 	and.w	r0, r2, #1	; 0x1
    1f3e:	e784      	b.n	1e4a <CAN_GetITStatus+0x22>

00001f40 <CAN_Receive>:
* Output         : RxMessage: pointer to a structure which contains CAN Id,
*                  CAN DLC, CAN datas and FMI number.
* Return         : None.
*******************************************************************************/
void CAN_Receive(u8 FIFONumber, CanRxMsg* RxMessage)
{
    1f40:	b430      	push	{r4, r5}
    1f42:	4605      	mov	r5, r0
    1f44:	4608      	mov	r0, r1
  /* Check the parameters */
  assert_param(IS_CAN_FIFO(FIFONumber));

  /* Get the Id */
  RxMessage->IDE = (u8)0x04 & CAN->sFIFOMailBox[FIFONumber].RIR;
    1f46:	0129      	lsls	r1, r5, #4
    1f48:	f101 4280 	add.w	r2, r1, #1073741824	; 0x40000000
    1f4c:	f502 42c8 	add.w	r2, r2, #25600	; 0x6400
    1f50:	f8d2 31b0 	ldr.w	r3, [r2, #432]
    1f54:	f003 0304 	and.w	r3, r3, #4	; 0x4
    1f58:	7203      	strb	r3, [r0, #8]
  if (RxMessage->IDE == CAN_ID_STD)
    1f5a:	2b00      	cmp	r3, #0
    1f5c:	d13c      	bne.n	1fd8 <CAN_Receive+0x98>
  {
    RxMessage->StdId = (u32)0x000007FF & (CAN->sFIFOMailBox[FIFONumber].RIR >> 21);
    1f5e:	f8d2 31b0 	ldr.w	r3, [r2, #432]
    1f62:	0d5b      	lsrs	r3, r3, #21
    1f64:	6003      	str	r3, [r0, #0]
  else
  {
    RxMessage->ExtId = (u32)0x1FFFFFFF & (CAN->sFIFOMailBox[FIFONumber].RIR >> 3);
  }
  
  RxMessage->RTR = (u8)0x02 & CAN->sFIFOMailBox[FIFONumber].RIR;
    1f66:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
    1f6a:	f501 41c8 	add.w	r1, r1, #25600	; 0x6400
    1f6e:	f8d1 31b0 	ldr.w	r3, [r1, #432]
    1f72:	f246 4400 	movw	r4, #25600	; 0x6400
    1f76:	f003 0302 	and.w	r3, r3, #2	; 0x2
    1f7a:	7243      	strb	r3, [r0, #9]

  /* Get the DLC */
  RxMessage->DLC = (u8)0x0F & CAN->sFIFOMailBox[FIFONumber].RDTR;
    1f7c:	f8d1 21b4 	ldr.w	r2, [r1, #436]
  else
  {
    RxMessage->ExtId = (u32)0x1FFFFFFF & (CAN->sFIFOMailBox[FIFONumber].RIR >> 3);
  }
  
  RxMessage->RTR = (u8)0x02 & CAN->sFIFOMailBox[FIFONumber].RIR;
    1f80:	f2c4 0400 	movt	r4, #16384	; 0x4000

  /* Get the DLC */
  RxMessage->DLC = (u8)0x0F & CAN->sFIFOMailBox[FIFONumber].RDTR;
    1f84:	f002 020f 	and.w	r2, r2, #15	; 0xf
    1f88:	7282      	strb	r2, [r0, #10]

  /* Get the FMI */
  RxMessage->FMI = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDTR >> 8);
    1f8a:	f8d1 31b4 	ldr.w	r3, [r1, #436]
    1f8e:	0a1b      	lsrs	r3, r3, #8
    1f90:	74c3      	strb	r3, [r0, #19]

  /* Get the data field */
  RxMessage->Data[0] = (u8)0xFF & CAN->sFIFOMailBox[FIFONumber].RDLR;
    1f92:	f8d1 21b8 	ldr.w	r2, [r1, #440]
    1f96:	72c2      	strb	r2, [r0, #11]
  RxMessage->Data[1] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDLR >> 8);
    1f98:	f8d1 31b8 	ldr.w	r3, [r1, #440]
    1f9c:	0a1b      	lsrs	r3, r3, #8
    1f9e:	7303      	strb	r3, [r0, #12]
  RxMessage->Data[2] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDLR >> 16);
    1fa0:	f8d1 21b8 	ldr.w	r2, [r1, #440]
    1fa4:	0c12      	lsrs	r2, r2, #16
    1fa6:	7342      	strb	r2, [r0, #13]
  RxMessage->Data[3] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDLR >> 24);
    1fa8:	f8d1 31b8 	ldr.w	r3, [r1, #440]
    1fac:	0e1b      	lsrs	r3, r3, #24
    1fae:	7383      	strb	r3, [r0, #14]

  RxMessage->Data[4] = (u8)0xFF & CAN->sFIFOMailBox[FIFONumber].RDHR;
    1fb0:	f8d1 21bc 	ldr.w	r2, [r1, #444]
    1fb4:	73c2      	strb	r2, [r0, #15]
  RxMessage->Data[5] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDHR >> 8);
    1fb6:	f8d1 31bc 	ldr.w	r3, [r1, #444]
    1fba:	0a1b      	lsrs	r3, r3, #8
    1fbc:	7403      	strb	r3, [r0, #16]
  RxMessage->Data[6] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDHR >> 16);
    1fbe:	f8d1 21bc 	ldr.w	r2, [r1, #444]
    1fc2:	0c12      	lsrs	r2, r2, #16
    1fc4:	7442      	strb	r2, [r0, #17]
  RxMessage->Data[7] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDHR >> 24);
    1fc6:	f8d1 31bc 	ldr.w	r3, [r1, #444]
    1fca:	0e1b      	lsrs	r3, r3, #24
    1fcc:	7483      	strb	r3, [r0, #18]
{
  /* Check the parameters */
  assert_param(IS_CAN_FIFO(FIFONumber));

  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
    1fce:	b945      	cbnz	r5, 1fe2 <CAN_Receive+0xa2>
  {
    CAN->RF0R = CAN_RF0R_RFOM0;
    1fd0:	2320      	movs	r3, #32
    1fd2:	60e3      	str	r3, [r4, #12]
  RxMessage->Data[6] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDHR >> 16);
  RxMessage->Data[7] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDHR >> 24);

  /* Release the FIFO */
  CAN_FIFORelease(FIFONumber);
}
    1fd4:	bc30      	pop	{r4, r5}
    1fd6:	4770      	bx	lr
  {
    RxMessage->StdId = (u32)0x000007FF & (CAN->sFIFOMailBox[FIFONumber].RIR >> 21);
  }
  else
  {
    RxMessage->ExtId = (u32)0x1FFFFFFF & (CAN->sFIFOMailBox[FIFONumber].RIR >> 3);
    1fd8:	f8d2 31b0 	ldr.w	r3, [r2, #432]
    1fdc:	08db      	lsrs	r3, r3, #3
    1fde:	6043      	str	r3, [r0, #4]
    1fe0:	e7c1      	b.n	1f66 <CAN_Receive+0x26>
    CAN->RF0R = CAN_RF0R_RFOM0;
  }
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    CAN->RF1R = CAN_RF1R_RFOM1;
    1fe2:	2320      	movs	r3, #32
    1fe4:	6123      	str	r3, [r4, #16]
    1fe6:	e7f5      	b.n	1fd4 <CAN_Receive+0x94>

00001fe8 <USART_StructInit>:
* Return         : None
*******************************************************************************/
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
    1fe8:	f44f 5316 	mov.w	r3, #9600	; 0x2580
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
    1fec:	2200      	movs	r2, #0
* Return         : None
*******************************************************************************/
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
    1fee:	6003      	str	r3, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1ff0:	f04f 030c 	mov.w	r3, #12	; 0xc
*******************************************************************************/
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
    1ff4:	8082      	strh	r2, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
    1ff6:	80c2      	strh	r2, [r0, #6]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
    1ff8:	8102      	strh	r2, [r0, #8]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1ffa:	8143      	strh	r3, [r0, #10]
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
    1ffc:	8182      	strh	r2, [r0, #12]
}
    1ffe:	4770      	bx	lr

00002000 <USART_ClockInit>:
*                    the specified USART peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
    2000:	b430      	push	{r4, r5}
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;

  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
    2002:	884b      	ldrh	r3, [r1, #2]
    2004:	880c      	ldrh	r4, [r1, #0]
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
    2006:	8a02      	ldrh	r2, [r0, #16]
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;

  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
    2008:	888d      	ldrh	r5, [r1, #4]
    200a:	4323      	orrs	r3, r4
    200c:	88cc      	ldrh	r4, [r1, #6]
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= CR2_CLOCK_CLEAR_Mask;
    200e:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;

  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
    2012:	432b      	orrs	r3, r5
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= CR2_CLOCK_CLEAR_Mask;
    2014:	0412      	lsls	r2, r2, #16
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;

  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
    2016:	4323      	orrs	r3, r4
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= CR2_CLOCK_CLEAR_Mask;
    2018:	0c12      	lsrs	r2, r2, #16
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;

  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
    201a:	b29b      	uxth	r3, r3
    201c:	4313      	orrs	r3, r2
    201e:	8203      	strh	r3, [r0, #16]
}
    2020:	bc30      	pop	{r4, r5}
    2022:	4770      	bx	lr

00002024 <USART_ClockStructInit>:
* Return         : None
*******************************************************************************/
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
    2024:	2300      	movs	r3, #0
    2026:	8003      	strh	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
    2028:	8043      	strh	r3, [r0, #2]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
    202a:	8083      	strh	r3, [r0, #4]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
    202c:	80c3      	strh	r3, [r0, #6]
}
    202e:	4770      	bx	lr

00002030 <USART_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    2030:	b129      	cbz	r1, 203e <USART_Cmd+0xe>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
    2032:	8983      	ldrh	r3, [r0, #12]
    2034:	b29b      	uxth	r3, r3
    2036:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    203a:	8183      	strh	r3, [r0, #12]
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
  }
}
    203c:	4770      	bx	lr
    USARTx->CR1 |= CR1_UE_Set;
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
    203e:	8983      	ldrh	r3, [r0, #12]
    2040:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    2044:	041b      	lsls	r3, r3, #16
    2046:	0c1b      	lsrs	r3, r3, #16
    2048:	8183      	strh	r3, [r0, #12]
    204a:	e7f7      	b.n	203c <USART_Cmd+0xc>

0000204c <USART_ITConfig>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
{
    204c:	b510      	push	{r4, lr}
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  usartxbase = (*(u32*)&(USARTx));

  /* Get the USART register index */
  usartreg = (((u8)USART_IT) >> 0x05);
    204e:	b2cb      	uxtb	r3, r1
    2050:	ea4f 1e53 	mov.w	lr, r3, lsr #5

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;

  itmask = (((u32)0x01) << itpos);
    2054:	f001 011f 	and.w	r1, r1, #31	; 0x1f
    2058:	2301      	movs	r3, #1
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
{
    205a:	b082      	sub	sp, #8
    205c:	4614      	mov	r4, r2
  usartreg = (((u8)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;

  itmask = (((u32)0x01) << itpos);
    205e:	fa13 f201 	lsls.w	r2, r3, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
    2062:	459e      	cmp	lr, r3
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
{
    2064:	9001      	str	r0, [sp, #4]
  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;

  itmask = (((u32)0x01) << itpos);
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
    2066:	d00e      	beq.n	2086 <USART_ITConfig+0x3a>
  {
    usartxbase += 0x0C;
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
    2068:	f1be 0f02 	cmp.w	lr, #2	; 0x2
    206c:	d00d      	beq.n	208a <USART_ITConfig+0x3e>
  {
    usartxbase += 0x10;
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
    206e:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
    2070:	b124      	cbz	r4, 207c <USART_ITConfig+0x30>
  {
    *(vu32*)usartxbase  |= itmask;
    2072:	6803      	ldr	r3, [r0, #0]
    2074:	4313      	orrs	r3, r2
    2076:	6003      	str	r3, [r0, #0]
  }
  else
  {
    *(vu32*)usartxbase &= ~itmask;
  }
}
    2078:	b002      	add	sp, #8
    207a:	bd10      	pop	{r4, pc}
  {
    *(vu32*)usartxbase  |= itmask;
  }
  else
  {
    *(vu32*)usartxbase &= ~itmask;
    207c:	6803      	ldr	r3, [r0, #0]
    207e:	43d2      	mvns	r2, r2
    2080:	4013      	ands	r3, r2
    2082:	6003      	str	r3, [r0, #0]
    2084:	e7f8      	b.n	2078 <USART_ITConfig+0x2c>

  itmask = (((u32)0x01) << itpos);
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
  {
    usartxbase += 0x0C;
    2086:	300c      	adds	r0, #12
    2088:	e7f2      	b.n	2070 <USART_ITConfig+0x24>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
  {
    usartxbase += 0x10;
    208a:	3010      	adds	r0, #16
    208c:	e7f0      	b.n	2070 <USART_ITConfig+0x24>
    208e:	46c0      	nop			(mov r8, r8)

00002090 <USART_DMACmd>:
  /* Check the parameters */
  assert_param(IS_USART_1234_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
    2090:	b12a      	cbz	r2, 209e <USART_DMACmd+0xe>
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
    2092:	8a83      	ldrh	r3, [r0, #20]
    2094:	b29b      	uxth	r3, r3
    2096:	ea41 0303 	orr.w	r3, r1, r3
    209a:	8283      	strh	r3, [r0, #20]
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (u16)~USART_DMAReq;
  }
}
    209c:	4770      	bx	lr
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (u16)~USART_DMAReq;
    209e:	8a83      	ldrh	r3, [r0, #20]
    20a0:	43ca      	mvns	r2, r1
    20a2:	b29b      	uxth	r3, r3
    20a4:	4013      	ands	r3, r2
    20a6:	8283      	strh	r3, [r0, #20]
    20a8:	e7f8      	b.n	209c <USART_DMACmd+0xc>
    20aa:	46c0      	nop			(mov r8, r8)

000020ac <USART_SetAddress>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS(USART_Address)); 
    
  /* Clear the USART address */
  USARTx->CR2 &= CR2_Address_Mask;
    20ac:	8a03      	ldrh	r3, [r0, #16]
    20ae:	f023 030f 	bic.w	r3, r3, #15	; 0xf
    20b2:	041b      	lsls	r3, r3, #16
    20b4:	0c1b      	lsrs	r3, r3, #16
    20b6:	8203      	strh	r3, [r0, #16]
  /* Set the USART address node */
  USARTx->CR2 |= USART_Address;
    20b8:	8a02      	ldrh	r2, [r0, #16]
    20ba:	b292      	uxth	r2, r2
    20bc:	430a      	orrs	r2, r1
    20be:	8202      	strh	r2, [r0, #16]
}
    20c0:	4770      	bx	lr
    20c2:	46c0      	nop			(mov r8, r8)

000020c4 <USART_WakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_WAKEUP(USART_WakeUp));
  
  USARTx->CR1 &= CR1_WAKE_Mask;
    20c4:	8983      	ldrh	r3, [r0, #12]
    20c6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    20ca:	041b      	lsls	r3, r3, #16
    20cc:	0c1b      	lsrs	r3, r3, #16
    20ce:	8183      	strh	r3, [r0, #12]
  USARTx->CR1 |= USART_WakeUp;
    20d0:	8982      	ldrh	r2, [r0, #12]
    20d2:	b292      	uxth	r2, r2
    20d4:	4311      	orrs	r1, r2
    20d6:	8181      	strh	r1, [r0, #12]
}
    20d8:	4770      	bx	lr
    20da:	46c0      	nop			(mov r8, r8)

000020dc <USART_ReceiverWakeUpCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
    20dc:	b129      	cbz	r1, 20ea <USART_ReceiverWakeUpCmd+0xe>
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= CR1_RWU_Set;
    20de:	8983      	ldrh	r3, [r0, #12]
    20e0:	b29b      	uxth	r3, r3
    20e2:	f043 0302 	orr.w	r3, r3, #2	; 0x2
    20e6:	8183      	strh	r3, [r0, #12]
  else
  {
    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    USARTx->CR1 &= CR1_RWU_Reset;
  }
}
    20e8:	4770      	bx	lr
    USARTx->CR1 |= CR1_RWU_Set;
  }
  else
  {
    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    USARTx->CR1 &= CR1_RWU_Reset;
    20ea:	8983      	ldrh	r3, [r0, #12]
    20ec:	f023 0302 	bic.w	r3, r3, #2	; 0x2
    20f0:	041b      	lsls	r3, r3, #16
    20f2:	0c1b      	lsrs	r3, r3, #16
    20f4:	8183      	strh	r3, [r0, #12]
    20f6:	e7f7      	b.n	20e8 <USART_ReceiverWakeUpCmd+0xc>

000020f8 <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
  
  USARTx->CR2 &= CR2_LBDL_Mask;
    20f8:	8a03      	ldrh	r3, [r0, #16]
    20fa:	f023 0320 	bic.w	r3, r3, #32	; 0x20
    20fe:	041b      	lsls	r3, r3, #16
    2100:	0c1b      	lsrs	r3, r3, #16
    2102:	8203      	strh	r3, [r0, #16]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
    2104:	8a02      	ldrh	r2, [r0, #16]
    2106:	b292      	uxth	r2, r2
    2108:	4311      	orrs	r1, r2
    210a:	8201      	strh	r1, [r0, #16]
}
    210c:	4770      	bx	lr
    210e:	46c0      	nop			(mov r8, r8)

00002110 <USART_LINCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    2110:	b129      	cbz	r1, 211e <USART_LINCmd+0xe>
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= CR2_LINEN_Set;
    2112:	8a03      	ldrh	r3, [r0, #16]
    2114:	b29b      	uxth	r3, r3
    2116:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    211a:	8203      	strh	r3, [r0, #16]
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= CR2_LINEN_Reset;
  }
}
    211c:	4770      	bx	lr
    USARTx->CR2 |= CR2_LINEN_Set;
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= CR2_LINEN_Reset;
    211e:	8a03      	ldrh	r3, [r0, #16]
    2120:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    2124:	041b      	lsls	r3, r3, #16
    2126:	0c1b      	lsrs	r3, r3, #16
    2128:	8203      	strh	r3, [r0, #16]
    212a:	e7f7      	b.n	211c <USART_LINCmd+0xc>

0000212c <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (u16)0x01FF);
    212c:	05c9      	lsls	r1, r1, #23
    212e:	0dc9      	lsrs	r1, r1, #23
    2130:	8081      	strh	r1, [r0, #4]
}
    2132:	4770      	bx	lr

00002134 <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (u16)(USARTx->DR & (u16)0x01FF);
    2134:	8880      	ldrh	r0, [r0, #4]
}
    2136:	05c0      	lsls	r0, r0, #23
    2138:	0dc0      	lsrs	r0, r0, #23
    213a:	4770      	bx	lr

0000213c <USART_SendBreak>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Send break characters */
  USARTx->CR1 |= CR1_SBK_Set;
    213c:	8983      	ldrh	r3, [r0, #12]
    213e:	b29b      	uxth	r3, r3
    2140:	f043 0301 	orr.w	r3, r3, #1	; 0x1
    2144:	8183      	strh	r3, [r0, #12]
}
    2146:	4770      	bx	lr

00002148 <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  
  /* Clear the USART Guard time */
  USARTx->GTPR &= GTPR_LSB_Mask;
    2148:	8b03      	ldrh	r3, [r0, #24]
    214a:	b2db      	uxtb	r3, r3
    214c:	8303      	strh	r3, [r0, #24]
  /* Set the USART guard time */
  USARTx->GTPR |= (u16)((u16)USART_GuardTime << 0x08);
    214e:	8b02      	ldrh	r2, [r0, #24]
    2150:	b292      	uxth	r2, r2
    2152:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    2156:	8302      	strh	r2, [r0, #24]
}
    2158:	4770      	bx	lr
    215a:	46c0      	nop			(mov r8, r8)

0000215c <USART_SetPrescaler>:
{ 
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART prescaler */
  USARTx->GTPR &= GTPR_MSB_Mask;
    215c:	8b03      	ldrh	r3, [r0, #24]
    215e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2162:	8303      	strh	r3, [r0, #24]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
    2164:	8b02      	ldrh	r2, [r0, #24]
    2166:	b292      	uxth	r2, r2
    2168:	430a      	orrs	r2, r1
    216a:	8302      	strh	r2, [r0, #24]
}
    216c:	4770      	bx	lr
    216e:	46c0      	nop			(mov r8, r8)

00002170 <USART_SmartCardCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
    2170:	b129      	cbz	r1, 217e <USART_SmartCardCmd+0xe>
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= CR3_SCEN_Set;
    2172:	8a83      	ldrh	r3, [r0, #20]
    2174:	b29b      	uxth	r3, r3
    2176:	f043 0320 	orr.w	r3, r3, #32	; 0x20
    217a:	8283      	strh	r3, [r0, #20]
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= CR3_SCEN_Reset;
  }
}
    217c:	4770      	bx	lr
    USARTx->CR3 |= CR3_SCEN_Set;
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= CR3_SCEN_Reset;
    217e:	8a83      	ldrh	r3, [r0, #20]
    2180:	f023 0320 	bic.w	r3, r3, #32	; 0x20
    2184:	041b      	lsls	r3, r3, #16
    2186:	0c1b      	lsrs	r3, r3, #16
    2188:	8283      	strh	r3, [r0, #20]
    218a:	e7f7      	b.n	217c <USART_SmartCardCmd+0xc>

0000218c <USART_SmartCardNACKCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
    218c:	b129      	cbz	r1, 219a <USART_SmartCardNACKCmd+0xe>
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= CR3_NACK_Set;
    218e:	8a83      	ldrh	r3, [r0, #20]
    2190:	b29b      	uxth	r3, r3
    2192:	f043 0310 	orr.w	r3, r3, #16	; 0x10
    2196:	8283      	strh	r3, [r0, #20]
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= CR3_NACK_Reset;
  }
}
    2198:	4770      	bx	lr
    USARTx->CR3 |= CR3_NACK_Set;
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= CR3_NACK_Reset;
    219a:	8a83      	ldrh	r3, [r0, #20]
    219c:	f023 0310 	bic.w	r3, r3, #16	; 0x10
    21a0:	041b      	lsls	r3, r3, #16
    21a2:	0c1b      	lsrs	r3, r3, #16
    21a4:	8283      	strh	r3, [r0, #20]
    21a6:	e7f7      	b.n	2198 <USART_SmartCardNACKCmd+0xc>

000021a8 <USART_HalfDuplexCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    21a8:	b129      	cbz	r1, 21b6 <USART_HalfDuplexCmd+0xe>
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= CR3_HDSEL_Set;
    21aa:	8a83      	ldrh	r3, [r0, #20]
    21ac:	b29b      	uxth	r3, r3
    21ae:	f043 0308 	orr.w	r3, r3, #8	; 0x8
    21b2:	8283      	strh	r3, [r0, #20]
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= CR3_HDSEL_Reset;
  }
}
    21b4:	4770      	bx	lr
    USARTx->CR3 |= CR3_HDSEL_Set;
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= CR3_HDSEL_Reset;
    21b6:	8a83      	ldrh	r3, [r0, #20]
    21b8:	f023 0308 	bic.w	r3, r3, #8	; 0x8
    21bc:	041b      	lsls	r3, r3, #16
    21be:	0c1b      	lsrs	r3, r3, #16
    21c0:	8283      	strh	r3, [r0, #20]
    21c2:	e7f7      	b.n	21b4 <USART_HalfDuplexCmd+0xc>

000021c4 <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
    
  USARTx->CR3 &= CR3_IRLP_Mask;
    21c4:	8a83      	ldrh	r3, [r0, #20]
    21c6:	f023 0304 	bic.w	r3, r3, #4	; 0x4
    21ca:	041b      	lsls	r3, r3, #16
    21cc:	0c1b      	lsrs	r3, r3, #16
    21ce:	8283      	strh	r3, [r0, #20]
  USARTx->CR3 |= USART_IrDAMode;
    21d0:	8a82      	ldrh	r2, [r0, #20]
    21d2:	b292      	uxth	r2, r2
    21d4:	4311      	orrs	r1, r2
    21d6:	8281      	strh	r1, [r0, #20]
}
    21d8:	4770      	bx	lr
    21da:	46c0      	nop			(mov r8, r8)

000021dc <USART_IrDACmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
    21dc:	b129      	cbz	r1, 21ea <USART_IrDACmd+0xe>
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= CR3_IREN_Set;
    21de:	8a83      	ldrh	r3, [r0, #20]
    21e0:	b29b      	uxth	r3, r3
    21e2:	f043 0302 	orr.w	r3, r3, #2	; 0x2
    21e6:	8283      	strh	r3, [r0, #20]
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= CR3_IREN_Reset;
  }
}
    21e8:	4770      	bx	lr
    USARTx->CR3 |= CR3_IREN_Set;
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= CR3_IREN_Reset;
    21ea:	8a83      	ldrh	r3, [r0, #20]
    21ec:	f023 0302 	bic.w	r3, r3, #2	; 0x2
    21f0:	041b      	lsls	r3, r3, #16
    21f2:	0c1b      	lsrs	r3, r3, #16
    21f4:	8283      	strh	r3, [r0, #20]
    21f6:	e7f7      	b.n	21e8 <USART_IrDACmd+0xc>

000021f8 <USART_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_FLAG(USART_FLAG));
  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   

  if ((USARTx->SR & USART_FLAG) != (u16)RESET)
    21f8:	8803      	ldrh	r3, [r0, #0]
    21fa:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
    21fc:	bf0c      	ite	eq
    21fe:	2000      	moveq	r0, #0
    2200:	2001      	movne	r0, #1
    2202:	4770      	bx	lr

00002204 <USART_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
   
  USARTx->SR = (u16)~USART_FLAG;
    2204:	43c9      	mvns	r1, r1
    2206:	b289      	uxth	r1, r1
    2208:	8001      	strh	r1, [r0, #0]
}
    220a:	4770      	bx	lr

0000220c <USART_GetITStatus>:
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IT(USART_IT));
  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
  
  /* Get the USART register index */
  usartreg = (((u8)USART_IT) >> 0x05);
    220c:	b2cb      	uxtb	r3, r1
*                       - USART_IT_PE:   Parity Error interrupt
* Output         : None
* Return         : The new state of USART_IT (SET or RESET).
*******************************************************************************/
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT)
{
    220e:	b500      	push	{lr}
  usartreg = (((u8)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;

  itmask = (u32)0x01 << itmask;
    2210:	f001 021f 	and.w	r2, r1, #31	; 0x1f
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IT(USART_IT));
  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
  
  /* Get the USART register index */
  usartreg = (((u8)USART_IT) >> 0x05);
    2214:	ea4f 1e53 	mov.w	lr, r3, lsr #5

  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;

  itmask = (u32)0x01 << itmask;
    2218:	2301      	movs	r3, #1
    221a:	fa13 f202 	lsls.w	r2, r3, r2
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
    221e:	459e      	cmp	lr, r3
  {
    itmask &= USARTx->CR1;
    2220:	bf02      	ittt	eq
    2222:	8983      	ldrheq	r3, [r0, #12]
    2224:	b29b      	uxtheq	r3, r3
    2226:	ea02 0e03 	andeq.w	lr, r2, r3
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;

  itmask = (u32)0x01 << itmask;
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
    222a:	d00b      	beq.n	2244 <USART_GetITStatus+0x38>
  {
    itmask &= USARTx->CR1;
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
    222c:	f1be 0f02 	cmp.w	lr, #2	; 0x2
  {
    itmask &= USARTx->CR2;
    2230:	bf0b      	itete	eq
    2232:	8a03      	ldrheq	r3, [r0, #16]
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
    2234:	8a83      	ldrhne	r3, [r0, #20]
  {
    itmask &= USARTx->CR1;
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
  {
    itmask &= USARTx->CR2;
    2236:	b29b      	uxtheq	r3, r3
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
    2238:	b29b      	uxthne	r3, r3
  {
    itmask &= USARTx->CR1;
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
  {
    itmask &= USARTx->CR2;
    223a:	bf0c      	ite	eq
    223c:	ea02 0e03 	andeq.w	lr, r2, r3
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
    2240:	ea02 0e03 	andne.w	lr, r2, r3
  }
  
  bitpos = USART_IT >> 0x08;

  bitpos = (u32)0x01 << bitpos;
    2244:	0a09      	lsrs	r1, r1, #8
    2246:	2201      	movs	r2, #1
    2248:	408a      	lsls	r2, r1
  bitpos &= USARTx->SR;
    224a:	8803      	ldrh	r3, [r0, #0]
    224c:	b29b      	uxth	r3, r3

  if ((itmask != (u16)RESET)&&(bitpos != (u16)RESET))
    224e:	421a      	tst	r2, r3
    2250:	bf0c      	ite	eq
    2252:	2000      	moveq	r0, #0
    2254:	2001      	movne	r0, #1
  {
    bitstatus = RESET;
  }
  
  return bitstatus;  
}
    2256:	f1be 0f00 	cmp.w	lr, #0	; 0x0
    225a:	bf0c      	ite	eq
    225c:	2000      	moveq	r0, #0
    225e:	f000 0001 	andne.w	r0, r0, #1	; 0x1
    2262:	bd00      	pop	{pc}

00002264 <USART_ClearITPendingBit>:
  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
  
  bitpos = USART_IT >> 0x08;

  itmask = (u16)((u16)0x01 << bitpos);
  USARTx->SR = (u16)~itmask;
    2264:	0a09      	lsrs	r1, r1, #8
    2266:	2301      	movs	r3, #1
    2268:	408b      	lsls	r3, r1
    226a:	43db      	mvns	r3, r3
    226c:	b29b      	uxth	r3, r3
    226e:	8003      	strh	r3, [r0, #0]
}
    2270:	4770      	bx	lr
    2272:	46c0      	nop			(mov r8, r8)

00002274 <USART_Init>:
  assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
  
  usartxbase = (*(u32*)&USARTx);

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
    2274:	8a03      	ldrh	r3, [r0, #16]
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (u32)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
    2276:	88ca      	ldrh	r2, [r1, #6]
  usartxbase = (*(u32*)&USARTx);

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
    2278:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
*                    specified USART peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
    227c:	b530      	push	{r4, r5, lr}
  usartxbase = (*(u32*)&USARTx);

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
    227e:	041b      	lsls	r3, r3, #16
    2280:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (u32)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
    2282:	4313      	orrs	r3, r2
    2284:	8203      	strh	r3, [r0, #16]
*                    specified USART peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
    2286:	460d      	mov	r5, r1
  
  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
    2288:	8981      	ldrh	r1, [r0, #12]
*                    specified USART peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
    228a:	b089      	sub	sp, #36
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (u16)tmpreg;
    228c:	88ab      	ldrh	r3, [r5, #4]
    228e:	892a      	ldrh	r2, [r5, #8]
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  /* The hardware flow control is available only for USART1, USART2 and USART3 */          
  assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
  
  usartxbase = (*(u32*)&USARTx);
    2290:	4604      	mov	r4, r0
*                    specified USART peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
    2292:	9001      	str	r0, [sp, #4]
  USARTx->CR2 = (u16)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
    2294:	f421 51b0 	bic.w	r1, r1, #5632	; 0x1600
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (u16)tmpreg;
    2298:	8968      	ldrh	r0, [r5, #10]
    229a:	431a      	orrs	r2, r3
  USARTx->CR2 = (u16)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
    229c:	f021 010c 	bic.w	r1, r1, #12	; 0xc
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (u16)tmpreg;
    22a0:	4302      	orrs	r2, r0
  USARTx->CR2 = (u16)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
    22a2:	0409      	lsls	r1, r1, #16
    22a4:	0c09      	lsrs	r1, r1, #16
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (u16)tmpreg;
    22a6:	b292      	uxth	r2, r2
    22a8:	430a      	orrs	r2, r1
    22aa:	81a2      	strh	r2, [r4, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
    22ac:	8aa3      	ldrh	r3, [r4, #20]
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (u16)tmpreg;
    22ae:	89aa      	ldrh	r2, [r5, #12]
  USARTx->CR1 = (u16)tmpreg;

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
    22b0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    22b4:	041b      	lsls	r3, r3, #16
    22b6:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (u16)tmpreg;
    22b8:	4313      	orrs	r3, r2
    22ba:	82a3      	strh	r3, [r4, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
    22bc:	a803      	add	r0, sp, #12
    22be:	f7fe fe5b 	bl	f78 <RCC_GetClocksFreq>
  if (usartxbase == USART1_BASE)
    22c2:	f643 0300 	movw	r3, #14336	; 0x3800
    22c6:	f2c4 0301 	movt	r3, #16385	; 0x4001
    22ca:	429c      	cmp	r4, r3
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
    22cc:	bf0c      	ite	eq
    22ce:	9906      	ldreq	r1, [sp, #24]
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
    22d0:	9905      	ldrne	r1, [sp, #20]
  }

  /* Determine the integer part */
  integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
    22d2:	00cb      	lsls	r3, r1, #3
    22d4:	014a      	lsls	r2, r1, #5
    22d6:	1ad2      	subs	r2, r2, r3
    22d8:	682b      	ldr	r3, [r5, #0]
    22da:	1852      	adds	r2, r2, r1
    22dc:	009b      	lsls	r3, r3, #2
  tmpreg = (integerdivider / 0x64) << 0x04;
    22de:	f248 551f 	movw	r5, #34079	; 0x851f
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }

  /* Determine the integer part */
  integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
    22e2:	fbb2 f2f3 	udiv	r2, r2, r3
  tmpreg = (integerdivider / 0x64) << 0x04;
    22e6:	f2c5 15eb 	movt	r5, #20971	; 0x51eb
    22ea:	fba5 3402 	umull	r3, r4, r5, r2
    22ee:	0964      	lsrs	r4, r4, #5
    22f0:	0124      	lsls	r4, r4, #4
  /* Determine the fractional part */
  fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
  tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);

  /* Write to USART BRR */
  USARTx->BRR = (u16)tmpreg;
    22f2:	0923      	lsrs	r3, r4, #4
    22f4:	0099      	lsls	r1, r3, #2
    22f6:	011b      	lsls	r3, r3, #4
    22f8:	18c9      	adds	r1, r1, r3
    22fa:	0088      	lsls	r0, r1, #2
    22fc:	1809      	adds	r1, r1, r0
    22fe:	1a52      	subs	r2, r2, r1
    2300:	0112      	lsls	r2, r2, #4
    2302:	3232      	adds	r2, #50
    2304:	fba5 3202 	umull	r3, r2, r5, r2
    2308:	0952      	lsrs	r2, r2, #5
    230a:	f002 020f 	and.w	r2, r2, #15	; 0xf
    230e:	4322      	orrs	r2, r4
    2310:	9b01      	ldr	r3, [sp, #4]
    2312:	b292      	uxth	r2, r2
    2314:	811a      	strh	r2, [r3, #8]
}
    2316:	b009      	add	sp, #36
    2318:	bd30      	pop	{r4, r5, pc}
    231a:	46c0      	nop			(mov r8, r8)

0000231c <USART_DeInit>:
*                     - USART1, USART2, USART3, UART4 or UART5.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_DeInit(USART_TypeDef* USARTx)
{
    231c:	b500      	push	{lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  switch (*(u32*)&USARTx)
    231e:	f644 4300 	movw	r3, #19456	; 0x4c00
    2322:	f2c4 0300 	movt	r3, #16384	; 0x4000
*                     - USART1, USART2, USART3, UART4 or UART5.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_DeInit(USART_TypeDef* USARTx)
{
    2326:	b083      	sub	sp, #12
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  switch (*(u32*)&USARTx)
    2328:	4298      	cmp	r0, r3
*                     - USART1, USART2, USART3, UART4 or UART5.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_DeInit(USART_TypeDef* USARTx)
{
    232a:	9001      	str	r0, [sp, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  switch (*(u32*)&USARTx)
    232c:	d046      	beq.n	23bc <USART_DeInit+0xa0>
    232e:	d90d      	bls.n	234c <USART_DeInit+0x30>
    2330:	f245 0300 	movw	r3, #20480	; 0x5000
    2334:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2338:	4298      	cmp	r0, r3
    233a:	d029      	beq.n	2390 <USART_DeInit+0x74>
    233c:	f643 0300 	movw	r3, #14336	; 0x3800
    2340:	f2c4 0301 	movt	r3, #16385	; 0x4001
    2344:	4298      	cmp	r0, r3
    2346:	d018      	beq.n	237a <USART_DeInit+0x5e>
      break;            

    default:
      break;
  }
}
    2348:	b003      	add	sp, #12
    234a:	bd00      	pop	{pc}
void USART_DeInit(USART_TypeDef* USARTx)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  switch (*(u32*)&USARTx)
    234c:	f244 4300 	movw	r3, #17408	; 0x4400
    2350:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2354:	4298      	cmp	r0, r3
    2356:	d026      	beq.n	23a6 <USART_DeInit+0x8a>
    2358:	f644 0300 	movw	r3, #18432	; 0x4800
    235c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2360:	4298      	cmp	r0, r3
    2362:	d1f1      	bne.n	2348 <USART_DeInit+0x2c>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
      break;

    case USART3_BASE:
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    2364:	2101      	movs	r1, #1
    2366:	f44f 2080 	mov.w	r0, #262144	; 0x40000
    236a:	f7fe fec3 	bl	10f4 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
    236e:	f44f 2080 	mov.w	r0, #262144	; 0x40000
    2372:	2100      	movs	r1, #0
    2374:	f7fe febe 	bl	10f4 <RCC_APB1PeriphResetCmd>
    2378:	e7e6      	b.n	2348 <USART_DeInit+0x2c>
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  switch (*(u32*)&USARTx)
  {
    case USART1_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    237a:	2101      	movs	r1, #1
    237c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
    2380:	f7fe fea4 	bl	10cc <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
    2384:	f44f 4080 	mov.w	r0, #16384	; 0x4000
    2388:	2100      	movs	r1, #0
    238a:	f7fe fe9f 	bl	10cc <RCC_APB2PeriphResetCmd>
    238e:	e7db      	b.n	2348 <USART_DeInit+0x2c>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
      break;
    
    case UART5_BASE:
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
    2390:	2101      	movs	r1, #1
    2392:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    2396:	f7fe fead 	bl	10f4 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    239a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    239e:	2100      	movs	r1, #0
    23a0:	f7fe fea8 	bl	10f4 <RCC_APB1PeriphResetCmd>
    23a4:	e7d0      	b.n	2348 <USART_DeInit+0x2c>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
      break;

    case USART2_BASE:
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
    23a6:	2101      	movs	r1, #1
    23a8:	f44f 3000 	mov.w	r0, #131072	; 0x20000
    23ac:	f7fe fea2 	bl	10f4 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
    23b0:	f44f 3000 	mov.w	r0, #131072	; 0x20000
    23b4:	2100      	movs	r1, #0
    23b6:	f7fe fe9d 	bl	10f4 <RCC_APB1PeriphResetCmd>
    23ba:	e7c5      	b.n	2348 <USART_DeInit+0x2c>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
      break;
    
    case UART4_BASE:
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
    23bc:	2101      	movs	r1, #1
    23be:	f44f 2000 	mov.w	r0, #524288	; 0x80000
    23c2:	f7fe fe97 	bl	10f4 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
    23c6:	f44f 2000 	mov.w	r0, #524288	; 0x80000
    23ca:	2100      	movs	r1, #0
    23cc:	f7fe fe92 	bl	10f4 <RCC_APB1PeriphResetCmd>
    23d0:	e7ba      	b.n	2348 <USART_DeInit+0x2c>
    23d2:	46c0      	nop			(mov r8, r8)

000023d4 <NVIC_DeInit>:
*******************************************************************************/
void NVIC_DeInit(void)
{
  u32 index = 0;
  
  NVIC->ICER[0] = 0xFFFFFFFF;
    23d4:	f24e 1200 	movw	r2, #57600	; 0xe100
    23d8:	f2ce 0200 	movt	r2, #57344	; 0xe000
    23dc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  NVIC->ICER[1] = 0x0FFFFFFF;
    23e0:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
*******************************************************************************/
void NVIC_DeInit(void)
{
  u32 index = 0;
  
  NVIC->ICER[0] = 0xFFFFFFFF;
    23e4:	f8c2 3080 	str.w	r3, [r2, #128]
  NVIC->ICER[1] = 0x0FFFFFFF;
    23e8:	f8c2 1084 	str.w	r1, [r2, #132]
  NVIC->ICPR[0] = 0xFFFFFFFF;
    23ec:	f8c2 3180 	str.w	r3, [r2, #384]
  NVIC->ICPR[1] = 0x0FFFFFFF;
  
  for(index = 0; index < 0x0F; index++)
  {
     NVIC->IPR[index] = 0x00000000;
    23f0:	3301      	adds	r3, #1
  u32 index = 0;
  
  NVIC->ICER[0] = 0xFFFFFFFF;
  NVIC->ICER[1] = 0x0FFFFFFF;
  NVIC->ICPR[0] = 0xFFFFFFFF;
  NVIC->ICPR[1] = 0x0FFFFFFF;
    23f2:	f8c2 1184 	str.w	r1, [r2, #388]
  
  for(index = 0; index < 0x0F; index++)
  {
     NVIC->IPR[index] = 0x00000000;
    23f6:	f8c2 3300 	str.w	r3, [r2, #768]
    23fa:	f8c2 3304 	str.w	r3, [r2, #772]
    23fe:	f8c2 3308 	str.w	r3, [r2, #776]
    2402:	f8c2 330c 	str.w	r3, [r2, #780]
    2406:	f8c2 3310 	str.w	r3, [r2, #784]
    240a:	f8c2 3314 	str.w	r3, [r2, #788]
    240e:	f8c2 3318 	str.w	r3, [r2, #792]
    2412:	f8c2 331c 	str.w	r3, [r2, #796]
    2416:	f8c2 3320 	str.w	r3, [r2, #800]
    241a:	f8c2 3324 	str.w	r3, [r2, #804]
    241e:	f8c2 3328 	str.w	r3, [r2, #808]
    2422:	f8c2 332c 	str.w	r3, [r2, #812]
    2426:	f8c2 3330 	str.w	r3, [r2, #816]
    242a:	f8c2 3334 	str.w	r3, [r2, #820]
    242e:	f8c2 3338 	str.w	r3, [r2, #824]
  } 
}
    2432:	4770      	bx	lr

00002434 <NVIC_SCBDeInit>:
*******************************************************************************/
void NVIC_SCBDeInit(void)
{
  u32 index = 0x00;
  
  SCB->ICSR = 0x0A000000;
    2434:	f64e 5200 	movw	r2, #60672	; 0xed00
    2438:	f2ce 0200 	movt	r2, #57344	; 0xe000
    243c:	f04f 6320 	mov.w	r3, #167772160	; 0xa000000
    2440:	6053      	str	r3, [r2, #4]
  SCB->VTOR = 0x00000000;
  SCB->AIRCR = AIRCR_VECTKEY_MASK;
    2442:	f240 0300 	movw	r3, #0	; 0x0
void NVIC_SCBDeInit(void)
{
  u32 index = 0x00;
  
  SCB->ICSR = 0x0A000000;
  SCB->VTOR = 0x00000000;
    2446:	2100      	movs	r1, #0
  SCB->AIRCR = AIRCR_VECTKEY_MASK;
    2448:	f2c0 53fa 	movt	r3, #1530	; 0x5fa
void NVIC_SCBDeInit(void)
{
  u32 index = 0x00;
  
  SCB->ICSR = 0x0A000000;
  SCB->VTOR = 0x00000000;
    244c:	6091      	str	r1, [r2, #8]
  SCB->AIRCR = AIRCR_VECTKEY_MASK;
    244e:	60d3      	str	r3, [r2, #12]
  for(index = 0; index < 0x03; index++)
  {
     SCB->SHPR[index] = 0;
  }
  SCB->SHCSR = 0x00000000;
  SCB->CFSR = 0xFFFFFFFF;
    2450:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  u32 index = 0x00;
  
  SCB->ICSR = 0x0A000000;
  SCB->VTOR = 0x00000000;
  SCB->AIRCR = AIRCR_VECTKEY_MASK;
  SCB->SCR = 0x00000000;
    2454:	6111      	str	r1, [r2, #16]
  SCB->CCR = 0x00000000;
    2456:	6151      	str	r1, [r2, #20]
  for(index = 0; index < 0x03; index++)
  {
     SCB->SHPR[index] = 0;
    2458:	6191      	str	r1, [r2, #24]
    245a:	61d1      	str	r1, [r2, #28]
    245c:	6211      	str	r1, [r2, #32]
  }
  SCB->SHCSR = 0x00000000;
    245e:	6251      	str	r1, [r2, #36]
  SCB->CFSR = 0xFFFFFFFF;
    2460:	6293      	str	r3, [r2, #40]
  SCB->HFSR = 0xFFFFFFFF;
    2462:	62d3      	str	r3, [r2, #44]
  SCB->DFSR = 0xFFFFFFFF;
    2464:	6313      	str	r3, [r2, #48]
}
    2466:	4770      	bx	lr

00002468 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
    2468:	f240 0300 	movw	r3, #0	; 0x0
    246c:	f2c0 53fa 	movt	r3, #1530	; 0x5fa
    2470:	f64e 5200 	movw	r2, #60672	; 0xed00
    2474:	4318      	orrs	r0, r3
    2476:	f2ce 0200 	movt	r2, #57344	; 0xe000
    247a:	60d0      	str	r0, [r2, #12]
}
    247c:	4770      	bx	lr
    247e:	46c0      	nop			(mov r8, r8)

00002480 <NVIC_Init>:
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct->NVIC_IRQChannel));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
    2480:	6843      	ldr	r3, [r0, #4]
*                    specified NVIC peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
    2482:	b470      	push	{r4, r5, r6}
    2484:	4604      	mov	r4, r0
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct->NVIC_IRQChannel));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
    2486:	2b00      	cmp	r3, #0
    2488:	d035      	beq.n	24f6 <NVIC_Init+0x76>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    248a:	f64e 5300 	movw	r3, #60672	; 0xed00
    248e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2492:	68da      	ldr	r2, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    2494:	7840      	ldrb	r0, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    2496:	43d2      	mvns	r2, r2
    2498:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    249c:	0a12      	lsrs	r2, r2, #8
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    249e:	230f      	movs	r3, #15
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    24a0:	f1c2 0104 	rsb	r1, r2, #4	; 0x4
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    24a4:	40d3      	lsrs	r3, r2
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    24a6:	4088      	lsls	r0, r1
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    24a8:	7825      	ldrb	r5, [r4, #0]
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    24aa:	78a1      	ldrb	r1, [r4, #2]

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    24ac:	f005 0403 	and.w	r4, r5, #3	; 0x3
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    24b0:	400b      	ands	r3, r1
    24b2:	4303      	orrs	r3, r0

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    24b4:	00e4      	lsls	r4, r4, #3
    
    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    24b6:	21ff      	movs	r1, #255
    24b8:	40a1      	lsls	r1, r4
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    24ba:	011b      	lsls	r3, r3, #4
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    24bc:	40a3      	lsls	r3, r4
    
    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    24be:	f24e 1000 	movw	r0, #57600	; 0xe100
    24c2:	f005 02fc 	and.w	r2, r5, #252	; 0xfc
    24c6:	f2ce 0000 	movt	r0, #57344	; 0xe000
    24ca:	1810      	adds	r0, r2, r0
    24cc:	f8d0 6300 	ldr.w	r6, [r0, #768]
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    24d0:	43ca      	mvns	r2, r1
    24d2:	4032      	ands	r2, r6
    tmppriority &= tmpmask;  
    tmpreg |= tmppriority;
    24d4:	400b      	ands	r3, r1
    24d6:	4313      	orrs	r3, r2

    NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    24d8:	f8c0 3300 	str.w	r3, [r0, #768]
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    24dc:	096a      	lsrs	r2, r5, #5
    24de:	2301      	movs	r3, #1
    24e0:	f005 051f 	and.w	r5, r5, #31	; 0x1f
    24e4:	40ab      	lsls	r3, r5
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    
    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    24e6:	f24e 1c00 	movw	ip, #57600	; 0xe100
    24ea:	f2ce 0c00 	movt	ip, #57344	; 0xe000
    tmpreg |= tmppriority;

    NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    24ee:	f84c 3022 	str.w	r3, [ip, r2, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
      (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
  }
}
    24f2:	bc70      	pop	{r4, r5, r6}
    24f4:	4770      	bx	lr
      (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    24f6:	7803      	ldrb	r3, [r0, #0]
    24f8:	2201      	movs	r2, #1
    24fa:	0959      	lsrs	r1, r3, #5
    24fc:	f003 031f 	and.w	r3, r3, #31	; 0x1f
    2500:	409a      	lsls	r2, r3
    2502:	f24e 1300 	movw	r3, #57600	; 0xe100
    2506:	0089      	lsls	r1, r1, #2
    2508:	f2ce 0300 	movt	r3, #57344	; 0xe000
    250c:	18cb      	adds	r3, r1, r3
    250e:	f8c3 2080 	str.w	r2, [r3, #128]
    2512:	e7ee      	b.n	24f2 <NVIC_Init+0x72>

00002514 <NVIC_StructInit>:
* Return         : None
*******************************************************************************/
void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
{
  /* NVIC_InitStruct members default value */
  NVIC_InitStruct->NVIC_IRQChannel = 0x00;
    2514:	2300      	movs	r3, #0
    2516:	7003      	strb	r3, [r0, #0]
  NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
    2518:	7043      	strb	r3, [r0, #1]
  NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
    251a:	7083      	strb	r3, [r0, #2]
  NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
    251c:	6043      	str	r3, [r0, #4]
}
    251e:	4770      	bx	lr

00002520 <NVIC_GetCurrentPendingIRQChannel>:
* Output         : None
* Return         : Pending IRQ Channel Identifier.
*******************************************************************************/
u16 NVIC_GetCurrentPendingIRQChannel(void)
{
  return ((u16)((SCB->ICSR & (u32)0x003FF000) >> 0x0C));
    2520:	f64e 5300 	movw	r3, #60672	; 0xed00
    2524:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2528:	6858      	ldr	r0, [r3, #4]
    252a:	f24f 0200 	movw	r2, #61440	; 0xf000
    252e:	f2c0 023f 	movt	r2, #63	; 0x3f
    2532:	4010      	ands	r0, r2
    2534:	0b00      	lsrs	r0, r0, #12
}
    2536:	b280      	uxth	r0, r0
    2538:	4770      	bx	lr
    253a:	46c0      	nop			(mov r8, r8)

0000253c <NVIC_GetIRQChannelPendingBitStatus>:
  u32 tmp = 0x00;
  
  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
    253c:	f000 031f 	and.w	r3, r0, #31	; 0x1f
    2540:	2201      	movs	r2, #1
    2542:	409a      	lsls	r2, r3

  if (((NVIC->ISPR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
    2544:	0940      	lsrs	r0, r0, #5
    2546:	f24e 1300 	movw	r3, #57600	; 0xe100
    254a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    254e:	0080      	lsls	r0, r0, #2
    2550:	18c0      	adds	r0, r0, r3
    2552:	f8d0 0100 	ldr.w	r0, [r0, #256]
    2556:	4010      	ands	r0, r2
  else
  {
    pendingirqstatus = RESET;
  }
  return pendingirqstatus;
}
    2558:	4290      	cmp	r0, r2
    255a:	bf14      	ite	ne
    255c:	2000      	movne	r0, #0
    255e:	2001      	moveq	r0, #1
    2560:	4770      	bx	lr
    2562:	46c0      	nop			(mov r8, r8)

00002564 <NVIC_SetIRQChannelPendingBit>:
void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
{
  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  *(vu32*) 0xE000EF00 = (u32)NVIC_IRQChannel;
    2564:	f64e 7300 	movw	r3, #61184	; 0xef00
    2568:	f2ce 0300 	movt	r3, #57344	; 0xe000
    256c:	6018      	str	r0, [r3, #0]
}
    256e:	4770      	bx	lr

00002570 <NVIC_ClearIRQChannelPendingBit>:
void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
{
  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  NVIC->ICPR[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
    2570:	0942      	lsrs	r2, r0, #5
    2572:	2101      	movs	r1, #1
    2574:	f000 001f 	and.w	r0, r0, #31	; 0x1f
    2578:	4081      	lsls	r1, r0
    257a:	f24e 1300 	movw	r3, #57600	; 0xe100
    257e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2582:	0092      	lsls	r2, r2, #2
    2584:	18d2      	adds	r2, r2, r3
    2586:	f8c2 1180 	str.w	r1, [r2, #384]
}
    258a:	4770      	bx	lr

0000258c <NVIC_GetCurrentActiveHandler>:
* Output         : None
* Return         : Active Handler Identifier.
*******************************************************************************/
u16 NVIC_GetCurrentActiveHandler(void)
{
  return ((u16)(SCB->ICSR & (u32)0x3FF));
    258c:	f64e 5300 	movw	r3, #60672	; 0xed00
    2590:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2594:	6858      	ldr	r0, [r3, #4]
}
    2596:	0580      	lsls	r0, r0, #22
    2598:	0d80      	lsrs	r0, r0, #22
    259a:	4770      	bx	lr

0000259c <NVIC_GetIRQChannelActiveBitStatus>:
  u32 tmp = 0x00;

  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
    259c:	f000 031f 	and.w	r3, r0, #31	; 0x1f
    25a0:	2201      	movs	r2, #1
    25a2:	409a      	lsls	r2, r3

  if (((NVIC->IABR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
    25a4:	0940      	lsrs	r0, r0, #5
    25a6:	f24e 1300 	movw	r3, #57600	; 0xe100
    25aa:	f2ce 0300 	movt	r3, #57344	; 0xe000
    25ae:	0080      	lsls	r0, r0, #2
    25b0:	18c0      	adds	r0, r0, r3
    25b2:	f8d0 0200 	ldr.w	r0, [r0, #512]
    25b6:	4010      	ands	r0, r2
  else
  {
    activeirqstatus = RESET;
  }
  return activeirqstatus;
}
    25b8:	4290      	cmp	r0, r2
    25ba:	bf14      	ite	ne
    25bc:	2000      	movne	r0, #0
    25be:	2001      	moveq	r0, #1
    25c0:	4770      	bx	lr
    25c2:	46c0      	nop			(mov r8, r8)

000025c4 <NVIC_GetCPUID>:
* Output         : None
* Return         : CPU ID.
*******************************************************************************/
u32 NVIC_GetCPUID(void)
{
  return (SCB->CPUID);
    25c4:	f64e 5300 	movw	r3, #60672	; 0xed00
    25c8:	f2ce 0300 	movt	r3, #57344	; 0xe000
    25cc:	6818      	ldr	r0, [r3, #0]
}
    25ce:	4770      	bx	lr

000025d0 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (u32)0x1FFFFF80);
    25d0:	f64f 7380 	movw	r3, #65408	; 0xff80
    25d4:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    25d8:	4019      	ands	r1, r3
    25da:	f64e 5300 	movw	r3, #60672	; 0xed00
    25de:	4301      	orrs	r1, r0
    25e0:	f2ce 0300 	movt	r3, #57344	; 0xe000
    25e4:	6099      	str	r1, [r3, #8]
}
    25e6:	4770      	bx	lr

000025e8 <NVIC_GenerateSystemReset>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_GenerateSystemReset(void)
{
  SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
    25e8:	f64e 5200 	movw	r2, #60672	; 0xed00
    25ec:	f240 0304 	movw	r3, #4	; 0x4
    25f0:	f2ce 0200 	movt	r2, #57344	; 0xe000
    25f4:	f2c0 53fa 	movt	r3, #1530	; 0x5fa
    25f8:	60d3      	str	r3, [r2, #12]
}
    25fa:	4770      	bx	lr

000025fc <NVIC_GenerateCoreReset>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_GenerateCoreReset(void)
{
  SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
    25fc:	f64e 5200 	movw	r2, #60672	; 0xed00
    2600:	f240 0301 	movw	r3, #1	; 0x1
    2604:	f2ce 0200 	movt	r2, #57344	; 0xe000
    2608:	f2c0 53fa 	movt	r3, #1530	; 0x5fa
    260c:	60d3      	str	r3, [r2, #12]
}
    260e:	4770      	bx	lr

00002610 <NVIC_SystemLPConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
    2610:	b141      	cbz	r1, 2624 <NVIC_SystemLPConfig+0x14>
  {
    SCB->SCR |= LowPowerMode;
    2612:	f64e 5200 	movw	r2, #60672	; 0xed00
    2616:	f2ce 0200 	movt	r2, #57344	; 0xe000
    261a:	6913      	ldr	r3, [r2, #16]
    261c:	ea40 0303 	orr.w	r3, r0, r3
    2620:	6113      	str	r3, [r2, #16]
  }
  else
  {
    SCB->SCR &= (u32)(~(u32)LowPowerMode);
  }
}
    2622:	4770      	bx	lr
  {
    SCB->SCR |= LowPowerMode;
  }
  else
  {
    SCB->SCR &= (u32)(~(u32)LowPowerMode);
    2624:	f64e 5300 	movw	r3, #60672	; 0xed00
    2628:	f2ce 0300 	movt	r3, #57344	; 0xe000
    262c:	6919      	ldr	r1, [r3, #16]
    262e:	43c2      	mvns	r2, r0
    2630:	400a      	ands	r2, r1
    2632:	611a      	str	r2, [r3, #16]
    2634:	e7f5      	b.n	2622 <NVIC_SystemLPConfig+0x12>
    2636:	46c0      	nop			(mov r8, r8)

00002638 <NVIC_SystemHandlerConfig>:

  /* Check the parameters */
  assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
    2638:	f000 001f 	and.w	r0, r0, #31	; 0x1f
    263c:	2301      	movs	r3, #1
    263e:	fa13 f000 	lsls.w	r0, r3, r0

  if (NewState != DISABLE)
    2642:	b141      	cbz	r1, 2656 <NVIC_SystemHandlerConfig+0x1e>
  {
    SCB->SHCSR |= tmpreg;
    2644:	f64e 5200 	movw	r2, #60672	; 0xed00
    2648:	f2ce 0200 	movt	r2, #57344	; 0xe000
    264c:	6a53      	ldr	r3, [r2, #36]
    264e:	ea40 0303 	orr.w	r3, r0, r3
    2652:	6253      	str	r3, [r2, #36]
  }
  else
  {
    SCB->SHCSR &= ~tmpreg;
  }
}
    2654:	4770      	bx	lr
  {
    SCB->SHCSR |= tmpreg;
  }
  else
  {
    SCB->SHCSR &= ~tmpreg;
    2656:	f64e 5300 	movw	r3, #60672	; 0xed00
    265a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    265e:	6a59      	ldr	r1, [r3, #36]
    2660:	43c2      	mvns	r2, r0
    2662:	400a      	ands	r2, r1
    2664:	625a      	str	r2, [r3, #36]
    2666:	e7f5      	b.n	2654 <NVIC_SystemHandlerConfig+0x1c>

00002668 <NVIC_SystemHandlerPriorityConfig>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
                                      u8 SystemHandlerSubPriority)
{
    2668:	b470      	push	{r4, r5, r6}
  /* Check the parameters */
  assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    
  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    266a:	f64e 5600 	movw	r6, #60672	; 0xed00
    266e:	f2ce 0600 	movt	r6, #57344	; 0xe000
    2672:	68f3      	ldr	r3, [r6, #12]
  tmp1 = (0x4 - tmppriority);
  tmp2 = tmp2 >> tmppriority;
    
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
  tmppriority |=  SystemHandlerSubPriority & tmp2;
    2674:	24ff      	movs	r4, #255
  /* Check the parameters */
  assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    
  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    2676:	43db      	mvns	r3, r3
    2678:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    267c:	0a1b      	lsrs	r3, r3, #8
  tmp1 = (0x4 - tmppriority);
  tmp2 = tmp2 >> tmppriority;
    
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
    267e:	f1c3 0504 	rsb	r5, r3, #4	; 0x4
  tmppriority |=  SystemHandlerSubPriority & tmp2;
    2682:	fa34 f303 	lsrs.w	r3, r4, r3
    
  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
  tmp1 = (0x4 - tmppriority);
  tmp2 = tmp2 >> tmppriority;
    
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
    2686:	40a9      	lsls	r1, r5
  tmppriority |=  SystemHandlerSubPriority & tmp2;
    2688:	401a      	ands	r2, r3

  tmppriority = tmppriority << 0x04;
  tmp1 = SystemHandler & (u32)0xC0;
    268a:	f000 03c0 	and.w	r3, r0, #192	; 0xc0
  tmp1 = tmp1 >> 0x06; 
  tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
  tmppriority = tmppriority << (tmp2 * 0x08);
    268e:	0940      	lsrs	r0, r0, #5
    2690:	f000 0018 	and.w	r0, r0, #24	; 0x18
  handlermask = (u32)0xFF << (tmp2 * 0x08);
  
  SCB->SHPR[tmp1] &= ~handlermask;
    2694:	4084      	lsls	r4, r0
  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
  tmp1 = (0x4 - tmppriority);
  tmp2 = tmp2 >> tmppriority;
    
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
  tmppriority |=  SystemHandlerSubPriority & tmp2;
    2696:	430a      	orrs	r2, r1

  tmppriority = tmppriority << 0x04;
    2698:	0112      	lsls	r2, r2, #4
  tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
  tmppriority = tmppriority << (tmp2 * 0x08);
  handlermask = (u32)0xFF << (tmp2 * 0x08);
  
  SCB->SHPR[tmp1] &= ~handlermask;
  SCB->SHPR[tmp1] |= tmppriority;
    269a:	4082      	lsls	r2, r0
  tmp1 = tmp1 >> 0x06; 
  tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
  tmppriority = tmppriority << (tmp2 * 0x08);
  handlermask = (u32)0xFF << (tmp2 * 0x08);
  
  SCB->SHPR[tmp1] &= ~handlermask;
    269c:	eb06 1613 	add.w	r6, r6, r3, lsr #4
    26a0:	69b1      	ldr	r1, [r6, #24]
    26a2:	43e4      	mvns	r4, r4
    26a4:	400c      	ands	r4, r1
    26a6:	61b4      	str	r4, [r6, #24]
  SCB->SHPR[tmp1] |= tmppriority;
    26a8:	69b3      	ldr	r3, [r6, #24]
    26aa:	431a      	orrs	r2, r3
    26ac:	61b2      	str	r2, [r6, #24]
}
    26ae:	bc70      	pop	{r4, r5, r6}
    26b0:	4770      	bx	lr
    26b2:	46c0      	nop			(mov r8, r8)

000026b4 <NVIC_GetSystemHandlerPendingBitStatus>:
  u32 tmp = 0x00, tmppos = 0x00;

  /* Check the parameters */
  assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
  
  tmppos = (SystemHandler >> 0x0A);
    26b4:	0a80      	lsrs	r0, r0, #10
  tmppos &= (u32)0x0F;

  tmppos = (u32)0x01 << tmppos;
    26b6:	f000 000f 	and.w	r0, r0, #15	; 0xf
    26ba:	2201      	movs	r2, #1
    26bc:	4082      	lsls	r2, r0

  tmp = SCB->SHCSR & tmppos;
    26be:	f64e 5300 	movw	r3, #60672	; 0xed00
    26c2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    26c6:	6a58      	ldr	r0, [r3, #36]
    26c8:	ea02 0000 	and.w	r0, r2, r0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
    26cc:	4290      	cmp	r0, r2
    26ce:	bf14      	ite	ne
    26d0:	2000      	movne	r0, #0
    26d2:	2001      	moveq	r0, #1
    26d4:	4770      	bx	lr
    26d6:	46c0      	nop			(mov r8, r8)

000026d8 <NVIC_SetSystemHandlerPendingBit>:
  assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
  
  /* Get the System Handler pending bit position */
  tmp = SystemHandler & (u32)0x1F;
  /* Set the corresponding System Handler pending bit */
  SCB->ICSR |= ((u32)0x01 << tmp);
    26d8:	f000 001f 	and.w	r0, r0, #31	; 0x1f
    26dc:	2301      	movs	r3, #1
    26de:	4083      	lsls	r3, r0
    26e0:	f64e 5200 	movw	r2, #60672	; 0xed00
    26e4:	f2ce 0200 	movt	r2, #57344	; 0xe000
    26e8:	6851      	ldr	r1, [r2, #4]
    26ea:	430b      	orrs	r3, r1
    26ec:	6053      	str	r3, [r2, #4]
}
    26ee:	4770      	bx	lr

000026f0 <NVIC_ClearSystemHandlerPendingBit>:
  assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
  
  /* Get the System Handler pending bit position */
  tmp = SystemHandler & (u32)0x1F;
  /* Clear the corresponding System Handler pending bit */
  SCB->ICSR |= ((u32)0x01 << (tmp - 0x01));
    26f0:	f000 001f 	and.w	r0, r0, #31	; 0x1f
    26f4:	3801      	subs	r0, #1
    26f6:	2301      	movs	r3, #1
    26f8:	4083      	lsls	r3, r0
    26fa:	f64e 5200 	movw	r2, #60672	; 0xed00
    26fe:	f2ce 0200 	movt	r2, #57344	; 0xe000
    2702:	6851      	ldr	r1, [r2, #4]
    2704:	430b      	orrs	r3, r1
    2706:	6053      	str	r3, [r2, #4]
}
    2708:	4770      	bx	lr
    270a:	46c0      	nop			(mov r8, r8)

0000270c <NVIC_GetSystemHandlerActiveBitStatus>:
  /* Check the parameters */
  assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
  
  tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;

  tmppos = (u32)0x01 << tmppos;
    270c:	0b80      	lsrs	r0, r0, #14
    270e:	f000 000f 	and.w	r0, r0, #15	; 0xf
    2712:	2201      	movs	r2, #1
    2714:	4082      	lsls	r2, r0

  tmp = SCB->SHCSR & tmppos;
    2716:	f64e 5300 	movw	r3, #60672	; 0xed00
    271a:	f2ce 0300 	movt	r3, #57344	; 0xe000
    271e:	6a58      	ldr	r0, [r3, #36]
    2720:	ea02 0000 	and.w	r0, r2, r0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
    2724:	4290      	cmp	r0, r2
    2726:	bf14      	ite	ne
    2728:	2000      	movne	r0, #0
    272a:	2001      	moveq	r0, #1
    272c:	4770      	bx	lr
    272e:	46c0      	nop			(mov r8, r8)

00002730 <NVIC_GetFaultHandlerSources>:
  u32 tmpreg = 0x00, tmppos = 0x00;

  /* Check the parameters */
  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
  
  tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
    2730:	0c83      	lsrs	r3, r0, #18
  tmppos = (SystemHandler >> 0x14) & (u32)0x03;

  if (tmpreg == 0x00)
    2732:	f013 0303 	ands.w	r3, r3, #3	; 0x3
  {
    faultsources = SCB->HFSR;
    2736:	bf04      	itt	eq
    2738:	f64e 5300 	movweq	r3, #60672	; 0xed00
    273c:	f2ce 0300 	movteq	r3, #57344	; 0xe000
    2740:	bf08      	it	eq
    2742:	6ad8      	ldreq	r0, [r3, #44]
  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
  
  tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
  tmppos = (SystemHandler >> 0x14) & (u32)0x03;

  if (tmpreg == 0x00)
    2744:	d007      	beq.n	2756 <NVIC_GetFaultHandlerSources+0x26>
  {
    faultsources = SCB->HFSR;
  }
  else if (tmpreg == 0x01)
    2746:	2b01      	cmp	r3, #1
      faultsources &= (u32)0xFF;
    }
  }
  else
  {
    faultsources = SCB->DFSR;
    2748:	bf1e      	ittt	ne
    274a:	f64e 5300 	movwne	r3, #60672	; 0xed00
    274e:	f2ce 0300 	movtne	r3, #57344	; 0xe000
    2752:	6b18      	ldrne	r0, [r3, #48]

  if (tmpreg == 0x00)
  {
    faultsources = SCB->HFSR;
  }
  else if (tmpreg == 0x01)
    2754:	d000      	beq.n	2758 <NVIC_GetFaultHandlerSources+0x28>
  else
  {
    faultsources = SCB->DFSR;
  }
  return faultsources;
}
    2756:	4770      	bx	lr
  {
    faultsources = SCB->HFSR;
  }
  else if (tmpreg == 0x01)
  {
    faultsources = SCB->CFSR >> (tmppos * 0x08);
    2758:	f64e 5300 	movw	r3, #60672	; 0xed00

  /* Check the parameters */
  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
  
  tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
  tmppos = (SystemHandler >> 0x14) & (u32)0x03;
    275c:	0d01      	lsrs	r1, r0, #20
  {
    faultsources = SCB->HFSR;
  }
  else if (tmpreg == 0x01)
  {
    faultsources = SCB->CFSR >> (tmppos * 0x08);
    275e:	f2ce 0300 	movt	r3, #57344	; 0xe000

  /* Check the parameters */
  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
  
  tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
  tmppos = (SystemHandler >> 0x14) & (u32)0x03;
    2762:	f001 0103 	and.w	r1, r1, #3	; 0x3
  {
    faultsources = SCB->HFSR;
  }
  else if (tmpreg == 0x01)
  {
    faultsources = SCB->CFSR >> (tmppos * 0x08);
    2766:	6a98      	ldr	r0, [r3, #40]
    2768:	00ca      	lsls	r2, r1, #3
    276a:	40d0      	lsrs	r0, r2
    if (tmppos != 0x02)
    276c:	2902      	cmp	r1, #2
    {
      faultsources &= (u32)0x0F;
    276e:	bf14      	ite	ne
    2770:	f000 000f 	andne.w	r0, r0, #15	; 0xf
    }
    else
    {
      faultsources &= (u32)0xFF;
    2774:	f000 00ff 	andeq.w	r0, r0, #255	; 0xff
    2778:	e7ed      	b.n	2756 <NVIC_GetFaultHandlerSources+0x26>
    277a:	46c0      	nop			(mov r8, r8)

0000277c <NVIC_GetFaultAddress>:
  /* Check the parameters */
  assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
  
  tmp = (SystemHandler >> 0x16) & (u32)0x01;

  if (tmp == 0x00)
    277c:	f410 0f80 	tst.w	r0, #4194304	; 0x400000
  {
    faultaddress = SCB->MMFAR;
    2780:	bf0b      	itete	eq
    2782:	f64e 5300 	movweq	r3, #60672	; 0xed00
  }
  else
  {
    faultaddress = SCB->BFAR;
    2786:	f64e 5300 	movwne	r3, #60672	; 0xed00
  
  tmp = (SystemHandler >> 0x16) & (u32)0x01;

  if (tmp == 0x00)
  {
    faultaddress = SCB->MMFAR;
    278a:	f2ce 0300 	movteq	r3, #57344	; 0xe000
  }
  else
  {
    faultaddress = SCB->BFAR;
    278e:	f2ce 0300 	movtne	r3, #57344	; 0xe000
  
  tmp = (SystemHandler >> 0x16) & (u32)0x01;

  if (tmp == 0x00)
  {
    faultaddress = SCB->MMFAR;
    2792:	bf0c      	ite	eq
    2794:	6b58      	ldreq	r0, [r3, #52]
  }
  else
  {
    faultaddress = SCB->BFAR;
    2796:	6b98      	ldrne	r0, [r3, #56]
  }
  return faultaddress;
}
    2798:	4770      	bx	lr
    279a:	46c0      	nop			(mov r8, r8)

0000279c <NVIC_GetBASEPRI>:
* Input          : None
* Output         : None
* Return         : BASEPRI register value
*******************************************************************************/
u32 NVIC_GetBASEPRI(void)
{
    279c:	b510      	push	{r4, lr}
  return (__GetBASEPRI());
    279e:	f000 f869 	bl	2874 <__GetBASEPRI>
}
    27a2:	bd10      	pop	{r4, pc}

000027a4 <NVIC_BASEPRICONFIG>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_BASEPRICONFIG(u32 NewPriority)
{
    27a4:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_NVIC_BASE_PRI(NewPriority));
  
  __BASEPRICONFIG((unsigned int)(NewPriority << 0x04));
    27a6:	0100      	lsls	r0, r0, #4
    27a8:	f000 f860 	bl	286c <__BASEPRICONFIG>
}
    27ac:	bd10      	pop	{r4, pc}
    27ae:	46c0      	nop			(mov r8, r8)

000027b0 <NVIC_RESETFAULTMASK>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_RESETFAULTMASK(void)
{
    27b0:	b510      	push	{r4, lr}
  __RESETFAULTMASK();
    27b2:	f000 f84f 	bl	2854 <__RESETFAULTMASK>
}
    27b6:	bd10      	pop	{r4, pc}

000027b8 <NVIC_SETFAULTMASK>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_SETFAULTMASK(void)
{
    27b8:	b510      	push	{r4, lr}
  __SETFAULTMASK();
    27ba:	f000 f84f 	bl	285c <__SETFAULTMASK>
}
    27be:	bd10      	pop	{r4, pc}

000027c0 <NVIC_RESETPRIMASK>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_RESETPRIMASK(void)
{
    27c0:	b510      	push	{r4, lr}
  __RESETPRIMASK();
    27c2:	f000 f83b 	bl	283c <__RESETPRIMASK>
}
    27c6:	bd10      	pop	{r4, pc}

000027c8 <NVIC_SETPRIMASK>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_SETPRIMASK(void)
{
    27c8:	b510      	push	{r4, lr}
  __SETPRIMASK();
    27ca:	f000 f83b 	bl	2844 <__SETPRIMASK>
}
    27ce:	bd10      	pop	{r4, pc}

000027d0 <__WFI>:
;******************************************************************************/

#warning "DON'T USE THESE FUNCTIONS. THEY ARE ST'S MACROS!!!"

void  __WFI() {
    asm("WFI");
    27d0:	bf30      	wfi
    asm("BX r14");
    27d2:	4770      	bx	lr
}
    27d4:	4770      	bx	lr
    27d6:	46c0      	nop			(mov r8, r8)

000027d8 <__WFE>:
; Input          : None
; Return         : None
;******************************************************************************/

void  __WFE() {
    asm("WFE");
    27d8:	bf20      	wfe
    asm("BX r14");
    27da:	4770      	bx	lr
}
    27dc:	4770      	bx	lr
    27de:	46c0      	nop			(mov r8, r8)

000027e0 <__SEV>:
; Input          : None
; Return         : None
;******************************************************************************/

void  __SEV() {
    asm("SEV");
    27e0:	bf40      	sev
    asm("BX r14");
    27e2:	4770      	bx	lr
}
    27e4:	4770      	bx	lr
    27e6:	46c0      	nop			(mov r8, r8)

000027e8 <__ISB>:
; Input          : None
; Return         : None
;******************************************************************************/

void  __ISB() {
    asm("ISB");
    27e8:	f3bf 8f6f 	isb	sy
    asm("BX r14");
    27ec:	4770      	bx	lr
}
    27ee:	4770      	bx	lr

000027f0 <__DSB>:
; Input          : None
; Return         : None
;******************************************************************************/

void  __DSB() {
    asm("DSB");
    27f0:	f3bf 8f4f 	dsb	sy
    asm("BX r14");
    27f4:	4770      	bx	lr
}
    27f6:	4770      	bx	lr

000027f8 <__DMB>:
; Input          : None
; Return         : None
;******************************************************************************/

void  __DMB() {
    asm("DMB");
    27f8:	f3bf 8f5f 	dmb	sy
    asm("BX r14");
    27fc:	4770      	bx	lr
}
    27fe:	4770      	bx	lr

00002800 <__SVC>:
; Input          : None
; Return         : None
;******************************************************************************/

void  __SVC() {
    asm("SVC 1");
    2800:	df01      	svc	1
    asm("BX r14");
    2802:	4770      	bx	lr
}
    2804:	4770      	bx	lr
    2806:	46c0      	nop			(mov r8, r8)

00002808 <__MRS_CONTROL>:
; Input          : None
; Return         : - r4 : Cortex-M3 CONTROL register value.
;******************************************************************************/

void  __MRS_CONTROL() {
    asm("MRS  r0,control");
    2808:	f3ef 8014 	mrs	r0, CONTROL
    asm("BX r14");
    280c:	4770      	bx	lr
}
    280e:	4770      	bx	lr

00002810 <__MSR_CONTROL>:
; Input          : - R0 : Cortex-M3 CONTROL register new value.  
; Return         : None
;******************************************************************************/

void  __MSR_CONTROL() {
    asm("MSR control, r0");
    2810:	f380 8814 	msr	CONTROL, r0
    asm("ISB");
    2814:	f3bf 8f6f 	isb	sy
    asm("BX r14");
    2818:	4770      	bx	lr
}
    281a:	4770      	bx	lr

0000281c <__MRS_PSP>:
; Input          : None
; Return         : - r0 : Process Stack value.
;******************************************************************************/

void  __MRS_PSP() {
    asm("MRS r0, psp");
    281c:	f3ef 8009 	mrs	r0, PSP
    asm("BX r14");
    2820:	4770      	bx	lr
}
    2822:	4770      	bx	lr

00002824 <__MSR_PSP>:
; Input          : - r0 : Process Stack new value.  
; Return         : None
;******************************************************************************/

void  __MSR_PSP() {
    asm("MSR psp,  r0");
    2824:	f380 8809 	msr	PSP, r0
    asm("BX r14");
    2828:	4770      	bx	lr
}
    282a:	4770      	bx	lr

0000282c <__MRS_MSP>:
; Input          : None
; Return         : - r0 : Main Stack value.
;******************************************************************************/

void  __MRS_MSP() {
    asm("MRS r0, msp");
    282c:	f3ef 8008 	mrs	r0, MSP
    asm("BX r14");
    2830:	4770      	bx	lr
}
    2832:	4770      	bx	lr

00002834 <__MSR_MSP>:
; Input          : - r0 : Main Stack new value.  
; Return         : None
;******************************************************************************/

void  __MSR_MSP() {
    asm("MSR msp, r0");
    2834:	f380 8808 	msr	MSP, r0
    asm("BX r14");
    2838:	4770      	bx	lr
}
    283a:	4770      	bx	lr

0000283c <__RESETPRIMASK>:
; Input          : None 
; Return         : None
;******************************************************************************/

void  __RESETPRIMASK() {
    asm("CPSIE i");
    283c:	b662      	cpsie	i
    asm("BX r14");
    283e:	4770      	bx	lr
}
    2840:	4770      	bx	lr
    2842:	46c0      	nop			(mov r8, r8)

00002844 <__SETPRIMASK>:
; Input          : None 
; Return         : None
;******************************************************************************/

void  __SETPRIMASK() {
    asm("CPSID i");
    2844:	b672      	cpsid	i
    asm("BX r14");
    2846:	4770      	bx	lr
}
    2848:	4770      	bx	lr
    284a:	46c0      	nop			(mov r8, r8)

0000284c <__READ_PRIMASK>:
; Input          : None 
; Return         : - r0 : PRIMASK register value 
;******************************************************************************/

void  __READ_PRIMASK() {
    asm("MRS r0, PRIMASK");
    284c:	f3ef 8010 	mrs	r0, PRIMASK
    asm("BX r14");
    2850:	4770      	bx	lr
}
    2852:	4770      	bx	lr

00002854 <__RESETFAULTMASK>:
; Input          : None 
; Return         : None
;******************************************************************************/

void  __RESETFAULTMASK() {
    asm("CPSIE f");
    2854:	b661      	cpsie	f
    asm("BX r14");
    2856:	4770      	bx	lr
}
    2858:	4770      	bx	lr
    285a:	46c0      	nop			(mov r8, r8)

0000285c <__SETFAULTMASK>:
; Input          : None 
; Return         : None
;******************************************************************************/

void  __SETFAULTMASK() {
    asm("CPSID f");
    285c:	b671      	cpsid	f
    asm("BX r14");
    285e:	4770      	bx	lr
}
    2860:	4770      	bx	lr
    2862:	46c0      	nop			(mov r8, r8)

00002864 <__READ_FAULTMASK>:
; Input          : None 
; Return         : - r0 : FAULTMASK register value 
;******************************************************************************/

void  __READ_FAULTMASK() {
    asm("MRS r0, FAULTMASK");
    2864:	f3ef 8013 	mrs	r0, FAULTMASK
    asm("BX r14");
    2868:	4770      	bx	lr
}
    286a:	4770      	bx	lr

0000286c <__BASEPRICONFIG>:
; Input          : - r0 : Base Priority new value  
; Return         : None
;******************************************************************************/

void  __BASEPRICONFIG(unsigned long basepri) {
    asm("MSR basepri, r0");
    286c:	f380 8811 	msr	BASEPRI, r0
    asm("BX r14");
    2870:	4770      	bx	lr
}
    2872:	4770      	bx	lr

00002874 <__GetBASEPRI>:
; Input          : None 
; Return         : - r0 : Base Priority value 
;******************************************************************************/

void  __GetBASEPRI() {
    asm("MRS r0, basepri_max");
    2874:	f3ef 8012 	mrs	r0, BASEPRI_MASK
    asm("BX r14");
    2878:	4770      	bx	lr
}
    287a:	4770      	bx	lr

0000287c <__REV_HalfWord>:
; Input          : - r0 : specifies the input variable
; Return         : - r0 : holds tve variable value after byte reversing.
;******************************************************************************/

void  __REV_HalfWord() {
    asm("REV16 r0, r0");
    287c:	ba40      	rev16	r0, r0
    asm("BX r14");
    287e:	4770      	bx	lr
}
    2880:	4770      	bx	lr
    2882:	46c0      	nop			(mov r8, r8)

00002884 <__REV_Word>:
; Input          : - r0 : specifies the input variable
; Return         : - r0 : holds tve variable value after byte reversing.
;******************************************************************************/

void  __REV_Word() {
    asm("REV r0, r0");
    2884:	ba00      	rev	r0, r0
    asm("BX r14");
    2886:	4770      	bx	lr
}
    2888:	4770      	bx	lr
    288a:	46c0      	nop			(mov r8, r8)

0000288c <f_cpu>:
    288c:	a200 044a 202b 4553 5f52 4143 3a4e 0020     ..J.+ SER_CAN: .
    289c:	7546 7a73 6e65 6365 656b 2772 2073 6573     Fuszenecker's se
    28ac:	6972 6c61 432d 4e41 6320 6e6f 6576 7472     rial-CAN convert
    28bc:	7265 202c 6572 656c 7361 2065 4949 002e     er, release II..
    28cc:	202b 7553 6363 7365 6673 6c75 796c 6920     + Successfully i
    28dc:	696e 6974 6c61 7a69 6465 002e 202b 6142     nitialized..+ Ba
    28ec:	6475 7220 7461 3a65 3020 0078 202c 6964     ud rate: 0x., di
    28fc:	6976 6f73 3a72 3020 0078 0000 202b 6946     visor: 0x...+ Fi
    290c:	746c 7265 3020 0078 203a 614d 6b73 203a     lter 0x.: Mask: 
    291c:	7830 0000 202c 6449 203a 7830 0000 0000     0x.., Id: 0x....
    292c:	202d 6e49 6176 696c 2064 6966 746c 7265     - Invalid filter
    293c:	6e20 6d75 6562 2e72 0000 0000 202b 654d      number.....+ Me
    294c:	7373 6761 2065 7573 6363 7365 6673 6c75     ssage successful
    295c:	796c 7320 6e65 2e74 0000 0000 202d 6e55     ly sent.....- Un
    296c:	6261 656c 7420 206f 6573 646e 6d20 7365     able to send mes
    297c:	6173 6567 002e 0000 202d 6e55 6e6b 776f     sage....- Unknow
    298c:	206e 656d 7373 6761 2065 7261 6972 6576     n message arrive
    299c:	2e64 0000 202d 6e49 6574 6e72 6c61 6520     d...- Internal e
    29ac:	7272 726f 2021 7453 706f 7520 6973 676e     rror! Stop using
    29bc:	7420 6968 2073 6564 6976 6563 0021 0000      this device!...
    29cc:	0a0d 0000 000a 0000 2023 6469 203a 7830     ........# id: 0x
    29dc:	0000 0000 202c 656c 676e 6874 203a 0000     ...., length: ..
    29ec:	202c 6164 6174 203a 7830 0000               , data: 0x..

000029f8 <xtab>:
    29f8:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
    2a08:	0000 0000                                   ....

00002a0c <APBAHBPrescTable>:
    2a0c:	0000 0000 0201 0403 0201 0403 0706 0908     ................

00002a1c <ADCPrescTable>:
    2a1c:	0402 0806                                   ....
Disassembly of section .bss:

20000000 <_bss>:
20000000:	00000000 	.word	0x00000000

20000004 <StartUpCounter>:
20000004:	00000000                                ....

20000008 <_ebss>:
	...

20000110 <usart2can>:
	...

20000218 <can_filter>:
	...

20000250 <can_id>:
	...

20000288 <can_baudrate>:
20000288:	00000000                                ....

2000028c <line>:
	...

200002cc <cr_needed>:
200002cc:	00000000                                ....

200002d0 <counter>:
200002d0:	00000000                                ....

200002d4 <line_len>:
200002d4:	00000000                                ....

200002d8 <TxMessage>:
	...

200002ec <RxMessage>:
	...
